<!DOCTYPE html>
<html lang=en><head><link href=favicon.ico rel=icon type=image/x-icon><meta name=viewport content="width=device-width, initial-scale=1.0"><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=author content="Baptiste Wicht"><title>Integer Linear Time Sorting Algorithms | @Blog("Baptiste Wicht")</title><link href=../../../assets/css/all-nocdn.css rel=stylesheet type=text/css><link rel=canonical href=http://wichtounet.github.io/posts/2012/11/integer-linear-time-sorting-algorithms.html><link rel=alternate type=application/rss+xml title=RSS href=../../../rss.xml></head><body><div class=social_container> <div class=social_container_gplus> <a target=_blank title="Share on Google+" href="https://plusone.google.com/_/+1/confirm?hl=en&amp;url=http://wichtounet.github.io/posts/2012/11/integer-linear-time-sorting-algorithms.html"><img src=../../../assets/img/google_plus.png></a> </div> <div class=social_container_facebook> <a target=_blank title="Share on Facebook" href="http://www.facebook.com/sharer/sharer.php?u=#url"><img src=../../../assets/img/facebook.png></a> </div> <div class=social_container_twitter> <a target=_blank title="Tweet on Twitter" href="http://twitter.com/home?status=#url"><img src=../../../assets/img/twitter.svg></a> </div></div><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class=navbar-toggle data-toggle=collapse data-target=.navbar-ex1-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=http://wichtounet.github.io/>@Blog("Baptiste Wicht")</a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href=../../../stories/about.html>About</a> </li><li><a href=../../../stories/publications.html>Publications</a> </li><li><a href=../../../stories/donate.html>Donate</a> </li><li><a href=../../../stories/contact.html>Contact</a> </li><li><a href=../../../stories/faq.html>FAQ</a> </li><li><a href=../../../stories/legal.html>Legal</a> </li><li><a href=../../../categories/index.html>Tags</a> </li><li><a href=../../../archive.html>Archives</a> </li><li><a href=http://feeds.feedburner.com/BaptisteWicht>RSS</a> </li></ul> <span class="navbar-form pull-left"> <form action=../../../stories/search.html> <input type=text name=q id=tipue_search_input> </form> </span> <ul class="nav navbar-nav navbar-right"> <li> <a target=_blank title="Follow @wichtounet on Twitter" href=https://twitter.com/wichtounewichtounet> <img src=../../../assets/img/twitter.svg alt="Follow @wichtounet on Twitter"> </a> </li> <li> <a target=_blank title="Follow +BaptisteWicht on Google+" href=https://plus.google.com/+BaptisteWicht> <img src=../../../assets/img/google_plus.svg alt="Follow +BaptisteWicht on Google+"> </a> </li> </ul> </div> </div></nav><div class=body-container> <div class=left-sidebar> <div class=left-sidebar-widget> <div class=left-sidebar-widget-content> <div class=g-person data-width=275 data-href=//plus.google.com/u/0/103113673902796202116 data-theme=dark data-layout=landscape data-rel=author></div> </div> </div> <div class=left-sidebar-widget> <h3>Related posts</h3> <div class=left-sidebar-widget-content> <ol><li><a href=cpp-benchmark-vector-vs-list.html>C++ benchmark - std::vector VS std::list</a></li><li><a href=../12/cpp-benchmark-vector-list-deque.html>C++ benchmark – std::vector VS std::list VS std::deque</a></li><li><a href=../12/cpp-benchmark-std-list-boost-intrusive-list.html>C++ Benchmark - std::list VS boost::intrusive::list</a></li><li><a href=gcc-4-7-clang-3-1-eddic.html>GCC 4.7 vs CLang 3.1 on eddic</a></li><li><a href=../12/wordpress-plugin-google-visualization-charts.html>New WordPress Plugin - Google Visualization Charts</a></li></ol> </div> </div> <div class=left-sidebar-widget> <h3>Recent comments</h3> <div class=left-sidebar-widget-content> <div id=recentcomments class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=28&amp;excerpt_length=50"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Popular posts</h3> <div class=left-sidebar-widget-content> <div id=popularthreads class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/popular_threads_widget.js?num_items=5&amp;days_back=90"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Blogroll</h3> <div class=left-sidebar-widget-content> <ul> <li><a target=_blank href=http://www.asjava.com/>AsJava.com : Java Tutorial</a></li> <li><a target=_blank href=http://www.mkyong.com/>Mkyong : Java Tutorials</a></li> </ul> </div> </div> </div> <div class=container> <div class=body-content style="margin-top: -75px;"> <div class=row> <article class="postbox post-text"> <div class=h-entry itemscope=itemscope itemtype=http://schema.org/Article> <h1 class=p-name itemprop="headline name">Integer Linear Time Sorting Algorithms</h1> <hr> <small> Posted: <time class="published dt-published" datetime=2012-11-07T09:02:46+01:00 itemprop=datePublished>2012-11-07 09:02</time>   |   More posts about <span itemprop=keywords> <a class="tag p-category" href=../../../categories/algorithm.html><span class="badge badge-info">Algorithm</span></a> <a class="tag p-category" href=../../../categories/benchmarks.html><span class="badge badge-info">Benchmarks</span></a> <a class="tag p-category" href=../../../categories/c.html><span class="badge badge-info">C++</span></a> <a class="tag p-category" href=../../../categories/performances.html><span class="badge badge-info">Performances</span></a> </span> </small> <hr> <div class=e-content itemprop="articleBody text"> <script type=text/javascript src=http://www.google.com/jsapi></script><script type=text/javascript>google.load('visualization','1',{packages:['corechart']});</script><p><strong>Update</strong>: The code is now more C++</p><p>Most of the sorting algorithms that are used are generally comparison sort. It means that each element of the collection being sorted will be compared to see which one is the first one. A comparison must have a lower bound of Ω(n log n) comparisons. That is why there are no comparison-based sorting algorithm better than O(n log n).</p><p>On the other hand, there are also sorting algorithms that are performing better. This is the family of the integer sorting algorithms. These algorithms are using properties of integer to sort them without comparing them. They can be only be used to sort integers. Nevertheless, a hash function can be used to assign a unique integer to any value and so sort any value. All these algorithms are using extra space. There are several of these algorithms. In this article, we will see three of them and I will present an implementation in C++. At the end of the article, I will compare them to <em>std::sort</em>.</p><p>In the article, I will use <em>n</em> as the size of the array to sort and <em>m</em> as the max number that is permitted in the array.</p><h3>Bin Sort</h3><p>Bin Sort, or Bucket Sort, is a very simple algorithm that partition all the input numbers into a number of buckets. Then, all the buckets are outputted in order in the array, resulting in a sorting array. I decided to implement the simplest case of Bin Sort where each number goes in its own bucket, so there are <em>m</em> buckets.</p><p>The implementation is pretty straightforward:</p><div class=code><pre><span class=kt>void</span> <span class=nf>binsort</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;&amp;&amp;</span> <span class=n>A</span><span class=p>){</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;&gt;</span> <span class=n>B</span><span class=p>(</span><span class=n>MAX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>

    <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SIZE</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=n>B</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]].</span><span class=n>push_back</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
    <span class=p>}</span>

    <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>current</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=n>item</span> <span class=o>:</span> <span class=n>B</span><span class=p>[</span><span class=n>i</span><span class=p>]){</span>
            <span class=n>A</span><span class=p>[</span><span class=n>current</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>item</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div><p>B is the array of buckets. Each bucket is implemented as a std::vector. The algorithm starts by filling each buckets with the numbers from the input array. Then, it outputs them in order in the array.</p><p>This algorithm works in <em>O(n + m)</em> and requires <em>O(m)</em> extra memory. With these properties, it makes a very limited algorithm, because if you don't know the maximum number and you have to use the maximum number of the array type, you will have to allocate for instance 2^32 buckets. That won't be possible.</p><h3>Couting Sort</h3><p>An interesting fact about binsort is that each bucket contains only the same numbers. The size of the bucket would be enough. That is exactly what Counting Sort. It counts the number of times an element is present instead of the elements themselves. I will present two versions. The first one is a version using a secondary array and then copying again into the input array and the second one is an in-place sort.</p><div class=code><pre><span class=kt>void</span> <span class=nf>counting_sort</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;&amp;&amp;</span> <span class=n>A</span><span class=p>){</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;</span> <span class=n>B</span><span class=p>(</span><span class=n>SIZE</span><span class=p>);</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;</span> <span class=n>C</span><span class=p>(</span><span class=n>MAX</span><span class=p>);</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SIZE</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=o>++</span><span class=n>C</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>MAX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>C</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=n>SIZE</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>B</span><span class=p>[</span><span class=n>C</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=o>--</span><span class=n>C</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SIZE</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>B</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div><p>The algorithm is also simple. It starts by counting the number of elements in each bucket. Then, it aggregates the number by summing them to obtain the position of the element in the final sorted array. Then, all the elements are copied in the temporary array. Finally, the temporary array is copied in the final array. This algorithms works in <em>O(m + n)</em> and requires <em>O(m + n)</em>. This version is presented only because it is present in the literature. We can do much better by avoiding the temporary array and optimizing it a bit:</p><div class=code><pre><span class=kt>void</span> <span class=nf>in_place_counting_sort</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;&amp;&amp;</span> <span class=n>A</span><span class=p>){</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;</span> <span class=n>C</span><span class=p>(</span><span class=n>MAX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SIZE</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=o>++</span><span class=n>C</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>current</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>j</span> <span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=o>++</span><span class=n>j</span><span class=p>){</span>
            <span class=n>A</span><span class=p>[</span><span class=n>current</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div><p>The temporary array is removed and the elements are directly written in the sorted array. The counts are not used directly as position, so there is no need to sum them. This version still works in <em>O(m + n)</em> but requires only <em>O(m)</em> extra memory. It is much faster than the previous version.</p><h3>Radix Sort</h3><p>The last version that I will discuss here is a Radix Sort. This algorithm sorts the number digit after digit in a specific radix. It is a form of bucket sort, where there is a bucket by digit. Like Counting Sort, only the counts are necessary. For example, if you use radix sort in base 10. It will first sort all the numbers by their first digit, then the second, .... It can work in any base and that is its force. With a well chosen base, it can be very powerful. Here, we will focus on radix that are in the form 2^r. These radix have good properties, we can use shifts and mask to perform division and modulo, making the algorithm much faster.</p><p>The implementation is a bit more complex than the other implementations:</p><div class=code><pre><span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>digits</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>             <span class=c1>//Digits</span>
<span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>                 <span class=c1>//Bits</span>
<span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>radix</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>r</span><span class=p>;</span>         <span class=c1>//Bins</span>
<span class=k>static</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>radix</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>radix_sort</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;&amp;&amp;</span> <span class=n>A</span><span class=p>){</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;</span> <span class=n>B</span><span class=p>(</span><span class=n>SIZE</span><span class=p>);</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=o>&gt;</span> <span class=n>cnt</span><span class=p>(</span><span class=n>radix</span><span class=p>);</span>

    <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>shift</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>digits</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>shift</span> <span class=o>+=</span> <span class=n>r</span><span class=p>){</span>
        <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>radix</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>){</span>
            <span class=n>cnt</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>SIZE</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>){</span>
            <span class=o>++</span><span class=n>cnt</span><span class=p>[(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;&gt;</span> <span class=n>shift</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>mask</span><span class=p>];</span>
        <span class=p>}</span>

        <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>radix</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>){</span>
            <span class=n>cnt</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>cnt</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
        <span class=p>}</span>

        <span class=k>for</span><span class=p>(</span><span class=kt>long</span> <span class=n>j</span> <span class=o>=</span> <span class=n>SIZE</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>j</span><span class=p>){</span>
            <span class=n>B</span><span class=p>[</span><span class=o>--</span><span class=n>cnt</span><span class=p>[(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;&gt;</span> <span class=n>shift</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>mask</span><span class=p>]]</span> <span class=o>=</span> <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
        <span class=p>}</span>

        <span class=k>for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>SIZE</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>){</span>
           <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>B</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div><p><em>r</em> indicates the power of two used as the radix (2^r). The mask is used to compute modulo faster. The algorithm repeats the steps for each digit. Here <em>digits</em> equals 2. It means that we support 2^32 values. A 32 bits value is sorted in two pass. The steps are very similar to counting sort. Each value of the digit is counted and then the counts are summed to give the position of the number. Finally, the numbers are put in order in the temporary array and copied into A.</p><p>This algorithm works in <em>O(digits (m + radix))</em> and requires <em>O(n + radix)</em> extra memory. A very good thing is that the algorithm does not require space based on the maximum value, only based on the radix.</p><h3>Results</h3><p>It's time to compare the different implementations in terms of runtime. For each size, each version is tested 25 times on different random arrays. The arrays are the same for each algorithm. The number is the time necessary to sort the 25 arrays. The benchmark has been compiler with GCC 4.7.</p><p>The first test is made with very few duplicates (m = 10n).</p><div id=graph_0 style="width: 600px; height: 400px;"></div><p><input id=button_graph_0 type=button value="Logarithmic scale"><script type=text/javascript>function draw_graph_0(){var graph=new google.visualization.ColumnChart(document.getElementById('graph_0'));var data=google.visualization.arrayToDataTable([['x','std::sort','counting_sort','in_place_counting_sort','bin_sort','radix_sort'],['100000',171,182,105,945,89],['500000',993,2229,970,6435,461],['1000000',2175,4812,2046,14096,1068],['5000000',11791,27050,10202,81255,6148],]);var options={title:"m = 10n",animation:{duration:1200,easing:"in"},width:'600px',height:'400px',hAxis:{title:"n"},vAxis:{title:"ms",viewWindow:{min:0}}};graph.draw(data,options);var button=document.getElementById('button_graph_0');button.onclick=function(){if(options.vAxis.logScale){button.value="Logarithmic Scale";}else{button.value="Normal scale";}options.vAxis.logScale=!options.vAxis.logScale;graph.draw(data,options);};}</script></p><p>Radix Sort comes to be the fastest in this case, <strong>twice faster as <em>std::sort</em></strong>. In place counting sort has almost the same performance as <em>std::sort</em>. The other are performing worse.</p><p>The second test is made with few duplicates (m ~= n).</p><div id=graph_1 style="width: 600px; height: 400px;"></div><p><input id=button_graph_1 type=button value="Logarithmic scale"><script type=text/javascript>function draw_graph_1(){var graph=new google.visualization.ColumnChart(document.getElementById('graph_1'));var data=google.visualization.arrayToDataTable([['x','std::sort','counting_sort','in_place_counting_sort','bin_sort','radix_sort'],['100000',186,73,37,309,90],['500000',991,611,189,3126,455],['1000000',2235,2171,547,7978,1038],['5000000',12184,18470,4516,49056,5791],]);var options={title:"m ~= n",animation:{duration:1200,easing:"in"},width:'600px',height:'400px',hAxis:{title:"n"},vAxis:{title:"ms",viewWindow:{min:0}}};graph.draw(data,options);var button=document.getElementById('button_graph_1');button.onclick=function(){if(options.vAxis.logScale){button.value="Logarithmic Scale";}else{button.value="Normal scale";}options.vAxis.logScale=!options.vAxis.logScale;graph.draw(data,options);};}</script></p><p>The numbers are impressive. In place <strong>counting sort is between 3-4 times faster than <em>std::sort</em></strong> and <strong>radix sort is twice faster than <em>std::sort</em></strong> ! Bin Sort does not performs very well and counting sort even if generally faster than <em>std::sort</em> does not scale very well.</p><p>Let's test with more duplicates (m = n / 2).</p><div id=graph_2 style="width: 600px; height: 400px;"></div><p><input id=button_graph_2 type=button value="Logarithmic scale"><script type=text/javascript>function draw_graph_2(){var graph=new google.visualization.ColumnChart(document.getElementById('graph_2'));var data=google.visualization.arrayToDataTable([['x','std::sort','counting_sort','in_place_counting_sort','bin_sort','radix_sort'],['100000',178,65,25,262,90],['500000',979,450,143,2332,461],['1000000',2171,1480,321,6240,1041],['5000000',11978,16205,3453,41709,5890],]);var options={title:"m = n / 2",animation:{duration:1200,easing:"in"},width:'600px',height:'400px',hAxis:{title:"n"},vAxis:{title:"ms",viewWindow:{min:0}}};graph.draw(data,options);var button=document.getElementById('button_graph_2');button.onclick=function(){if(options.vAxis.logScale){button.value="Logarithmic Scale";}else{button.value="Normal scale";}options.vAxis.logScale=!options.vAxis.logScale;graph.draw(data,options);};}</script></p><p><em>std::sort</em> and radix sort performance does not change a lot but the other sort are performing better. In-place counting sort is still the leader with a higher margin.</p><p>Finally, with a lot of duplicates (m = n / 10).</p><div id=graph_3 style="width: 600px; height: 400px;"></div><p><input id=button_graph_3 type=button value="Logarithmic scale"><script type=text/javascript>function draw_graph_3(){var graph=new google.visualization.ColumnChart(document.getElementById('graph_3'));var data=google.visualization.arrayToDataTable([['x','std::sort','counting_sort','in_place_counting_sort','bin_sort','radix_sort'],['100000',161,46,12,144,74],['500000',918,322,76,1023,449],['1000000',2062,824,167,2721,1041],['5000000',10789,8534,1030,24026,5686],]);var options={title:"m = n / 10n",animation:{duration:1200,easing:"in"},width:'600px',height:'400px',hAxis:{title:"n"},vAxis:{title:"ms",viewWindow:{min:0}}};graph.draw(data,options);var button=document.getElementById('button_graph_3');button.onclick=function(){if(options.vAxis.logScale){button.value="Logarithmic Scale";}else{button.value="Normal scale";}options.vAxis.logScale=!options.vAxis.logScale;graph.draw(data,options);};}</script></p><p>Again, <em>std::sort</em> and radix sort performance are stable, but in-place counting is now <strong>ten times faster than <em>std::sort</em></strong> !</p><h3>Conclusion</h3><p>To conclude, we have seen that these algorithms can outperforms <em>std::sort</em> by a high factor (10 times for In place Counting Sort when there m &lt;&lt; n). If you have to sort integers, you should consider these two cases:</p><ul> <li>m &gt; n or m is unknown : Use radix sort that is about twice faster than <em>std::sort</em>.</li> <li>m &lt;&lt; n : Use in place counting sort that can be much faster than <em>std::sort</em>.</li></ul><p>I hope you found this article interesting. The implementation can be found on Github: https://github.com/wichtounet/articles/tree/master/src/linear_sorting</p><script type=text/javascript>function draw_visualization(){draw_graph_0();draw_graph_1();draw_graph_2();draw_graph_3();}google.setOnLoadCallback(draw_visualization);</script> </div> </div> <ul class=pager> <li class=previous> <a href=cmakelatex-1-0-2-nomenclature-filters.html rel=prev>← Previous post</a> </li> <li class=next> <a href=eddic-compiler-1-1-4-graph-coloring-register-allocation.html rel=next>Next post →</a> </li> </ul> <div id=disqus_thread></div> <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://wichtounet.github.io/posts/2012/11/integer-linear-time-sorting-algorithms.html",
        disqus_title="Integer Linear Time Sorting Algorithms",
        disqus_identifier="cache/posts/2012/11/integer-linear-time-sorting-algorithms.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> <a href=http://disqus.com class=dsq-brlink rel=nofollow>Comments powered by <span class=logo-disqus>Disqus</span></a> </article> </div> </div> </div></div><footer> Contents © 2014 <a href=mailto:baptistewicht@gmail.com>Baptiste Wicht</a> - Powered by <a href=http://getnikola.com rel=nofollow>Nikola</a><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons License" style=padding-left:5px;border-width:0 src=../../../assets/img/cc.png></a> <ul class=footer_inline_ul> <li> <a href=integer-linear-time-sorting-algorithms.wp id=sourcelink>Source</a> </li> </ul></footer> <script src=../../../assets/js/all-nocdn.js type=text/javascript></script><script type=text/javascript src=https://apis.google.com/js/platform.js></script></body></html>