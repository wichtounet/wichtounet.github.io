<!DOCTYPE html><html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Baptiste Wicht">
    <title>Integer Linear Time Sorting Algorithms | @Blog("Baptiste Wicht")</title>
    
            <link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
      <link rel="canonical" href="http://wichtounet.github.io/posts/2012/11/integer-linear-time-sorting-algorithms.html">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">

    





    
<link rel="stylesheet" type="text/css" href="../../../assets/css/tipuesearch.css">
</head><body><div id="tipue_search_content" style="margin-left: auto; margin-right: auto; padding: 20px;"></div>




<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container-fluid"><!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://wichtounet.github.io/">@Blog("Baptiste Wicht")</a>
        </div><!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li><a href="../../../stories/about.html">About</a>
                </li><li><a href="../../../stories/publications.html">Publications</a>
                </li><li><a href="../../../stories/donate.html">Donate</a>
                </li><li><a href="../../../stories/faq.html">FAQ</a>
                </li><li><a href="../../../stories/legal.html">Legal</a>
                </li><li><a href="../../../archive.html">Archives</a>
                </li><li><a href="../../../categories/index.html">Tags</a>
                </li><li><a href="../../../rss.xml">RSS</a>

            </li></ul>
                
<span class="navbar-form pull-left">
<input type="text" id="tipue_search_input">
</span>

            <ul class="nav navbar-nav navbar-right">
                
                
            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>

<!-- End of Menubar -->

<div class="body-container">

    <!-- Sidebar -->

    <div class="left-sidebar">
        <div class="left-sidebar-widget">
            <h3>Something, something</h3>
            <div class="left-sidebar-widget-content">
                ...dark side...
            </div>
        </div>
        
        <div class="left-sidebar-widget">
            <h3>Tags</h3>
            <div class="left-sidebar-widget-content">
                <div id="tags_container">
                    <canvas width="275" height="250" id="tags_canvas">
                        <p>Anything in here will be replaced on browsers that support the canvas element</p>
                    </canvas>
                </div>
            </div>
        </div>
        
        <div class="left-sidebar-widget">
            <h3>Blogroll</h3>
            <div class="left-sidebar-widget-content">
                <ul>
                    <li><a target="_blank" href="http://www.asjava.com/">AsJava.com : Java Tutorial</a></li>
                    <li><a target="_blank" href="http://www.mkyong.com/">Mkyong : Java Tutorials</a></li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Content -->

    <div class="container">
        <div class="body-content">
            <!--Body content-->
            <div class="row">
                
    <article class="postbox post-text">
    <div class="h-entry" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <h1 class="p-name" itemprop="headline name">Integer Linear Time Sorting Algorithms</h1>

    <hr>
    <small>
        Posted: <time class="published dt-published" datetime="2012-11-07T09:02:46+00:00" itemprop="datePublished">2012-11-07 09:02</time>
        

        
          |  
        More posts about 
    <span itemprop="keywords">
        <a class="tag p-category" href="../../../categories/algorithm.html"><span class="badge badge-info">Algorithm</span></a>
        <a class="tag p-category" href="../../../categories/benchmarks.html"><span class="badge badge-info">Benchmarks</span></a>
        <a class="tag p-category" href="../../../categories/c.html"><span class="badge badge-info">C++</span></a>
        <a class="tag p-category" href="../../../categories/c.html"><span class="badge badge-info">C++</span></a>
        <a class="tag p-category" href="../../../categories/performances.html"><span class="badge badge-info">Performances</span></a>
    </span>


    </small>
    <hr>
    <div class="e-content" itemprop="articleBody text">
    <div><p></p><strong>Update</strong>: The code is now more C++
<p>Most of the sorting algorithms that are used are generally comparison sort. It means that each element of the collection being sorted will be compared to see which one is the first one. A comparison must have a lower bound of Ω(n log n) comparisons. That is why there are no comparison-based sorting algorithm better than O(n log n).</p>
<p>On the other hand, there are also sorting algorithms that are performing better. This is the family of the integer sorting algorithms. These algorithms are using properties of integer to sort them without comparing them. They can be only be used to sort integers. Nevertheless, a hash function can be used to assign a unique integer to any value and so sort any value. All these algorithms are using extra space. There are several of these algorithms. In this article, we will see three of them and I will present an implementation in C++. At the end of the article, I will compare them to <em>std::sort</em>.</p>
<p>In the article, I will use <em>n</em> as the size of the array to sort and <em>m</em> as the max number that is permitted in the array.</p>
<h3>Bin Sort</h3>

<p>Bin Sort, or Bucket Sort, is a very simple algorithm that partition all the input numbers into a number of buckets. Then, all the buckets are outputted in order in the array, resulting in a sorting array. I decided to implement the simplest case of Bin Sort where each number goes in its own bucket, so there are <em>m</em> buckets.</p>
<p>The implementation is pretty straightforward:</p>
<p>[cpp]void binsort(std::vector&lt;std::size_t&gt;&amp; A){
    std::vector&lt;std::vector&lt;std::size_t&gt;&gt; B(MAX + 1);</p>
<div class="code"><pre><span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">B</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">MAX</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
        <span class="n">A</span><span class="p">[</span><span class="n">current</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/cpp]</p>
<p>B is the array of buckets. Each bucket is implemented as a std::vector. The algorithm starts by filling each buckets with the numbers from the input array. Then, it outputs them in order in the array.</p>
<p>This algorithm works in <em>O(n + m)</em> and requires <em>O(m)</em> extra memory. With these properties, it makes a very limited algorithm, because if you don't know the maximum number and you have to use the maximum number of the array type, you will have to allocate for instance 2^32 buckets. That won't be possible.</p>
<h3>Couting Sort</h3>

<p>An interesting fact about binsort is that each bucket contains only the same numbers. The size of the bucket would be enough. That is exactly what Counting Sort. It counts the number of times an element is present instead of the elements themselves. I will present two versions. The first one is a version using a secondary array and then copying again into the input array and the second one is an in-place sort.</p>
<p>[cpp]void counting_sort(std::vector&lt;std::size_t&gt;&amp; A){
    std::vector&lt;std::size_t&gt; B(SIZE);
    std::vector&lt;std::size_t&gt; C(MAX);</p>
<div class="code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="o">++</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">MAX</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">B</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="o">--</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>


<p>}[/cpp]</p>
<p>The algorithm is also simple. It starts by counting the number of elements in each bucket. Then, it aggregates the number by summing them to obtain the position of the element in the final sorted array. Then, all the elements are copied in the temporary array. Finally, the temporary array is copied in the final array. This algorithms works in <em>O(m + n)</em> and requires <em>O(m + n)</em>. This version is presented only because it is present in the literature. We can do much better by avoiding the temporary array and optimizing it a bit:</p>
<p>[cpp]void in_place_counting_sort(std::vector&lt;std::size_t&gt;&amp; A){
    std::vector&lt;std::size_t&gt; C(MAX + 1);</p>
<div class="code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="o">++</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">MAX</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
        <span class="n">A</span><span class="p">[</span><span class="n">current</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/cpp]</p>
<p>The temporary array is removed and the elements are directly written in the sorted array. The counts are not used directly as position, so there is no need to sum them. This version still works in <em>O(m + n)</em> but requires only <em>O(m)</em> extra memory. It is much faster than the previous version.</p>
<h3>Radix Sort</h3>

<p>The last version that I will discuss here is a Radix Sort. This algorithm sorts the number digit after digit in a specific radix. It is a form of bucket sort, where there is a bucket by digit. Like Counting Sort, only the counts are necessary. For example, if you use radix sort in base 10. It will first sort all the numbers by their first digit, then the second, .... It can work in any base and that is its force. With a well chosen base, it can be very powerful. Here, we will focus on radix that are in the form 2^r. These radix have good properties, we can use shifts and mask to perform division and modulo, making the algorithm much faster.</p>
<p>The implementation is a bit more complex than the other implementations:</p>
<p>[cpp]static const std::size_t digits = 2;        //Digits</p>
<p>static const std::size_t r = 16;                 //Bits</p>
<p>static const std::size_t radix = 1 &lt;&lt; r;         //Bins</p>
<p>static const std::size_t mask = radix - 1;</p>
<p>void radix_sort(std::vector&lt;std::size_t&gt;&amp; A){
    std::vector&lt;std::size_t&gt; B(SIZE);
    std::vector&lt;std::size_t&gt; cnt(radix);</p>
<div class="code"><pre><span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">digits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">shift</span> <span class="o">+=</span> <span class="n">r</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">radix</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
        <span class="o">++</span><span class="n">cnt</span><span class="p">[(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">mask</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">radix</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="n">SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">){</span>
        <span class="n">B</span><span class="p">[</span><span class="o">--</span><span class="n">cnt</span><span class="p">[(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">mask</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
       <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/cpp]</p>
<p><em>r</em> indicates the power of two used as the radix (2^r). The mask is used to compute modulo faster. The algorithm repeats the steps for each digit. Here <em>digits</em> equals 2. It means that we support 2^32 values. A 32 bits value is sorted in two pass. The steps are very similar to counting sort. Each value of the digit is counted and then the counts are summed to give the position of the number. Finally, the numbers are put in order in the temporary array and copied into A.</p>
<p>This algorithm works in <em>O(digits (m + radix))</em> and requires <em>O(n + radix)</em> extra memory. A very good thing is that the algorithm does not require space based on the maximum value, only based on the radix.</p>
<h3>Results</h3>

<p>It's time to compare the different implementations in terms of runtime. For each size, each version is tested 25 times on different random arrays. The arrays are the same for each algorithm. The number is the time necessary to sort the 25 arrays. The benchmark has been compiler with GCC 4.7.</p>
<p>The first test is made with very few duplicates (m = 10n).</p>
<p>[bar_chart title="m = 10n" width="600px" height="400px" scale_button="true" v_title="ms" h_title="n"]</p>
<p>['x', 'std::sort', 'counting_sort', 'in_place_counting_sort', 'bin_sort', 'radix_sort'],</p>
<p>['100000', 171, 182, 105, 945, 89],</p>
<p>['500000', 993, 2229, 970, 6435, 461],</p>
<p>['1000000', 2175, 4812, 2046, 14096, 1068],</p>
<p>['5000000', 11791, 27050, 10202, 81255, 6148],</p>
<p>[/bar_chart]</p>
<p>Radix Sort comes to be the fastest in this case, <strong>twice faster as <em>std::sort</em></strong>. In place counting sort has almost the same performance as <em>std::sort</em>. The other are performing worse.</p>
<p>The second test is made with few duplicates (m ~= n).</p>
<p>[bar_chart title="m ~= n" width="600px" height="400px" scale_button="true" v_title="ms" h_title="n"]</p>
<p>['x', 'std::sort', 'counting_sort', 'in_place_counting_sort', 'bin_sort', 'radix_sort'],</p>
<p>['100000', 186, 73, 37, 309, 90],</p>
<p>['500000', 991, 611, 189, 3126, 455],</p>
<p>['1000000', 2235, 2171, 547, 7978, 1038],</p>
<p>['5000000', 12184, 18470, 4516, 49056, 5791],</p>
<p>[/bar_chart]</p>
<p>The numbers are impressive. In place <strong>counting sort is between 3-4 times faster than <em>std::sort</em></strong> and <strong>radix sort is twice faster than <em>std::sort</em></strong> ! Bin Sort does not performs very well and counting sort even if generally faster than <em>std::sort</em> does not scale very well.</p>
<p>Let's test with more duplicates (m = n / 2).</p>
<p>[bar_chart title="m = n / 2" width="600px" height="400px" scale_button="true" v_title="ms" h_title="n"]</p>
<p>['x', 'std::sort', 'counting_sort', 'in_place_counting_sort', 'bin_sort', 'radix_sort'],</p>
<p>['100000', 178, 65, 25, 262, 90],</p>
<p>['500000', 979, 450, 143, 2332, 461],</p>
<p>['1000000', 2171, 1480, 321, 6240, 1041],</p>
<p>['5000000', 11978, 16205, 3453, 41709, 5890],</p>
<p>[/bar_chart]</p>
<p><em>std::sort</em> and radix sort performance does not change a lot but the other sort are performing better. In-place counting sort is still the leader with a higher margin.</p>
<p>Finally, with a lot of duplicates (m = n / 10).</p>
<p>[bar_chart title="m = n / 10n" width="600px" height="400px" scale_button="true" v_title="ms" h_title="n"]</p>
<p>['x', 'std::sort', 'counting_sort', 'in_place_counting_sort', 'bin_sort', 'radix_sort'],</p>
<p>['100000', 161, 46, 12, 144, 74],</p>
<p>['500000', 918, 322, 76, 1023, 449],</p>
<p>['1000000', 2062, 824, 167, 2721, 1041],</p>
<p>['5000000', 10789, 8534, 1030, 24026, 5686],</p>
<p>[/bar_chart]</p>
<p>Again, <em>std::sort</em> and radix sort performance are stable, but in-place counting is now <strong>ten times faster than <em>std::sort</em></strong> !</p>
<h3>Conclusion</h3>

<p>To conclude, we have seen that these algorithms can outperforms <em>std::sort</em> by a high factor (10 times for In place Counting Sort when there m &lt;&lt; n). If you have to sort integers, you should consider these two cases:</p>
<ul>
    <li>m &gt; n or m is unknown : Use radix sort that is about twice faster than <em>std::sort</em>.</li>
    <li>m &lt;&lt; n : Use in place counting sort that can be much faster than <em>std::sort</em>.</li>
</ul>

<p>I hope you found this article interesting. The implementation can be found on Github: https://github.com/wichtounet/articles/tree/master/src/linear_sorting</p></div>
    </div>
    </div>
    
        <ul class="pager">
            <li class="previous">
                <a href="cmakelatex-1-0-2-nomenclature-filters.html" rel="prev">← Previous post</a>
            </li>
            <li class="next">
                <a href="eddic-compiler-1-1-4-graph-coloring-register-allocation.html" rel="next">Next post →</a>
            </li>
        </ul>

        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://wichtounet.github.io/posts/2012/11/integer-linear-time-sorting-algorithms.html",
        disqus_title="Integer Linear Time Sorting Algorithms",
        disqus_identifier="cache/posts/2012/11/integer-linear-time-sorting-algorithms.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


    

    </article>

            </div>
            <!--End of body content-->
        </div>
    </div>
</div>

<!-- Footer -->

<footer>
    Contents © 2014         <a href="mailto:baptistewicht@gmail.com">Baptiste Wicht</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/88x31.png"></a>
        <ul class="footer_inline_ul">
            
    <li>
    <a href="integer-linear-time-sorting-algorithms.wp" id="sourcelink">Source</a>
    </li>

        </ul>
</footer>


            <script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>

    <script type="text/javascript">
      $(document).ready(function() {
        jQuery.getJSON('/assets/js/tag_cloud_data.json', function(data) {
            var items = [];

            $.each(data, function(key, val) {
                items.push('<li><a href="' + val[1] +'" '+'data-weight="'+val[0]+'"'+'>' + key + '</a></li>');
            });

            $('<div/>', {
                'id': 'tags',
                html: '<ul>' + items.join('') + '</ul>'
            }).appendTo('body');

            if(!$('#tags_canvas').tagcanvas({
                textColour: '#FFFFFF',
                outlineColour: '#ff00ff',
                reverse: true,
                depth: 0.8,
                maxSpeed: 0.05,
                weight: true,
                weightFrom: "data-weight",
                weightSizeMin: 8,
                weightSizeMax: 24
            },'tags')) {
            // something went wrong, hide the canvas container
            $('#tags_container').hide();
            }});});
    </script>

    
<!-- AddThis Smart Layers BEGIN -->
<!-- Go to http://www.addthis.com/get/smart-layers to customize -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5327566b264df4ee"></script>
<script type="text/javascript">
  addthis.layers({
    'theme' : 'dark',
    'share' : {
      'position' : 'right',
      'numPreferredServices' : 5
    }, 
    'follow' : {
      'services' : [
        {'service': 'twitter', 'id': 'wichtounet'},
        {'service': 'google_follow', 'id': '+BaptisteWicht'}
      ]
    }   
  });
</script>
<!-- AddThis Smart Layers END -->


    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    

<script type="text/javascript" src="../../../assets/js/tipuesearch_set.js"></script>
<script type="text/javascript" src="../../../assets/js/tipuesearch.js"></script>
<script type="text/javascript">
$(document).ready(function() {
  $('#tipue_search_input').tipuesearch({
      'mode': 'json',
      'contentLocation': '/assets/js/tipuesearch_content.json',
      'showUrl': false
  });
});
</script>


</body></html>