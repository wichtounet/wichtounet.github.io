<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang=en> <head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>C++11 Concurrency Tutorial - Part 3: Advanced locking and condition variables | @Blog("Baptiste Wicht")</title><link href=../../../assets/css/all-nocdn.css rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title=RSS href=../../../rss.xml><link rel=canonical href=http://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html><script type=text/javascript>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2175227-7']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script><meta name=author content="Baptiste Wicht"><meta name=og:title content="C++11 Concurrency Tutorial - Part 3: Advanced locking and condition va"><meta name=og:url content=http://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html><meta name=og:description content="In the previous article, we saw how to use mutexes to fix concurrency problems. In this post, we will continue to work on mutexes with more advanced techniques. We will also study another concurrency "><meta name=og:site_name content=@Blog( baptiste wicht><meta name=og:type content=article><link href=../../../favicon.ico rel=icon type=image/x-icon></head><body><div class=social_container> <div class=social_container_gplus> <a target=_blank title="Share on Google+" href="https://plusone.google.com/_/+1/confirm?hl=en&amp;url=http://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html"><img src=../../../assets/img/google_plus.png></a> </div> <div class=social_container_facebook> <a target=_blank title="Share on Facebook" href="http://www.facebook.com/sharer/sharer.php?u=#url"><img src=../../../assets/img/facebook.png></a> </div> <div class=social_container_twitter> <a target=_blank title="Tweet on Twitter" href="http://twitter.com/home?status=#url"><img src=../../../assets/img/twitter.svg></a> </div></div><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class=navbar-toggle data-toggle=collapse data-target=.navbar-ex1-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=http://baptiste-wicht.com/> <span id=blog-title>@Blog("Baptiste Wicht")</span> </a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href=../../../stories/about.html>About</a> </li><li><a href=../../../stories/publications.html>Publications</a> </li><li><a href=../../../stories/donate.html>Donate</a> </li><li><a href=../../../stories/contact.html>Contact</a> </li><li><a href=../../../stories/faq.html>FAQ</a> </li><li><a href=../../../stories/legal.html>Legal</a> </li><li><a href=../../../categories/index.html>Tags</a> </li><li><a href=../../../archive.html>Archives</a> </li><li><a href=http://feeds.feedburner.com/BaptisteWicht>RSS</a> </li></ul> <span class="navbar-form pull-left"> <form action=../../../stories/search.html> <input type=text name=q id=tipue_search_input> </form> </span> <ul class="nav navbar-nav navbar-right"> <li> <a target=_blank title="Follow @wichtounet on Twitter" href=https://twitter.com/wichtounet> <img src=../../../assets/img/twitter.svg alt="Follow @wichtounet on Twitter"> </a> </li> <li> <a target=_blank title="Follow +BaptisteWicht on Google+" href=https://plus.google.com/+BaptisteWicht> <img src=../../../assets/img/google_plus.svg alt="Follow +BaptisteWicht on Google+"> </a> </li> </ul> </div> </div></nav><div class=body-container> <div class=left-sidebar> <div class=left-sidebar-widget> <div class=left-sidebar-widget-content> <div class=g-person data-width=275 data-href=//plus.google.com/u/0/103113673902796202116 data-theme=dark data-layout=landscape data-rel=author></div> </div> </div> <div class=left-sidebar-widget> <h3>Related posts</h3> <div class=left-sidebar-widget-content> <ol><li><a href=../03/cp11-concurrency-tutorial-part-2-protect-shared-data.html>C++11 Concurrency Tutorial - Part 2 : Protect shared data</a></li><li><a href=../03/cpp11-concurrency-part1-start-threads.html>C++11 Concurrency - Part 1 : Start Threads</a></li><li><a href=../../2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html>Java Concurrency - Part 5 : Monitors (Locks and Conditions)</a></li><li><a href=../../2010/08/java-concurrrency-synchronization-locks.html>Java Concurrency – Part 3 : Synchronization with intrinsic locks</a></li><li><a href=../07/c11-synchronization-benchmark.html>C++11 Synchronization Benchmark</a></li></ol> </div> </div> <div class=left-sidebar-widget> <h3>Recent comments</h3> <div class=left-sidebar-widget-content> <div id=recentcomments class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=28&amp;excerpt_length=50"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Blogroll</h3> <div class=left-sidebar-widget-content> <ul> <li><a target=_blank href=http://www.asjava.com/>AsJava.com : Java Tutorial</a></li> <li><a target=_blank href=http://www.mkyong.com/>Mkyong : Java Tutorials</a></li> </ul> </div> </div> </div> <div class=container> <div class=body-content> <div class=row><article class="post-text h-entry hentry postpage" itemscope=itemscope itemtype=http://schema.org/Article> <header> <h1 class="p-name entry-title" itemprop="headline name"><a href=# class=u-url>C++11 Concurrency Tutorial - Part 3: Advanced locking and condition variables</a></h1> <div class=metadata> <p class="byline author vcard"><span class="byline-name fn">Baptiste Wicht</span></p> <p class=dateline><a href=# rel=bookmark><time class="published dt-published" datetime=2012-04-10T08:37:37+02:00 itemprop=datePublished title="Publication date">2012-04-10 08:37</time></a></p> <p class=commentline> <a href=c11-concurrency-tutorial-advanced-locking-and-condition-variables.html#disqus_thread data-disqus-identifier=cache/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html>Comments</a> </p><p class=sourceline><a href=c11-concurrency-tutorial-advanced-locking-and-condition-variables.wp id=sourcelink>Source</a></p> </div> </header> <div class="e-content entry-content" itemprop="articleBody text"> <p>In the previous article, we saw how to use mutexes to fix concurrency problems. In this post, we will continue to work on mutexes with more advanced techniques. We will also study another concurrency technique of the C++11 Concurrency Library: condition variables.</p><h4>Recursive locking</h4><p>Let's imagine that you have a simple class like this one:</p><pre class="code literal-block"><span class=k>struct</span> <span class=n>Complex</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>mutex</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>

    <span class=n>Complex</span><span class=p>()</span> <span class=o>:</span> <span class=n>i</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>

    <span class=kt>void</span> <span class=n>mul</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>){</span>
        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>i</span> <span class=o>*=</span> <span class=n>x</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>void</span> <span class=n>div</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>){</span>
        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>i</span> <span class=o>/=</span> <span class=n>x</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>
</pre><p>And you want to add an operation doing both operations with no problems, so you add a new function:</p><pre class="code literal-block"><span class=kt>void</span> <span class=nf>both</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>){</span>
    <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
    <span class=n>mul</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
    <span class=n>div</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>
<span class=p>}</span>
</pre><p>Now, it's time to test this function:</p><pre class="code literal-block"><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=n>Complex</span> <span class=n>complex</span><span class=p>;</span>
    <span class=n>complex</span><span class=p>.</span><span class=n>both</span><span class=p>(</span><span class=mi>32</span><span class=p>,</span> <span class=mi>23</span><span class=p>);</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre><p>If you launch this application, you'll see that the program will never terminates. The problem is very simple. In the <em>both()</em> function, the thread acquires the lock and then calls the <em>mul()</em> function. In this function, the threads tries to acquire the lock again, but the lock is already locked. This is a case of deadlock. By default, a thread cannot acquire the same mutex twice.</p><p>There is a simple solution to this problem: <strong>std::recursive_mutex</strong>. This mutex can be acquired several times by the same thread. Here is the correct version of the Complex struct:</p><pre class="code literal-block"><span class=k>struct</span> <span class=n>Complex</span> <span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>recursive_mutex</span> <span class=n>mutex</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>

    <span class=n>Complex</span><span class=p>()</span> <span class=o>:</span> <span class=n>i</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>

    <span class=kt>void</span> <span class=n>mul</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>){</span>
        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>recursive_mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>i</span> <span class=o>*=</span> <span class=n>x</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>void</span> <span class=n>div</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>){</span>
        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>recursive_mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>i</span> <span class=o>/=</span> <span class=n>x</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>void</span> <span class=n>both</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>){</span>
        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>recursive_mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>mul</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
        <span class=n>div</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>};</span>
</pre><p>This time, the application works correctly.</p><h4>Timed locking</h4><p>Sometimes, you doesn't want a thread to wait ad infinitum for a mutex. For example, if your thread can do something else when waiting for the thread. For this purpose, the standard library has a solution: <strong>std::timed_mutex</strong> and <strong>std::recursive_timed_mutex</strong> (if you need the recursivity properties of the mutex). You have access to the same functions as a <strong>std::mutex</strong>: <em>lock()</em> and <em>unlock()</em>, but you have also two new functions: <em>try_lock_for()</em> and <em>try_lock_until()</em>.</p><p>The first one is also the most useful. It allows you to set a timeout after when the function automatically returns even if the lock was not acquired. The function returns true if the lock has been acquired, false otherwise. Let's try it with a simple example:</p><pre class="code literal-block"><span class=n>std</span><span class=o>::</span><span class=n>timed_mutex</span> <span class=n>mutex</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>work</span><span class=p>(){</span>
    <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>milliseconds</span> <span class=n>timeout</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>

    <span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>){</span>
        <span class=k>if</span><span class=p>(</span><span class=n>mutex</span><span class=p>.</span><span class=n>try_lock_for</span><span class=p>(</span><span class=n>timeout</span><span class=p>)){</span>
            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>get_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>": do work with the mutex"</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>

            <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>milliseconds</span> <span class=n>sleepDuration</span><span class=p>(</span><span class=mi>250</span><span class=p>);</span>
            <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=n>sleepDuration</span><span class=p>);</span>

            <span class=n>mutex</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>

            <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=n>sleepDuration</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>get_id</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>": do work without mutex"</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>

            <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>milliseconds</span> <span class=n>sleepDuration</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
            <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=n>sleepDuration</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>work</span><span class=p>);</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>work</span><span class=p>);</span>

    <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre><p>(The example is completely useless in practice)</p><p>The first interesting thing in this example is the declaration of the duration with <strong>std::chrono::milliseconds</strong>. This is also a new feature of the C++11 standard. You have access to several time unit: nanoseconds, microseconds, milliseconds, seconds, minutes and hours. We use a variable of this kind to set the timeout of the try_lock_for function. We also use this to make a thread sleeps with <strong>std::this_thread::sleep_for(duration)</strong>. The rest of the example has nothing exciting in it, just some prints to see the results visually. Note that the program never stops, you have to kill it.</p><h4>Call once</h4><p>Sometimes you want a function to be called only once no matter the number of threads that are used. Imagine a function that has two parts. The first part has to be called only once and the second has to be executed every time the function gets called. We can use the std::call_once function to fix this problem very easily. Here is an example using this mechanism:</p><pre class="code literal-block"><span class=n>std</span><span class=o>::</span><span class=n>once_flag</span> <span class=n>flag</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>do_something</span><span class=p>(){</span>
    <span class=n>std</span><span class=o>::</span><span class=n>call_once</span><span class=p>(</span><span class=n>flag</span><span class=p>,</span> <span class=p>[](){</span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>"Called once"</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;});</span>

    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>"Called each time"</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>do_something</span><span class=p>);</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>do_something</span><span class=p>);</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t3</span><span class=p>(</span><span class=n>do_something</span><span class=p>);</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t4</span><span class=p>(</span><span class=n>do_something</span><span class=p>);</span>

    <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>t3</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>t4</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre><p>Each <strong>std::call_once</strong> is matched to a <strong>std::once_flag</strong> variable. Here I put a closure to be executed only once, but a function pointer or a std::function will make the trick.</p><h4>Condition variables</h4><p>A condition variable manages a list of threads waiting until another thread notify them. Each thread that wants to wait on the condition variable has to acquire a lock first. The lock is then released when the thread starts to wait on the condition and the lock is acquired again when the thread is awakened.</p><p>A very good example is a concurrent Bounded Buffer. It’s a cyclic buffer with a certain capacity with a start and an end. Here is our implementation of a Bounded Buffer using condition variables:</p><pre class="code literal-block"><span class=k>struct</span> <span class=n>BoundedBuffer</span> <span class=p>{</span>
    <span class=kt>int</span><span class=o>*</span> <span class=n>buffer</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>capacity</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>front</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>rear</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>

    <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>lock</span><span class=p>;</span>

    <span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>not_full</span><span class=p>;</span>
    <span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>not_empty</span><span class=p>;</span>

    <span class=n>BoundedBuffer</span><span class=p>(</span><span class=kt>int</span> <span class=n>capacity</span><span class=p>)</span> <span class=o>:</span> <span class=n>capacity</span><span class=p>(</span><span class=n>capacity</span><span class=p>),</span> <span class=n>front</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>rear</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>count</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>buffer</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>capacity</span><span class=p>];</span>
    <span class=p>}</span>

    <span class=o>~</span><span class=n>BoundedBuffer</span><span class=p>(){</span>
        <span class=k>delete</span><span class=p>[]</span> <span class=n>buffer</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>void</span> <span class=n>deposit</span><span class=p>(</span><span class=kt>int</span> <span class=n>data</span><span class=p>){</span>
        <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>l</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>

        <span class=n>not_full</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=p>[</span><span class=k>this</span><span class=p>](){</span><span class=k>return</span> <span class=n>count</span> <span class=o>!=</span> <span class=n>capacity</span><span class=p>;</span> <span class=p>});</span>

        <span class=n>buffer</span><span class=p>[</span><span class=n>rear</span><span class=p>]</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span>
        <span class=n>rear</span> <span class=o>=</span> <span class=p>(</span><span class=n>rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>capacity</span><span class=p>;</span>
        <span class=o>++</span><span class=n>count</span><span class=p>;</span>

        <span class=n>not_empty</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>fetch</span><span class=p>(){</span>
        <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>l</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>

        <span class=n>not_empty</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=p>[</span><span class=k>this</span><span class=p>](){</span><span class=k>return</span> <span class=n>count</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>});</span>

        <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>[</span><span class=n>front</span><span class=p>];</span>
        <span class=n>front</span> <span class=o>=</span> <span class=p>(</span><span class=n>front</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>capacity</span><span class=p>;</span>
        <span class=o>--</span><span class=n>count</span><span class=p>;</span>

        <span class=n>not_full</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span>

        <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>
</pre><p>The mutexes are managed by a <strong>std::unique_lock</strong>. It is a wrapper to manage a lock. This is necessary to be used with the condition variables. To wake up a thread that is waiting on a condition variable, the <em>notify_one()</em> function is used. The wait function is a bit special. It takes as the first argument the unique lock and a the second one a predicate. The predicate must return false when the waiting must be continued (it is equivalent to while(!pred()){cv.wait(l);}). The rest of the example has nothing special.</p><p>We can use this structure to fix multiple consumers / multiple producers problem. This problem is very common in concurrent programming. Several threads (consumers) are waiting from data produced by another several threads (producers). Here is an example with several threads using the structure:</p><pre class="code literal-block"><span class=kt>void</span> <span class=nf>consumer</span><span class=p>(</span><span class=kt>int</span> <span class=n>id</span><span class=p>,</span> <span class=n>BoundedBuffer</span><span class=o>&amp;</span> <span class=n>buffer</span><span class=p>){</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>50</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>.</span><span class=n>fetch</span><span class=p>();</span>
        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>"Consumer "</span> <span class=o>&lt;&lt;</span> <span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>" fetched "</span> <span class=o>&lt;&lt;</span> <span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>milliseconds</span><span class=p>(</span><span class=mi>250</span><span class=p>));</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>producer</span><span class=p>(</span><span class=kt>int</span> <span class=n>id</span><span class=p>,</span> <span class=n>BoundedBuffer</span><span class=o>&amp;</span> <span class=n>buffer</span><span class=p>){</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>75</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=n>buffer</span><span class=p>.</span><span class=n>deposit</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>"Produced "</span> <span class=o>&lt;&lt;</span> <span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>" produced "</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
        <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>milliseconds</span><span class=p>(</span><span class=mi>100</span><span class=p>));</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=n>BoundedBuffer</span> <span class=n>buffer</span><span class=p>(</span><span class=mi>200</span><span class=p>);</span>

    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>c1</span><span class=p>(</span><span class=n>consumer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ref</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>c2</span><span class=p>(</span><span class=n>consumer</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ref</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>c3</span><span class=p>(</span><span class=n>consumer</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ref</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>p1</span><span class=p>(</span><span class=n>producer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ref</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>p2</span><span class=p>(</span><span class=n>producer</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>ref</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>

    <span class=n>c1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>c2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>c3</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>p1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
    <span class=n>p2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre><p>Three consumer threads and two producer threads are created and query the structure constantly. An interesting thing about this example is the use of std::ref to pass the buffer by reference, it is necessary to avoid a copy of the buffer.</p><h4>Wrap-Up</h4><p>In this article we saw several things. First, we saw how to use a recursive_mutex to allow a thread to acquire a thread more than once. Then, we saw how to acquire a mutex with a timeout. After that, a method to call a function only once has been studied. And finally, condition variables were used to solve the multiple consumers / multiple producers problem.</p><p>The source code for this article can be found on <a title="Source code of this article" href=https://github.com/wichtounet/articles/tree/master/src/threads/part3/>Github</a>.</p><h4>Next</h4><p>In the next post of this series, we will another technique of this new C++11 Concurrency Library, the Atomics.</p> </div> <aside class=postpromonav> <nav> <ul itemprop=keywords class=tags> <li><a class="tag p-category" href=../../../categories/c11-concurrency-tutorial.html rel=tag>C++11 Concurrency Tutorial</a></li> <li><a class="tag p-category" href=../../../categories/c.html rel=tag>C++</a></li> <li><a class="tag p-category" href=../../../categories/concurrency.html rel=tag>Concurrency</a></li> </ul> <ul class=pager> <li class=previous> <a href=linux-kernel-tip-do-not-disable-system-v-ipc-for-x-org-and-chrome.html rel=prev title="Linux Kernel Tip : Do not disable System V IPC for X.Org and Chrome">Previous post</a> </li> <li class=next> <a href=switching-gentoo-linux.html rel=next title="Switching to Gentoo Linux">Next post</a> </li> </ul> </nav> </aside> <section class=comments> <h2>Comments</h2> <div id=disqus_thread></div> <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://baptiste-wicht.com/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html",
        disqus_title="C++11 Concurrency Tutorial - Part 3: Advanced locking and condition variables",
        disqus_identifier="cache/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=//disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> <a href=//disqus.com class=dsq-brlink rel=nofollow>Comments powered by <span class=logo-disqus>Disqus</span></a> </section></article> <script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script> </div> </div> </div></div><footer> Contents © 2014 <a href=mailto:baptistewicht@gmail.com>Baptiste Wicht</a> - Powered by <a href=http://getnikola.com rel=nofollow>Nikola</a><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons License" style=padding-left:5px;border-width:0 src=../../../assets/img/cc.png></a> <ul class=footer_inline_ul> <li> <a href=c11-concurrency-tutorial-advanced-locking-and-condition-variables.wp id=sourcelink>Source</a> </li> </ul></footer> <script src=../../../assets/js/all-nocdn.js></script><script type=text/javascript src=https://apis.google.com/js/platform.js></script></body></html>