<!DOCTYPE html>
<html lang=en><head><link href=favicon.ico rel=icon type=image/x-icon><meta name=viewport content="width=device-width, initial-scale=1.0"><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=author content="Baptiste Wicht"><title>Memory Manager in 64bits Intel Assembly on Linux | @Blog("Baptiste Wicht")</title><link href=../../../assets/css/all-nocdn.css rel=stylesheet type=text/css><link rel=canonical href=http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html><link rel=alternate type=application/rss+xml title=RSS href=../../../rss.xml><script type=text/javascript>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2175227-7']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script></head><body><div class=social_container> <div class=social_container_gplus> <a target=_blank title="Share on Google+" href="https://plusone.google.com/_/+1/confirm?hl=en&amp;url=http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html"><img src=../../../assets/img/google_plus.png></a> </div> <div class=social_container_facebook> <a target=_blank title="Share on Facebook" href="http://www.facebook.com/sharer/sharer.php?u=#url"><img src=../../../assets/img/facebook.png></a> </div> <div class=social_container_twitter> <a target=_blank title="Tweet on Twitter" href="http://twitter.com/home?status=#url"><img src=../../../assets/img/twitter.svg></a> </div></div><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class=navbar-toggle data-toggle=collapse data-target=.navbar-ex1-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=http://baptiste-wicht.com/>@Blog("Baptiste Wicht")</a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href=../../../stories/about.html>About</a> </li><li><a href=../../../stories/publications.html>Publications</a> </li><li><a href=../../../stories/donate.html>Donate</a> </li><li><a href=../../../stories/contact.html>Contact</a> </li><li><a href=../../../stories/faq.html>FAQ</a> </li><li><a href=../../../stories/legal.html>Legal</a> </li><li><a href=../../../categories/index.html>Tags</a> </li><li><a href=../../../archive.html>Archives</a> </li><li><a href=http://feeds.feedburner.com/BaptisteWicht>RSS</a> </li></ul> <span class="navbar-form pull-left"> <form action=../../../stories/search.html> <input type=text name=q id=tipue_search_input> </form> </span> <ul class="nav navbar-nav navbar-right"> <li> <a target=_blank title="Follow @wichtounet on Twitter" href=https://twitter.com/wichtounet> <img src=../../../assets/img/twitter.svg alt="Follow @wichtounet on Twitter"> </a> </li> <li> <a target=_blank title="Follow +BaptisteWicht on Google+" href=https://plus.google.com/+BaptisteWicht> <img src=../../../assets/img/google_plus.svg alt="Follow +BaptisteWicht on Google+"> </a> </li> </ul> </div> </div></nav><div class=body-container> <div class=left-sidebar> <div class=left-sidebar-widget> <div class=left-sidebar-widget-content> <div class=g-person data-width=275 data-href=//plus.google.com/u/0/103113673902796202116 data-theme=dark data-layout=landscape data-rel=author></div> </div> </div> <div class=left-sidebar-widget> <h3>Related posts</h3> <div class=left-sidebar-widget-content> <ol><li><a href=../../2011/11/dynamic-memory-allocation-intel-assembly-linux.html>Dynamic memory allocation in Intel Assembly on Linux</a></li><li><a href=../07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html>EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors</a></li><li><a href=../03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html>Introduction to 64 Bit Intel Assembly Language Programming for Linux - Book Review</a></li><li><a href=../../2011/11/print-strings-integers-intel-assembly.html>How to print strings and integers in Intel Assembly on Linux ?</a></li><li><a href=../../2010/02/java-keywords.html>The reserved keywords of the Java Language</a></li></ol> </div> </div> <div class=left-sidebar-widget> <h3>Recent comments</h3> <div class=left-sidebar-widget-content> <div id=recentcomments class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=28&amp;excerpt_length=50"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Blogroll</h3> <div class=left-sidebar-widget-content> <ul> <li><a target=_blank href=http://www.asjava.com/>AsJava.com : Java Tutorial</a></li> <li><a target=_blank href=http://www.mkyong.com/>Mkyong : Java Tutorials</a></li> </ul> </div> </div> </div> <div class=container> <div class=body-content> <div class=row> <article class="postbox post-text"> <div class=h-entry itemscope=itemscope itemtype=http://schema.org/Article> <h1 class=p-name itemprop="headline name">Memory Manager in 64bits Intel Assembly on Linux</h1> <hr> <small> Posted: <time class="published dt-published" datetime=2012-08-02T08:05:30+02:00 itemprop=datePublished>2012-08-02 08:05</time>   |   More posts about <span itemprop=keywords> <a class="tag p-category" href=../../../categories/assembly.html><span class="badge badge-info">Assembly</span></a> <a class="tag p-category" href=../../../categories/intel.html><span class="badge badge-info">Intel</span></a> <a class="tag p-category" href=../../../categories/linux.html><span class="badge badge-info">Linux</span></a> </span> </small> <hr> <div class=e-content itemprop="articleBody text"> <div><p>For <a title="EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors" href=http://www.baptiste-wicht.com/2012/07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors/>the last version of the EDDI Compiler</a>, it has been necessary to extend the dynamic memory allocator, to support free memory. In this post, we will see how to write a simple Memory Manager in Intel Assembly for Linux.</p><p>In the past, we've seen <a title="Dynamic memory allocation in Intel Assembly on Linux" href=http://www.baptiste-wicht.com/2011/11/dynamic-memory-allocation-intel-assembly-linux/>how to write a basic memory allocator</a>, this time, we will write a more complete version.</p><p>The implementation is made in 64bits Intel Assembly.</p><h4>Memory Manager specification</h4><p>The memory will be allocated by blocks. Each block will contain a header with two information:</p><ul> <li>A boolean flag indicating if the block is free or not</li> <li>The size of the block (including the header)</li></ul><p>Each time some memory is asked, the blocks are tested one by one until an available one is found. If no available block is found, a new block is allocated after the last one and this block is returned.</p><p>The memory manager consists of three functions:</p><ul> <li>memory_init: Init the memory manager</li> <li>memory_alloc: Allocate the given number of bytes of memory</li> <li>memory_free: Release the given block</li></ul><p>The parameter is passed in the <strong>r14</strong> register. The return value is returned in the <strong>rax</strong> register.</p><h4>Global State</h4><p>This implementation needs two global variables. One for the start address of memory and the other one for the last:</p><div class=code><pre><span class=k>section</span> <span class=nv>.data</span>
<span class=nf>mem_last</span> <span class=nv>dq</span> <span class=mi>0</span>
<span class=nf>mem_start</span> <span class=nv>dq</span> <span class=mi>0</span>
</pre></div><h4>Init memory Manager</h4><p>The init function is very simple to implement:</p><div class=code><pre><span class=nl>init:</span>
<span class=nf>push</span> <span class=nb>rbp</span>
<span class=nf>mov</span> <span class=nb>rbp</span><span class=p>,</span> <span class=nb>rsp</span>
<span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>12</span>
<span class=nf>xor</span> <span class=nb>rdi</span><span class=p>,</span> <span class=nb>rdi</span>
<span class=nf>syscall</span>
<span class=nf>mov</span> <span class=p>[</span><span class=nv>mem_start</span><span class=p>],</span> <span class=nb>rax</span>
<span class=nf>mov</span> <span class=p>[</span><span class=nv>mem_last</span><span class=p>],</span> <span class=nb>rax</span>
<span class=nf>leave</span>
<span class=nf>ret</span>
</pre></div><p>We just have to call sys_brk in order to get the location of <em>program break</em>. Then, the start and the last addresses are the same.</p><h4>Free memory</h4><p>The free function is the simplest one:</p><div class=code><pre><span class=nl>free:</span>
<span class=nf>push</span> <span class=nb>rbp</span>
<span class=nf>mov</span> <span class=nb>rbp</span><span class=p>,</span> <span class=nb>rsp</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=p>[</span><span class=nv>r14</span> <span class=o>-</span> <span class=mi>16</span><span class=p>],</span> <span class=mi>1</span>
<span class=nf>leave</span>
<span class=nf>ret</span>
</pre></div><p>The address to free is passed in the <strong>r14</strong> register. We have to go back 16 bytes (size of the control block) to go to the start of the block. The availability flag is set to 1 (the block is free).</p><h4>The alloc function</h4><p>The alloc function is the most complex:</p><div class=code><pre><span class=nl>alloc:</span>
<span class=nf>push</span> <span class=nb>rbp</span>
<span class=nf>mov</span> <span class=nb>rbp</span><span class=p>,</span> <span class=nb>rsp</span>
<span class=nf>push</span> <span class=nb>rdi</span>
<span class=nf>push</span> <span class=nv>r10</span>
<span class=nf>push</span> <span class=nv>r11</span>
<span class=nf>push</span> <span class=nv>r12</span>
<span class=nf>push</span> <span class=nv>r13</span>
<span class=nf>push</span> <span class=nv>r14</span>
<span class=nf>add</span> <span class=nv>r14</span><span class=p>,</span> <span class=mi>16</span>
<span class=nf>mov</span> <span class=nv>r12</span><span class=p>,</span> <span class=p>[</span><span class=nv>mem_start</span><span class=p>]</span>
<span class=nf>mov</span> <span class=nv>r13</span><span class=p>,</span> <span class=p>[</span><span class=nv>mem_last</span><span class=p>]</span>
<span class=nl>.start:</span>
<span class=nf>cmp</span> <span class=nv>r12</span><span class=p>,</span> <span class=nv>r13</span>
<span class=nf>je</span> <span class=nv>.alloc</span>
<span class=nf>mov</span> <span class=nv>r10</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span><span class=p>]</span>
<span class=nf>mov</span> <span class=nv>r11</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>8</span><span class=p>]</span>
<span class=nf>cmp</span> <span class=nv>r10</span><span class=p>,</span> <span class=mi>1</span>
<span class=nf>jne</span> <span class=nv>.move</span>
<span class=nf>cmp</span> <span class=nv>r11</span><span class=p>,</span> <span class=nv>r14</span>
<span class=nf>jl</span> <span class=nv>.move</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=p>[</span><span class=nv>r12</span><span class=p>],</span> <span class=mi>0</span>
<span class=nf>lea</span> <span class=nb>rax</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>16</span><span class=p>]</span>
<span class=nf>pop</span> <span class=nv>r14</span>
<span class=nf>pop</span> <span class=nv>r13</span>
<span class=nf>pop</span> <span class=nv>r12</span>
<span class=nf>pop</span> <span class=nv>r11</span>
<span class=nf>pop</span> <span class=nv>r10</span>
<span class=nf>pop</span> <span class=nb>rdi</span>
<span class=nf>leave</span>
<span class=nf>ret</span>

<span class=nl>.move:</span>
<span class=nf>add</span> <span class=nv>r12</span><span class=p>,</span> <span class=nv>r11</span>
<span class=nf>jmp</span> <span class=nv>.start</span>

<span class=nl>.alloc:</span>
<span class=nf>lea</span> <span class=nb>rdi</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=nv>r14</span><span class=p>]</span>
<span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>12</span>
<span class=nf>syscall</span>
<span class=nf>mov</span> <span class=p>[</span><span class=nv>mem_last</span><span class=p>],</span> <span class=nb>rdi</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=p>[</span><span class=nv>r12</span><span class=p>],</span> <span class=mi>0</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>8</span><span class=p>],</span> <span class=nv>r14</span>
<span class=nf>lea</span> <span class=nb>rax</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>16</span><span class=p>]</span>
<span class=nf>pop</span> <span class=nv>r14</span>
<span class=nf>pop</span> <span class=nv>r13</span>
<span class=nf>pop</span> <span class=nv>r12</span>
<span class=nf>pop</span> <span class=nv>r11</span>
<span class=nf>pop</span> <span class=nv>r10</span>
<span class=nf>pop</span> <span class=nb>rdi</span>
<span class=nf>leave</span>
<span class=nf>ret</span>
</pre></div><p>As the function is a bit complex, I will detail it in part:</p><div class=code><pre><span class=nf>add</span> <span class=nv>r14</span><span class=p>,</span> <span class=mi>16</span>
<span class=nf>mov</span> <span class=nv>r12</span><span class=p>,</span> <span class=p>[</span><span class=nv>mem_start</span><span class=p>]</span>
<span class=nf>mov</span> <span class=nv>r13</span><span class=p>,</span> <span class=p>[</span><span class=nv>mem_last</span><span class=p>]</span>
<span class=nl>.start:</span>
<span class=nf>cmp</span> <span class=nv>r12</span><span class=p>,</span> <span class=nv>r13</span>
<span class=nf>je</span> <span class=nv>.alloc</span>
<span class=nf>mov</span> <span class=nv>r10</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span><span class=p>]</span>
<span class=nf>mov</span> <span class=nv>r11</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>8</span><span class=p>]</span>
<span class=nf>cmp</span> <span class=nv>r10</span><span class=p>,</span> <span class=mi>1</span>
<span class=nf>jne</span> <span class=nv>.move</span>
<span class=nf>cmp</span> <span class=nv>r11</span><span class=p>,</span> <span class=nv>r14</span>
<span class=nf>jl</span> <span class=nv>.move</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=p>[</span><span class=nv>r12</span><span class=p>],</span> <span class=mi>0</span>
<span class=nf>lea</span> <span class=nb>rax</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>16</span><span class=p>]</span>
</pre></div><p>The necessary number of bytes is passed in the <strong>r14</strong> register. We add 16 bytes (size of the control group) to the size as we also need some place for the header. Then, we load the start and last addresses. If both addresses are equal, we need to allocate more memory (detailed later). Then, we check the size and the availability of the current block. If the size is enough to fit the needs and the block is available, we set it to unavailable. We return the address past the control block (16 bytes).</p><div class=code><pre><span class=nl>.move:</span>
<span class=nf>add</span> <span class=nv>r12</span><span class=p>,</span> <span class=nv>r11</span>
<span class=nf>jmp</span> <span class=nv>.start</span>
</pre></div><p>To move to the next block, we just have to add the size of the current block to the current block address.</p><div class=code><pre><span class=nl>.alloc:</span>
<span class=nf>lea</span> <span class=nb>rdi</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=nv>r14</span><span class=p>]</span>
<span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=mi>12</span>
<span class=nf>syscall</span>
<span class=nf>mov</span> <span class=p>[</span><span class=nv>V_mem_last</span><span class=p>],</span> <span class=nb>rdi</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=p>[</span><span class=nv>r12</span><span class=p>],</span> <span class=mi>0</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>8</span><span class=p>],</span> <span class=nv>r14</span>
<span class=nf>lea</span> <span class=nb>rax</span><span class=p>,</span> <span class=p>[</span><span class=nv>r12</span> <span class=o>+</span> <span class=mi>16</span><span class=p>]</span>
</pre></div><p>To allocate memory, we compute the new <em>program break</em> and call <em>sys_brk</em> again to set the new <em>program break</em>. The block is then set to not available and the size is set. We return the address past the control block (16 bytes).</p><p>The rest of the program is just here to save and restore the registers and compute the stack frames.</p><h4>Wrap-Up</h4><p>In this article, we saw how to implement a very simple memory manager in 64bits Intel Assembly on Linux. This memory manager is very simple, but has several drawbacks:</p><ul> <li>The overhead for small blocks is important. For example, allocating an 8 bytes integer needs a 24 bytes block, thrice the size of the int.</li> <li>In the worst-case scenario, all of the process memory need to be walked across to find a new free block</li> <li>The functions are not thread-safe</li> <li>This algorithm can lead to a lot of memory fragmentation</li></ul><p>In the future I will try to make a more powerful version of this memory manager.</p><h4>Download</h4><p>All the functions are available online on the Github Repository:</p><ul> <li><a href=https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_alloc.s>alloc</a></li> <li><a href=https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_free.s>free</a></li> <li><a href=https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_init.s>init</a></li></ul><p>They are also available in 32bits Intel Assembly:</p><ul> <li><a href=https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_alloc.s>alloc</a></li> <li><a href=https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_free.s>free</a></li> <li><a href=https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_init.s>init</a></li></ul></div> </div> </div> <ul class=pager> <li class=previous> <a href=../07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html rel=prev>← Previous post</a> </li> <li class=next> <a href=architexa-free-understand-code-base.html rel=next>Next post →</a> </li> </ul> <div id=disqus_thread></div> <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html",
        disqus_title="Memory Manager in 64bits Intel Assembly on Linux",
        disqus_identifier="cache/posts/2012/08/memory-manager-intel-assembly-64-linux.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> <a href=http://disqus.com class=dsq-brlink rel=nofollow>Comments powered by <span class=logo-disqus>Disqus</span></a> </article> </div> </div> </div></div><footer> Contents © 2014 <a href=mailto:baptistewicht@gmail.com>Baptiste Wicht</a> - Powered by <a href=http://getnikola.com rel=nofollow>Nikola</a><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons License" style=padding-left:5px;border-width:0 src=../../../assets/img/cc.png></a> <ul class=footer_inline_ul> <li> <a href=memory-manager-intel-assembly-64-linux.wp id=sourcelink>Source</a> </li> </ul></footer> <script src=../../../assets/js/all-nocdn.js type=text/javascript></script><script type=text/javascript src=https://apis.google.com/js/platform.js></script></body></html>