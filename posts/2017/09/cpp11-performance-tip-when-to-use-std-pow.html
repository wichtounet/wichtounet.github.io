<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Test the performance of std::pow in comparison to simple multiplications.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>C++11 Performance tip: When to use std::pow ? | Blog blog("Baptiste Wicht");</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://baptiste-wicht.com/posts/2017/09/cpp11-performance-tip-when-to-use-std-pow.html">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Baptiste Wicht">
<link rel="prev" href="budgetwarrior-042-budget-summary-improved-fortune-reports.html" title="budgetwarrior 0.4.2 - Budget summary and improved fortune reports" type="text/html">
<link rel="next" href="how-i-made-deep-learning-library-38-faster-to-compile-optimization-and-cpp17-if-constexpr.html" title="How I made my Deep Learning Library 38% faster to compile (Optimization and C++17 if constexpr)" type="text/html">
<meta property="og:site_name" content='Blog blog("Baptiste Wicht");'>
<meta property="og:title" content="C++11 Performance tip: When to use std::pow ?">
<meta property="og:url" content="https://baptiste-wicht.com/posts/2017/09/cpp11-performance-tip-when-to-use-std-pow.html">
<meta property="og:description" content="Test the performance of std::pow in comparison to simple multiplications.">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-09-18T07:50:44+02:00">
<meta property="article:tag" content="Benchmark">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++11">
<meta property="article:tag" content="Performances">
<meta property="article:tag" content="Tip">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://baptiste-wicht.com/">

                <span id="blog-title">Blog blog("Baptiste Wicht");</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../../stories/about.html">About</a>
                </li>
<li>
<a href="../../../stories/publications.html">Publications</a>
                </li>
<li>
<a href="../../../stories/projects.html">Projects</a>
                </li>
<li>
<a href="../../../categories/index.html">Tags</a>
                </li>
<li>
<a href="../../../archive.html">Archives</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<li>
    <a href="cpp11-performance-tip-when-to-use-std-pow.rst" id="sourcelink">Source</a>
    </li>

                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">C++11 Performance tip: When to use std::pow ?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Baptiste Wicht
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2017-09-18T07:50:44+02:00" itemprop="datePublished" title="2017-09-18 07:50">2017-09-18 07:50</time></a>
            </p>
                <p class="commentline">
    
    <a href="cpp11-performance-tip-when-to-use-std-pow.html#disqus_thread" data-disqus-identifier="cache/posts/2017/09/cpp11-performance-tip-when-to-use-std-pow.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="cpp11-performance-tip-when-to-use-std-pow.rst" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Update: I've added a new section for larger values of <code>n</code>.</p>
<p>Recently, I've been wondering about the performance of <code>std::pow(x, n)</code>.
I'm talking here about the case when <code>n</code> is an integer. In the case when
<code>n</code> is not an integer, I believe, you should always use <code>std::pow</code>
or use another specialized library.</p>
<p>In case when n is an integer, you can actually replace it with the direct
equivalent (for instance <code>std::pow(x, 3) = x * x x</code>). If n is very large,
you'd rather write a loop of course ;) In practice, we generally use powers of
two and three much more often than power of 29, although that could happen. Of
course, it especially make sense to wonder about this if the pow is used inside
a loop. If you only use it once outside a loop, that won't be any difference on
the overall performance.</p>
<p>Since I'm mostly interested in single precision performance (neural networks are
only about single precision), the first benchmarks will be using <code>float</code>.</p>
<!-- TEASER_END -->
<section id="std-pow-performances"><h2>std::pow performances</h2>
<p>So let's see what are the differences between <code>std::pow(x, 2)</code> and
<code>x * x</code>. All the code will be compiled in C++11. For the sake of it,
I'll also check the performance of the C <code>pow</code> function.
Let's start with GCC-6.4 and -O2:</p>
<div id="graph_std_pow_2" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_2" type="button" value="Logarithmic scale"><p>First, there is no difference between C pow function and std::pow, which is
expected. On the other hand, it's interesting to see that there is a definite
difference in performance between <code>x * x</code> and <code>std::pow(x, 2)</code>. This
is not a huge difference, but still around 2.5 times slower for
<code>std::pow</code>.</p>
<p>Let's see if the difference is the same for bigger exponent.</p>
<div id="graph_std_pow_3" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_3" type="button" value="Logarithmic scale"><p>This time the difference is very significant. <code>x * x * x</code> is two orders
of magnitude faster than <code>std::pow(x, n)</code>. It seems that the algorithm
used for bigger power is much less efficient. In any case, we can see that this
is not optimized for integer values of exponent values.</p>
<p>Let's see if this changes for a power of 4:</p>
<div id="graph_std_pow_4" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_4" type="button" value="Logarithmic scale"><p>The numbers are almost the same. It seems the algorithm used for approximation
of the power does not depend on the exponent itself (at least between 3 and 4).</p>
</section><section id="fast-math"><h2>fast math</h2>
<p>One compiler option is very important to consider here: -ffast-math. This
compiler option will make some math operations much faster, but will also
violate a lot of IEEE compliance. In most cases, it does not matter since this
will mostly cover edge cases resulting in infinities and Not-A-Numbers. It also
will reduce the accuracy of some operations. If you really care about precise
computation, you should not use -ffast-math, but in most case, I think it's fine.
Any way, let's see if that changes anything:</p>
<div id="graph_std_pow_fast_2" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_fast_2" type="button" value="Logarithmic scale"><p>For second power, it does not change anything. Let's see about the third power:</p>
<div id="graph_std_pow_fast_3" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_fast_3" type="button" value="Logarithmic scale"><p>For the third power, for <code>std::pow(x, 3)</code>, it is now much faster than
before. Even though it's still faster to use <code>x * x * x</code> than
<code>std::pow(x, 3)</code>, the difference is <em>only</em> around 2.5 times slower.</p>
</section><section id="clang"><h2>Clang</h2>
<p>I've tested several version of G++ (4.9.4, 5.4.0 and 6.4.0) and I've not seen
any significant difference in performance. Let's see if there are differences
between clang-3.9 and GCC 6.4.0. Since we are using a function from the library,
let's see if using libc++ makes any difference.</p>
<div id="graph_std_pow_compilers_1" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_compilers_1" type="button" value="Logarithmic scale"><p>As it turns out, there is not much difference between the two compilers, but
clang is actually around 15% slower here. Moreover, there is no difference
between the two libraries. Let's see if this makes a difference for third power:</p>
<div id="graph_std_pow_compilers_2" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_compilers_2" type="button" value="Logarithmic scale"><p>This time, the difference between the two compilers is more significant, clang
is about 50% slower than GCC on this. Again, there is no significant difference
between the two C++ libraries. I was expecting more of a difference between the
two, but it seems they are using a similar implementations, if not the same.</p>
</section><section id="double-precision"><h2>double precision</h2>
<p>As said earlier, all the tests were run in single precision (<code>float</code>).
Let's see now if it's any different with double precision (<code>double</code>).
Again, I'll use G++ 5.4.0 to start with.</p>
<p>Here are the results first without -ffast-math:</p>
<div id="graph_std_pow_double_2" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_double_2" type="button" value="Logarithmic scale"><p>This is very interesting! Here there is no overhead of using <code>std::pow</code>
compared to direct multiplication (<code>x * x</code>). It seems that most of the
overhead of this function for single precision was in fact in conversion to
double since it seems that the algorithm itself is only implemented for double
precision. Let's see about third power now:</p>
<div id="graph_std_pow_double_3" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_double_3" type="button" value="Logarithmic scale"><p>As seen before, with third power, the overhead is actually huge. Although this
is slightly faster than when using single precision, it is still 2 orders of
magnitude slower than direct multiplication <code>x * x * x</code>. Let's see what
happens with -ffast-math:</p>
<div id="graph_std_pow_double_4" style="width: 700px; height: 400px;"></div>
<input id="graph_button_std_pow_double_4" type="button" value="Logarithmic scale"><p>With -ffast-math, there is absolutely no overhead anymore for <code>std::pow(x, n)</code>
even for third power. The results are the same for clang. I've checked for
higher values of the exponent and the result is also the same.</p>
</section><section id="bigger-exponents"><h2>Bigger exponents</h2>
<p>Now, let's try to test for which <code>n</code> is <code>code:std::pow(x, n)</code>
becoming faster than multiplying in a loop. Since std::pow is using a special
algorithm to perform the computation rather than be simply loop-based
multiplications, there may be a point after which it's more interesting to use
the algorithm rather than a loop.</p>
<p>First, our pow function:</p>
<div class="code"><pre class="code c++"><a id="rest_code_a713b3dfba60425d8e306439909eb7c4-1" name="rest_code_a713b3dfba60425d8e306439909eb7c4-1" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-1"></a><span class="kt">double</span><span class="w"> </span><span class="nf">my_pow</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-2" name="rest_code_a713b3dfba60425d8e306439909eb7c4-2" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-2"></a><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-3" name="rest_code_a713b3dfba60425d8e306439909eb7c4-3" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-3"></a>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-4" name="rest_code_a713b3dfba60425d8e306439909eb7c4-4" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-4"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-5" name="rest_code_a713b3dfba60425d8e306439909eb7c4-5" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-5"></a><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-6" name="rest_code_a713b3dfba60425d8e306439909eb7c4-6" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-6"></a><span class="w">        </span><span class="o">--</span><span class="n">n</span><span class="p">;</span>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-7" name="rest_code_a713b3dfba60425d8e306439909eb7c4-7" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-7"></a><span class="w">    </span><span class="p">}</span>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-8" name="rest_code_a713b3dfba60425d8e306439909eb7c4-8" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-8"></a>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-9" name="rest_code_a713b3dfba60425d8e306439909eb7c4-9" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-9"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<a id="rest_code_a713b3dfba60425d8e306439909eb7c4-10" name="rest_code_a713b3dfba60425d8e306439909eb7c4-10" href="cpp11-performance-tip-when-to-use-std-pow.html#rest_code_a713b3dfba60425d8e306439909eb7c4-10"></a><span class="p">}</span>
</pre></div>
<p>And now, let's see the performance. I've compiled my benchmark with GCC 4.9.3
and running on my old Sandy Bridge processor. Here are the results for 1000
calls to each functions:</p>
<div id="graph_std_pow_my_pow_1" style="width: 700px; height: 400px;"></div>
<p>We can see that between <code>n=100</code> and <code>n=110</code>, <code>std::pow(x, n)</code>
starts to be faster than <code>my_pow(x, n)</code>. At this point, you should only
use <code>std::pow(x, n)</code>.  Interestingly too, the time for <code>std::pow(x,
n)</code> is decreasing. Let's see how is the performance with higher range of
<code>n</code>:</p>
<div id="graph_std_pow_my_pow_2" style="width: 700px; height: 400px;"></div>
<p>We can see that the pow function time still remains stable while our loop-based
pow function still increases linearly. At <code>n=1000</code>, <code>std::pow</code> is
one order of magnitude faster than <code>my_pow</code>.</p>
<p>Overall, if you do not care much about extreme accuracy, you may consider using
you own pow function for small-ish (integer) <code>n</code> values. After
<code>n=100</code>, it becomes more interesting to use <code>std::pow</code>.</p>
</section><section id="conclusion"><h2>Conclusion</h2>
<p>If you are using double precision (<code>double</code>), <code>std::pow(x, n)</code> will
be slower than the handcrafted equivalent unless you use -ffast-math, in which
case, there is absolutely no overhead. The overhead without using the compiler
option is quite large, around 2 orders of magnitude, starting from the third
power. With or without -ffast-math, std::pow(x, 2) has no overhead compared to
<code>x * x</code>.</p>
<p>For single precision, it's another story! For the two compilers that have been
tested and for small integer values of n (but I think it's stays the same for
large integer values of n), it's always faster to use direct multiplication
rather than exponentiation via <code>std::pow(x, n)</code>. Indeed, it seems that
there is no optimization for the case when n is an integer. When -ffast-math is
used, the difference it not very big, around 2.5 times slower for GCC and around
3.5 times slower for clang. I'm a bit disappointed by the lack of
single-precision performance for <code>std::pow</code>. Basically, you should not use
<code>std::pow</code> if you want single-precision powers.</p>
<p>I hope you found this benchmark interesting :)</p>
<p>For those interested in the code of the benchmark, it's available
<a class="reference external" href="https://github.com/wichtounet/articles">on Github</a>.</p>
<script type="text/javascript" src="https://www.google.com/jsapi"></script><script type="text/javascript">google.load('visualization', '1.0', {'packages':['corechart']});</script><script type="text/javascript">
function draw_graph_pow_2(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 2)', 'std::pow(x, 2)', 'x * x'],
['100',      0.1,     0.1,      0.1],
['1000',     3,     3,      1],
['10000',    32,    32,     14],
['100000',   326,   323,    147],
['1000000',  3253,  3238,   1471],
['10000000', 32457, 32465,  14756],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_2'));
var options = {curveType: "function",title: "std::pow(x, 2) (float)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_2');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_3(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 3)', 'std::pow(x, 3)', 'x * x * x'],
['100',      29,      15,       0.1],
['1000',     123,     119,      1],
['10000',    1193,    1192,     14],
['100000',   11998,   11942,    147],
['1000000',  125629,  125245,   1473],
['10000000', 1213756, 1217333,  14756],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_3'));
var options = {curveType: "function",title: "std::pow(x, 3) (float)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_3');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_4(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 4)', 'std::pow(x, 4)', 'x * x * x * x'],
['100',      19,      17,       0.1],
['1000',     123,     122,      1],
['10000',    1203,    1219,     14],
['100000',   12223,   11981,    147],
['1000000',  121036,  119601,   1472],
['10000000', 1198359, 1196447,  14728],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_4'));
var options = {curveType: "function",title: "std::pow(x, 4) (float)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_4');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_fast_2(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 2)', 'std::pow(x, 2)', 'x * x'],
['100',      0.1,     0.1,      0.1],
['1000',     3,       3,        1],
['10000',    32,      32,       14],
['100000',   326,     324,      147],
['1000000',  3239,    3238,     1473],
['10000000', 32398,   32384,    14756],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_fast_2'));
var options = {curveType: "function",title: "std::pow(x, 2) (float) -ffast-math",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_fast_2');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_fast_3(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 2)', 'std::pow(x, 2)', 'x * x'],
['100',      0.1,     0.1,      0.1],
['1000',     3,       3,        1],
['10000',    32,      32,       14],
['100000',   324,     324,      147],
['1000000',  3249,    3243,     1472],
['10000000', 32491,   32519,    14718],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_fast_3'));
var options = {curveType: "function",title: "std::pow(x, 2) (float) -ffast-math",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_fast_3');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_compilers_1(){
var data = google.visualization.arrayToDataTable([
['N', 'g++-6.4', 'clang-3.9', 'clang-3.9 libc++'],
['100',      0.1,     0.1,      0.1],
['1000',     3,       3,        3],
['10000',    32,      37,       37],
['100000',   324,     374,      370],
['1000000',  3249,    3714,     3716],
['10000000', 32491,   37132,    37136],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_compilers_1'));
var options = {curveType: "function",title: "std::pow(x, 2) (float)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_compilers_1');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_compilers_2(){
var data = google.visualization.arrayToDataTable([
['N', 'g++-6.4', 'clang-3.9', 'clang-3.9 libc++'],
['100',      0.1,     0.1,      0.1],
['1000',     3,       4,        5],
['10000',    32,      48,       48],
['100000',   325,     482,      481],
['1000000',  3244,    4828,     4824],
['10000000', 32489,   48242,    48332],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_compilers_2'));
var options = {curveType: "function",title: "std::pow(x, 3) (float)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_compilers_2');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_double_2(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 2)', 'std::pow(x, 2)', 'x * x'],
['100',      0.1,   0.1,    0.1],
['1000',     1,     1,      1],
['10000',    16,    12,     12],
['100000',   122,   122,    122],
['1000000',  1228,  1228,   1228],
['10000000', 12323, 12714,  12380],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_double_2'));
var options = {curveType: "function",title: "std::pow(x, 2) (double)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_double_2');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_double_3(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 3)', 'std::pow(x, 3)', 'x * x * x'],
['100',      27,      16,       0.1],
['1000',     122,     119,      1],
['10000',    1179,    1181,     13],
['100000',   12181,   11794,    129],
['1000000',  124035,  122994,   1298],
['10000000', 1194969, 1195090,  13017],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_double_3'));
var options = {curveType: "function",title: "std::pow(x, 3) (double)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_double_3');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_double_4(){
var data = google.visualization.arrayToDataTable([
['N', 'pow(x, 3)', 'std::pow(x, 3)', 'x * x * x'],
['100',      0.1,   0.1,    0.1],
['1000',     1,     1,      1],
['10000',    14,    14,     14],
['100000',   147,   147,    147],
['1000000',  1471,  1473,   1473],
['10000000', 14744, 14740,  14745],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_double_4'));
var options = {curveType: "function",title: "std::pow(x, 3) (double) -ffast-math",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
var button = document.getElementById('graph_button_std_pow_double_4');
button.onclick = function(){
if(options.vAxis.logScale){
button.value="Logarithmic Scale";
} else {
button.value="Normal scale";
}
options.vAxis.logScale=!options.vAxis.logScale;
graph.draw(data, options);
};
}
function draw_graph_pow_my_pow_1(){
var data = google.visualization.arrayToDataTable([
['n', 'my_pow(x, n)', 'std::pow(x, n)'],
['10',   2,     127],
['20',   17,     123],
['30',   26,     127],
['40',   36,     123],
['50',   43,     123],
['60',   55,     123],
['70',   72,     123],
['80',   85,     123],
['90',   102,    126],
['100',  114,    125],
['110',  131,    115],
['120',  144,    111],
['130',  165,    111],
['140',  173,    108],
['150',  189,    107],
['160',  202,    112],
['170',  219,    106],
['180',  232,    105],
['190',  249,    108],
['200',  261,    105],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_my_pow_1'));
var options = {curveType: "function",title: "std::pow(x, 2) (float)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
}
function draw_graph_pow_my_pow_2(){
var data = google.visualization.arrayToDataTable([
['n', 'my_pow(x, n)', 'std::pow(x, n)'],
['100',  114,    125],
['200',  261,    105],
['300',  410,    104],
['400',  558,    104],
['500',  708,    104],
['600',  855,    104],
['700',  1002,   104],
['800',  1148,   104],
['900',  1300,   104],
['1000', 1442,   104],
]);
var graph = new google.visualization.LineChart(document.getElementById('graph_std_pow_my_pow_2'));
var options = {curveType: "function",title: "std::pow(x, 2) (float)",animation: {duration:1200, easing:"in"},width: 700, height: 400,hAxis: {title:"Number of elements", slantedText:true},vAxis: {viewWindow: {min:0}, title:"us"}};
graph.draw(data, options);
}
function draw_all(){
draw_graph_pow_2();
draw_graph_pow_3();
draw_graph_pow_4();
draw_graph_pow_fast_2();
draw_graph_pow_fast_3();
draw_graph_pow_compilers_1();
draw_graph_pow_compilers_2();
draw_graph_pow_double_2();
draw_graph_pow_double_3();
draw_graph_pow_double_4();
draw_graph_pow_my_pow_1();
draw_graph_pow_my_pow_2();
}
google.setOnLoadCallback(draw_all);
</script></section><h3>Related articles</h3>
    

    <li><a href="cpp11-performance-tip-update-when-to-use-std-pow.html">C++11 Performance tip: Update on when to use std::pow ?</a></li>
<li><a href="../05/cpp-containers-benchmark-vector-list-deque-plf-colony.html">C++ Containers Benchmark: vector/list/deque and plf::colony</a></li>
<li><a href="../../2012/11/cpp-benchmark-vector-vs-list.html">C++ benchmark - std::vector VS std::list</a></li>
<li><a href="../../2012/12/cpp-benchmark-vector-list-deque.html">C++ benchmark – std::vector VS std::list VS std::deque</a></li>
<li><a href="../../2012/12/cpp-benchmark-std-list-boost-intrusive-list.html">C++ Benchmark - std::list VS boost::intrusive::list</a></li>
<li><a href="../../2012/11/gcc-4-7-clang-3-1-eddic.html">GCC 4.7 vs CLang 3.1 on eddic</a></li>


    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/benchmark.html" rel="tag">Benchmark</a></li>
            <li><a class="tag p-category" href="../../../categories/c%2B%2B.html" rel="tag">C++</a></li>
            <li><a class="tag p-category" href="../../../categories/c%2B%2B11.html" rel="tag">C++11</a></li>
            <li><a class="tag p-category" href="../../../categories/performances.html" rel="tag">Performances</a></li>
            <li><a class="tag p-category" href="../../../categories/tip.html" rel="tag">Tip</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="budgetwarrior-042-budget-summary-improved-fortune-reports.html" rel="prev" title="budgetwarrior 0.4.2 - Budget summary and improved fortune reports">Previous post</a>
            </li>
            <li class="next">
                <a href="how-i-made-deep-learning-library-38-faster-to-compile-optimization-and-cpp17-if-constexpr.html" rel="next" title="How I made my Deep Learning Library 38% faster to compile (Optimization and C++17 if constexpr)">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
    
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="https://baptiste-wicht.com/posts/2017/09/cpp11-performance-tip-when-to-use-std-pow.html",
        disqus_title="C++11 Performance tip: When to use std::pow ?",
        disqus_identifier="cache/posts/2017/09/cpp11-performance-tip-when-to-use-std-pow.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         <a href="mailto:baptistewicht@gmail.com">Baptiste Wicht</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         - License: 
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="padding-left:5px;border-width:0" src="../../../assets/img/cc.png"></a>
            
        </footer>
</div>
</div>


            <script src="../../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
