<!DOCTYPE html>
<html lang=en><head><link href=favicon.ico rel=icon type=image/x-icon><meta name=viewport content="width=device-width, initial-scale=1.0"><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=author content="Baptiste Wicht"><title>Java Concurrency - Part 6 : Atomic Variables | @Blog("Baptiste Wicht")</title><link href=../../../assets/css/all-nocdn.css rel=stylesheet type=text/css><link rel=canonical href=http://wichtounet.github.io/posts/2010/09/java-concurrency-atomic-variables.html><link rel=alternate type=application/rss+xml title=RSS href=../../../rss.xml></head><body><div class=social_container> <div class=social_container_gplus> <a target=_blank title="Share on Google+" href="https://plusone.google.com/_/+1/confirm?hl=en&amp;url=http://wichtounet.github.io/posts/2010/09/java-concurrency-atomic-variables.html"><img src=../../../assets/img/google_plus.png></a> </div> <div class=social_container_facebook> <a target=_blank title="Share on Facebook" href="http://www.facebook.com/sharer/sharer.php?u=#url"><img src=../../../assets/img/facebook.png></a> </div> <div class=social_container_twitter> <a target=_blank title="Tweet on Twitter" href="http://twitter.com/home?status=#url"><img src=../../../assets/img/twitter.svg></a> </div></div><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class=navbar-toggle data-toggle=collapse data-target=.navbar-ex1-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=http://wichtounet.github.io/>@Blog("Baptiste Wicht")</a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href=../../../stories/about.html>About</a> </li><li><a href=../../../stories/publications.html>Publications</a> </li><li><a href=../../../stories/donate.html>Donate</a> </li><li><a href=../../../stories/contact.html>Contact</a> </li><li><a href=../../../stories/faq.html>FAQ</a> </li><li><a href=../../../stories/legal.html>Legal</a> </li><li><a href=../../../archive.html>Archives</a> </li><li><a href=../../../categories/index.html>Tags</a> </li><li><a href=../../../rss.xml>RSS</a> </li></ul> <span class="navbar-form pull-left"> <form action=../../../stories/search.html> <input type=text name=q id=tipue_search_input> </form> </span> <ul class="nav navbar-nav navbar-right"> <li> <a target=_blank title="Follow @wichtounet on Twitter" href=https://twitter.com/wichtounewichtounet> <img src=../../../assets/img/twitter.svg alt="Follow @wichtounet on Twitter"> </a> </li> <li> <a target=_blank title="Follow +BaptisteWicht on Google+" href=https://plus.google.com/+BaptisteWicht> <img src=../../../assets/img/google_plus.svg alt="Follow +BaptisteWicht on Google+"> </a> </li> </ul> </div> </div></nav><div class=body-container> <div class=left-sidebar> <div class=left-sidebar-widget> <div class=left-sidebar-widget-content> <div class=g-person data-width=275 data-href=//plus.google.com/u/0/103113673902796202116 data-theme=dark data-layout=landscape data-rel=author></div> </div> </div> <div class=left-sidebar-widget> <h3>Related posts</h3> <div class=left-sidebar-widget-content> <ol><li><a href=../../2009/12/swing-user-interface-jtable.html>Creation of Swing User Interface : Tables (JTable)</a></li><li><a href=../01/jr-introduction.html>Introduction to JR programming language</a></li><li><a href=../08/java-concurrrency-synchronization-locks.html>Java Concurrency – Part 3 : Synchronization with intrinsic locks</a></li><li><a href=java-synchronization-mutual-exclusion-benchmark.html>Java Synchronization (Mutual Exclusion) Benchmark</a></li><li><a href=../../2012/03/cp11-concurrency-tutorial-part-2-protect-shared-data.html>C++11 Concurrency Tutorial - Part 2 : Protect shared data</a></li></ol> </div> </div> <div class=left-sidebar-widget> <h3>Recent comments</h3> <div class=left-sidebar-widget-content> <div id=recentcomments class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=28&amp;excerpt_length=50"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Popular posts</h3> <div class=left-sidebar-widget-content> <div id=popularthreads class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/popular_threads_widget.js?num_items=5&amp;days_back=90"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Blogroll</h3> <div class=left-sidebar-widget-content> <ul> <li><a target=_blank href=http://www.asjava.com/>AsJava.com : Java Tutorial</a></li> <li><a target=_blank href=http://www.mkyong.com/>Mkyong : Java Tutorials</a></li> </ul> </div> </div> </div> <div class=container> <div class=body-content style="margin-top: -75px;"> <div class=row> <article class="postbox post-text"> <div class=h-entry itemscope=itemscope itemtype=http://schema.org/Article> <h1 class=p-name itemprop="headline name">Java Concurrency - Part 6 : Atomic Variables</h1> <hr> <small> Posted: <time class="published dt-published" datetime=2010-09-08T07:14:18+02:00 itemprop=datePublished>2010-09-08 07:14</time>   |   More posts about <span itemprop=keywords> <a class="tag p-category" href=../../../categories/concurrency.html><span class="badge badge-info">Concurrency</span></a> <a class="tag p-category" href=../../../categories/java.html><span class="badge badge-info">Java</span></a> </span> </small> <hr> <div class=e-content itemprop="articleBody text"> <div><p>When a data (typically a variable) can be accessed by several threads, you must synchronize the access to the data to ensure visibility and correctness. </p><p>By example, if you have a simple counter (yes, once again) : </p><div class=code><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Counter</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getPreviousValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>--;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div><p>This class works really well in single-threaded environment, but don't work at all when several threads access the same Counter instance. If you don't know why, read <a target=_blank href=http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/>this post about synchronization</a>. You can solve the problem using synchronized at method level : </p><div class=code><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SynchronizedCounter</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>int</span> <span class=nf>getValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>int</span> <span class=nf>getPreviousValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>--;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div><p>This class now works well. But locking is not a lightweight mechanism and have several disadvantages. When several threads try to acquire the same lock, one or more threads will be suspended and they will be resumed later. When the critical section is little, the overhead is really heavy especially when the lock is often acquired and there is a lot of contention. Another disadvantage is that the other threads waiting of the lock cannot do something else during waiting and if the thread who has the lock is delayed (due to a page fault or the end of the time quanta by example), the others threads cannot take their turn. </p><p>So how to do to avoid this disadvantages ? We must use non-blocking algorithms. This algorithms don't use blocking mechanisms and by that fact are more scalable and performing. These algorithms use low-level machine instructions which are atomic to ensure the atomicity of higher-level operations. While locking is a pessimistic approach, we can also use optimistic technique to develop algorithms. This time, we'll detect collisions between threads in which case, the operation fails and we do something else (often retrying the same operation).</p><p>The actual processors provide several instructions that simplify greatly the implementation of these non-blocking algorithms, the most-used operation today is the compare-and-swap operation (CAS). This operation takes three parameters, the memory address, the expected current value and the new value. It atomically update the value at the given memory address if the current value is the expected, otherwise it do nothing. In both cases, the operation return the value at the address after the operation execution. So when several threads try to execute the CAS operation, one thread wins and the others do nothing. So the caller can choose to retry or to do something else. We often use this operation to implement another operation, the compare-and-set. This method makes exactly the same things as CAS but return a boolean indicating if the operation succeeded or not. </p><p>Before Java 5.0, this operation was not available directly to developer, but in Java 5.0 several atomic variables (for int, long, boolean and reference values) were added. The int and long versions also supports numeric operations. The JVM compiles these classes with the better operations provided by the hardware machine, CAS or a Java implementation of the operation using a lock. Here are the classes : </p><ul><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li></ul><p>All these classes supports compare-and-set (via the compareAndSet() method) and other operations (get(), set() and getAndSet()). The setters operations are implemented using compareAndSet. These classes supports multi-threaded access and have a better scalability than synchronizing all the operations. </p><p>Here is how we can rewrite our counter using an AtomicInteger : </p><div class=code><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AtomicCounter</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>AtomicInteger</span> <span class=n>value</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicInteger</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>.</span><span class=na>incrementAndGet</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getPreviousValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>.</span><span class=na>decrementAndGet</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div><p>The incrementAndGet() and decrementAndGet() methods are two of the numeric operations provided by the AtomicLong and AtomicInteger classes. You also have getAndDecrement(), getAndIncrement(), getAndAdd(int i) and addAndGet(). </p><p>This version is faster than the synchronized one and is also thread safe. </p><p>If you only have the compareAndSet(), here is how we can implement increment() method using it : </p><div class=code><pre><span class=kd>public</span> <span class=kt>void</span> <span class=nf>increment</span><span class=o>(</span><span class=n>AtomicInteger</span> <span class=n>integer</span><span class=o>){</span>
    <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
        <span class=kt>int</span> <span class=n>current</span> <span class=o>=</span> <span class=n>integer</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
        <span class=kt>int</span> <span class=n>next</span> <span class=o>=</span> <span class=n>current</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>

        <span class=k>if</span><span class=o>(</span><span class=n>integer</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>current</span><span class=o>,</span> <span class=n>next</span><span class=o>)){</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div><p>This seems to be complicated, but this is the cost of non-blocking algorithms. When we detect collision, we retry until the operation succeeded. This is the common schema for non-blocking algorithms. </p><p>Here is a thread-safe Stack implemented using AtomicReference : </p><div class=code><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Stack</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>AtomicReference</span><span class=o>&lt;</span><span class=n>Element</span><span class=o>&gt;</span> <span class=n>head</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicReference</span><span class=o>&lt;</span><span class=n>Element</span><span class=o>&gt;(</span><span class=kc>null</span><span class=o>);</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=n>String</span> <span class=n>value</span><span class=o>){</span>
        <span class=n>Element</span> <span class=n>newElement</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Element</span><span class=o>(</span><span class=n>value</span><span class=o>);</span>

        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
            <span class=n>Element</span> <span class=n>oldHead</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
            <span class=n>newElement</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>oldHead</span><span class=o>;</span>

            <span class=c1>//Trying to set the new element as the head</span>
            <span class=k>if</span><span class=o>(</span><span class=n>head</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>oldHead</span><span class=o>,</span> <span class=n>newElement</span><span class=o>)){</span>
                <span class=k>return</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>String</span> <span class=nf>pop</span><span class=o>(){</span>
        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
            <span class=n>Element</span> <span class=n>oldHead</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>

            <span class=c1>//The stack is empty</span>
            <span class=k>if</span><span class=o>(</span><span class=n>oldHead</span> <span class=o>==</span> <span class=kc>null</span><span class=o>){</span>
                <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
            <span class=o>}</span>

            <span class=n>Element</span> <span class=n>newHead</span> <span class=o>=</span> <span class=n>oldHead</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>

            <span class=c1>//Trying to set the new element as the head</span>
            <span class=k>if</span><span class=o>(</span><span class=n>head</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>oldHead</span><span class=o>,</span> <span class=n>newHead</span><span class=o>)){</span>
                <span class=k>return</span> <span class=n>oldHead</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>Element</span> <span class=o>{</span>
        <span class=kd>private</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>value</span><span class=o>;</span>
        <span class=kd>private</span> <span class=n>Element</span> <span class=n>next</span><span class=o>;</span>

        <span class=kd>private</span> <span class=nf>Element</span><span class=o>(</span><span class=n>String</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>this</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div><p>It's really more complicated than using synchronized on the two methods but also more performing if there is contention (and often even if there is no contention). </p><p>So this ends this post. To conclude, atomic variables classes are a really good way to implement non-blocking algorithms and moreover are also a very good alternative to volatile variables, because they can provide atomicity and visibility.</p></div> </div> </div> <ul class=pager> <li class=previous> <a href=java-concurrency-part-5-monitors-locks-and-conditions.html rel=prev>← Previous post</a> </li> <li class=next> <a href=tip-batch-resize-images-on-ubuntu-linux.html rel=next>Next post →</a> </li> </ul> <div id=disqus_thread></div> <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://wichtounet.github.io/posts/2010/09/java-concurrency-atomic-variables.html",
        disqus_title="Java Concurrency - Part 6 : Atomic Variables",
        disqus_identifier="cache/posts/2010/09/java-concurrency-atomic-variables.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> <a href=http://disqus.com class=dsq-brlink rel=nofollow>Comments powered by <span class=logo-disqus>Disqus</span></a> </article> </div> </div> </div></div><footer> Contents © 2014 <a href=mailto:baptistewicht@gmail.com>Baptiste Wicht</a> - Powered by <a href=http://getnikola.com rel=nofollow>Nikola</a><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons License" style=padding-left:5px;border-width:0 src=../../../assets/img/cc.png></a> <ul class=footer_inline_ul> <li> <a href=java-concurrency-atomic-variables.wp id=sourcelink>Source</a> </li> </ul></footer> <script src=../../../assets/js/all-nocdn.js type=text/javascript></script><script type=text/javascript src=https://apis.google.com/js/platform.js></script></body></html>