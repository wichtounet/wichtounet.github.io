<!DOCTYPE html><html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Baptiste Wicht">
    <title>Java Concurrency - Part 6 : Atomic Variables | @Blog("Baptiste Wicht")</title>
    
            <link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
      <link rel="canonical" href="http://wichtounet.github.io/posts/2010/09/java-concurrency-atomic-variables.html">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">

    





    
<link rel="stylesheet" type="text/css" href="../../../assets/css/tipuesearch.css">
</head><body><div id="tipue_search_content" style="margin-left: auto; margin-right: auto; padding: 20px;"></div>




<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container-fluid"><!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://wichtounet.github.io/">@Blog("Baptiste Wicht")</a>
        </div><!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li><a href="../../../stories/about.html">About</a>
                </li><li><a href="../../../stories/publications.html">Publications</a>
                </li><li><a href="../../../stories/donate.html">Donate</a>
                </li><li><a href="../../../stories/faq.html">FAQ</a>
                </li><li><a href="../../../stories/legal.html">Legal</a>
                </li><li><a href="../../../archive.html">Archives</a>
                </li><li><a href="../../../categories/index.html">Tags</a>
                </li><li><a href="../../../rss.xml">RSS</a>

            </li></ul>
                
<span class="navbar-form pull-left">
<input type="text" id="tipue_search_input">
</span>

            <ul class="nav navbar-nav navbar-right">
                
                
            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>

<!-- End of Menubar -->

<div class="body-container">

    <!-- Sidebar -->

    <div class="left-sidebar">
        <div class="left-sidebar-widget">
            <h3>Something, something</h3>
            <div class="left-sidebar-widget-content">
                ...dark side...
            </div>
        </div>
        
        <div class="left-sidebar-widget">
            <h3>Tags</h3>
            <div class="left-sidebar-widget-content">
                <div id="tags_container">
                    <canvas width="275" height="250" id="tags_canvas">
                        <p>Anything in here will be replaced on browsers that support the canvas element</p>
                    </canvas>
                </div>
            </div>
        </div>
        
        <div class="left-sidebar-widget">
            <h3>Blogroll</h3>
            <div class="left-sidebar-widget-content">
                <ul>
                    <li><a target="_blank" href="http://www.asjava.com/">AsJava.com : Java Tutorial</a></li>
                    <li><a target="_blank" href="http://www.mkyong.com/">Mkyong : Java Tutorials</a></li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Content -->

    <div class="container">
        <div class="body-content">
            <!--Body content-->
            <div class="row">
                
    <article class="postbox post-text">
    <div class="h-entry" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <h1 class="p-name" itemprop="headline name">Java Concurrency - Part 6 : Atomic Variables</h1>

    <hr>
    <small>
        Posted: <time class="published dt-published" datetime="2010-09-08T07:14:18+00:00" itemprop="datePublished">2010-09-08 07:14</time>
        

        
          |  
        More posts about 
    <span itemprop="keywords">
        <a class="tag p-category" href="../../../categories/concurrency.html"><span class="badge badge-info">Concurrency</span></a>
        <a class="tag p-category" href="../../../categories/java.html"><span class="badge badge-info">Java</span></a>
    </span>


    </small>
    <hr>
    <div class="e-content" itemprop="articleBody text">
    <div><p></p><p>When a data (typically a variable) can be accessed by several threads, you must synchronize the access to the data to ensure visibility and correctness. </p>
<p>By example, if you have a simple counter (yes, once again) : </p>
<p>[java]public class Counter {
    private int value;</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getPreviousValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>This class works really well in single-threaded environment, but don't work at all when several threads access the same Counter instance. If you don't know why, read <a target="_blank" href="http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/">this post about synchronization</a>. You can solve the problem using synchronized at method level : </p>
<p>[java]public class SynchronizedCounter {
    private int value;</p>
<div class="code"><pre><span class="n">public</span> <span class="n">synchronized</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="n">synchronized</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="n">synchronized</span> <span class="kt">int</span> <span class="nf">getPreviousValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>This class now works well. But locking is not a lightweight mechanism and have several disadvantages. When several threads try to acquire the same lock, one or more threads will be suspended and they will be resumed later. When the critical section is little, the overhead is really heavy especially when the lock is often acquired and there is a lot of contention. Another disadvantage is that the other threads waiting of the lock cannot do something else during waiting and if the thread who has the lock is delayed (due to a page fault or the end of the time quanta by example), the others threads cannot take their turn. </p>
<p>So how to do to avoid this disadvantages ? We must use non-blocking algorithms. This algorithms don't use blocking mechanisms and by that fact are more scalable and performing. These algorithms use low-level machine instructions which are atomic to ensure the atomicity of higher-level operations. While locking is a pessimistic approach, we can also use optimistic technique to develop algorithms. This time, we'll detect collisions between threads in which case, the operation fails and we do something else (often retrying the same operation).</p>
<p>The actual processors provide several instructions that simplify greatly the implementation of these non-blocking algorithms, the most-used operation today is the compare-and-swap operation (CAS). This operation takes three parameters, the memory address, the expected current value and the new value. It atomically update the value at the given memory address if the current value is the expected, otherwise it do nothing. In both cases, the operation return the value at the address after the operation execution. So when several threads try to execute the CAS operation, one thread wins and the others do nothing. So the caller can choose to retry or to do something else. We often use this operation to implement another operation, the compare-and-set. This method makes exactly the same things as CAS but return a boolean indicating if the operation succeeded or not. </p>
<p>Before Java 5.0, this operation was not available directly to developer, but in Java 5.0 several atomic variables (for int, long, boolean and reference values) were added. The int and long versions also supports numeric operations. The JVM compiles these classes with the better operations provided by the hardware machine, CAS or a Java implementation of the operation using a lock. Here are the classes : </p>
<p></p><ul>
<li>AtomicInteger</li>

<li>AtomicLong</li>

<li>AtomicBoolean</li>

<li>AtomicReference</li>

</ul>

<p>All these classes supports compare-and-set (via the compareAndSet() method) and other operations (get(), set() and getAndSet()). The setters operations are implemented using compareAndSet. These classes supports multi-threaded access and have a better scalability than synchronizing all the operations. </p>
<p>Here is how we can rewrite our counter using an AtomicInteger : </p>
<p>[java]public class AtomicCounter {
    private final AtomicInteger value = new AtomicInteger(0);</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getPreviousValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">decrementAndGet</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>The incrementAndGet() and decrementAndGet() methods are two of the numeric operations provided by the AtomicLong and AtomicInteger classes. You also have getAndDecrement(), getAndIncrement(), getAndAdd(int i) and addAndGet(). </p>
<p>This version is faster than the synchronized one and is also thread safe. </p>
<p>If you only have the compareAndSet(), here is how we can implement increment() method using it : </p>
<p>[java]public void increment(AtomicInteger integer){
    while(true){
        int current = integer.get();
        int next = current + 1;</p>
<div class="code"><pre>    <span class="k">if</span><span class="p">(</span><span class="n">integer</span><span class="p">.</span><span class="n">compareAndSet</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next</span><span class="p">)){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>This seems to be complicated, but this is the cost of non-blocking algorithms. When we detect collision, we retry until the operation succeeded. This is the common schema for non-blocking algorithms. </p>
<p>Here is a thread-safe Stack implemented using AtomicReference : </p>
<p>[java]public class Stack {
    private final AtomicReference&lt;Element&gt; head = new AtomicReference&lt;Element&gt;(null);</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">String</span> <span class="n">value</span><span class="p">){</span>
    <span class="n">Element</span> <span class="n">newElement</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Element</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">Element</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="n">newElement</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="p">;</span>

        <span class="c1">//Trying to set the new element as the head</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">compareAndSet</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">newElement</span><span class="p">)){</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">public</span> <span class="n">String</span> <span class="nf">pop</span><span class="p">(){</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">Element</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

        <span class="c1">//The stack is empty</span>
        <span class="k">if</span><span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">null</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Element</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">oldHead</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

        <span class="c1">//Trying to set the new element as the head</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">compareAndSet</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">newHead</span><span class="p">)){</span>
            <span class="k">return</span> <span class="n">oldHead</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="n">class</span> <span class="n">Element</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">final</span> <span class="n">String</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">Element</span> <span class="n">next</span><span class="p">;</span>

    <span class="n">private</span> <span class="nf">Element</span><span class="p">(</span><span class="n">String</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>It's really more complicated than using synchronized on the two methods but also more performing if there is contention (and often even if there is no contention). </p>
<p>So this ends this post. To conclude, atomic variables classes are a really good way to implement non-blocking algorithms and moreover are also a very good alternative to volatile variables, because they can provide atomicity and visibility. </p></div>
    </div>
    </div>
    
        <ul class="pager">
            <li class="previous">
                <a href="java-concurrency-part-5-monitors-locks-and-conditions.html" rel="prev">← Previous post</a>
            </li>
            <li class="next">
                <a href="tip-batch-resize-images-on-ubuntu-linux.html" rel="next">Next post →</a>
            </li>
        </ul>

        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://wichtounet.github.io/posts/2010/09/java-concurrency-atomic-variables.html",
        disqus_title="Java Concurrency - Part 6 : Atomic Variables",
        disqus_identifier="cache/posts/2010/09/java-concurrency-atomic-variables.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


    

    </article>

            </div>
            <!--End of body content-->
        </div>
    </div>
</div>

<!-- Footer -->

<footer>
    Contents © 2014         <a href="mailto:baptistewicht@gmail.com">Baptiste Wicht</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/88x31.png"></a>
        <ul class="footer_inline_ul">
            
    <li>
    <a href="java-concurrency-atomic-variables.wp" id="sourcelink">Source</a>
    </li>

        </ul>
</footer>


            <script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>

    <script type="text/javascript">
      $(document).ready(function() {
        jQuery.getJSON('/assets/js/tag_cloud_data.json', function(data) {
            var items = [];

            $.each(data, function(key, val) {
                items.push('<li><a href="' + val[1] +'" '+'data-weight="'+val[0]+'"'+'>' + key + '</a></li>');
            });

            $('<div/>', {
                'id': 'tags',
                html: '<ul>' + items.join('') + '</ul>'
            }).appendTo('body');

            if(!$('#tags_canvas').tagcanvas({
                textColour: '#FFFFFF',
                outlineColour: '#ff00ff',
                reverse: true,
                depth: 0.8,
                maxSpeed: 0.05,
                weight: true,
                weightFrom: "data-weight",
                weightSizeMin: 8,
                weightSizeMax: 24
            },'tags')) {
            // something went wrong, hide the canvas container
            $('#tags_container').hide();
            }});});
    </script>

    
<!-- AddThis Smart Layers BEGIN -->
<!-- Go to http://www.addthis.com/get/smart-layers to customize -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5327566b264df4ee"></script>
<script type="text/javascript">
  addthis.layers({
    'theme' : 'dark',
    'share' : {
      'position' : 'right',
      'numPreferredServices' : 5
    }, 
    'follow' : {
      'services' : [
        {'service': 'twitter', 'id': 'wichtounet'},
        {'service': 'google_follow', 'id': '+BaptisteWicht'}
      ]
    }   
  });
</script>
<!-- AddThis Smart Layers END -->


    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    

<script type="text/javascript" src="../../../assets/js/tipuesearch_set.js"></script>
<script type="text/javascript" src="../../../assets/js/tipuesearch.js"></script>
<script type="text/javascript">
$(document).ready(function() {
  $('#tipue_search_input').tipuesearch({
      'mode': 'json',
      'contentLocation': '/assets/js/tipuesearch_content.json',
      'showUrl': false
  });
});
</script>


</body></html>