<!DOCTYPE html><html lang="en">
<head>
    <link href="favicon.ico" rel="icon" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Baptiste Wicht">
    <title>Find closest pair of point with Plane Sweep Algorithm in O(n ln n) | @Blog("Baptiste Wicht")</title>
    
            <link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
      <link rel="canonical" href="http://wichtounet.github.io/posts/2010/04/closest-pair-of-point-plane-sweep-algorithm.html">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">

    





<!--
    <link rel="stylesheet" type="text/css" href="/assets/css/tipuesearch.css">
-->
    
</head>
<body>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container-fluid"><!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://wichtounet.github.io/">@Blog("Baptiste Wicht")</a>
        </div><!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li><a href="../../../stories/about.html">About</a>
                </li><li><a href="../../../stories/publications.html">Publications</a>
                </li><li><a href="../../../stories/donate.html">Donate</a>
                </li><li><a href="../../../stories/contact.html">Contact</a>
                </li><li><a href="../../../stories/faq.html">FAQ</a>
                </li><li><a href="../../../stories/legal.html">Legal</a>
                </li><li><a href="../../../archive.html">Archives</a>
                </li><li><a href="../../../categories/index.html">Tags</a>
                </li><li><a href="../../../rss.xml">RSS</a>

            </li></ul>
            <!--
            <span class="navbar-form pull-left">
                <input type="text" id="tipue_search_input">
            </span>
            -->
            <ul class="nav navbar-nav navbar-right">
                
                
            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>

<!-- End of Menubar -->

<div class="body-container">

    <!-- Sidebar -->

    <div class="left-sidebar">
            <div class="left-sidebar-widget">
                <div class="left-sidebar-widget-content">
                    <div class="g-person" data-width="275" data-href="//plus.google.com/u/0/103113673902796202116" data-theme="dark" data-layout="landscape" data-rel="author"></div>
                </div>
            </div>
        
        <div class="left-sidebar-widget">
            <h3>Recent comments</h3>
            <div class="left-sidebar-widget-content">
                <div id="recentcomments" class="dsq-widget">
                    <script type="text/javascript" src="http://blogwichtounet.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=28&amp;excerpt_length=150"></script>
                </div>
            </div>
        </div>
        
        <div class="left-sidebar-widget">
            <h3>Blogroll</h3>
            <div class="left-sidebar-widget-content">
                <ul>
                    <li><a target="_blank" href="http://www.asjava.com/">AsJava.com : Java Tutorial</a></li>
                    <li><a target="_blank" href="http://www.mkyong.com/">Mkyong : Java Tutorials</a></li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Content -->

    <div class="container">
            <div class="body-content" style="margin-top: -75px;">

            <!-- <div id="tipue_search_content" style="margin-left: auto; margin-right: auto; padding: 20px;"></div> -->

            <div class="row">
                
    <article class="postbox post-text">
    <div class="h-entry" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <h1 class="p-name" itemprop="headline name">Find closest pair of point with Plane Sweep Algorithm in O(n ln n)</h1>

    <hr>
    <small>
        Posted: <time class="published dt-published" datetime="2010-04-27T16:08:10+00:00" itemprop="datePublished">2010-04-27 16:08</time>
        

        
          |  
        More posts about 
    <span itemprop="keywords">
        <a class="tag p-category" href="../../../categories/algorithm.html"><span class="badge badge-info">Algorithm</span></a>
        <a class="tag p-category" href="../../../categories/benchmarks.html"><span class="badge badge-info">Benchmarks</span></a>
        <a class="tag p-category" href="../../../categories/conception.html"><span class="badge badge-info">Conception</span></a>
        <a class="tag p-category" href="../../../categories/java.html"><span class="badge badge-info">Java</span></a>
        <a class="tag p-category" href="../../../categories/performances.html"><span class="badge badge-info">Performances</span></a>
    </span>


    </small>
    <hr>
    <div class="e-content" itemprop="articleBody text">
    <div><p></p><p>Finding the closest pair of Point in a given collection of points is a standard problem in computational geometry. In this article I'll explain an efficient algorithm using plane sweep, compare it to the naive implementation and discuss its complexity.</p>
<!--more-->

<p>This problem is standard, but not really easy to solve in an efficient way. The first implementation we think of is the naive one, comparing each point to each other point.</p>
<p>In my examples, I'll use the java.awt.Point class to represent a point. This naive implementation is really easy to implement :</p>
<p>[java]public static Point[] naiveClosestPair(Point[] points) {
    double min = Double.MAX_VALUE;</p>
<div class="code"><pre><span class="n">Point</span><span class="p">[]</span> <span class="n">closestPair</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Point</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>

                <span class="n">closestPair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
                <span class="n">closestPair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">closestPair</span><span class="p">;</span>
</pre></div>


<p>}[/java]</p>
<p>As you can directly see, this naive implementation has a complexity of O(n^2). But we can do a lot better using a plane sweep algorithm.</p>
<p>With that algorithm, we'll sweep the plane from left to right (right to left is also a possibility) and when we reach a point we'll compute all the interesting candidates (the candidates that can be in the closest pair).</p>
<p>For that we'll make the following operations :</p>
<p></p><ol>
    <li>We sort the list of points from left to right in the x axis</li>
    <li>And then for each point :
<ol>
    <li>We remove from the candidates all the point that are further in x axis that the current min distance</li>
    <li>We take all the candidates that are located more or less current min distance from the current point in y axis</li>
    <li>We test for the min distance all the founded candidates with the current point</li>
    <li>And finally we add the current point to the list of candidates</li>
</ol>
</li>

</ol>

<p>So when we found a new min distance, we can make the rectangle of candidates smaller in the x axis and smaller in the y axis. So we make a lot less comparisons between the points.</p>
<p>Here is a picture illustrating that :</p>
<p><a href="../../../wp-content/uploads/2010/04/Sweep.png"><img class="size-full wp-image-473" title="Plane Sweep Algorithm" src="../../../wp-content/uploads/2010/04/Sweep.png" alt="Plane Sweep Algorithm" width="500" height="436"></a></p>
<p>The red points are the closest pair at this time of the algorithm. The red rectangle is the rectangle of the candidates delimited in right by the current point. And the yellow rectangle contains only the candidates interesting for the current point.</p>
<p>There is always a maximum of 6 points in the yellow rectangle, the 4 vertices, the point with the same coordinates as the current point and finally the point in the same y coordinate and in the limit of the x axis. Even if the maximum is 6, you'll almost never have more than 2 points in that list (the maximum is see in my test was 3 with a collection of 1'000'000 random points). You can see this 6 points here :</p>
<p><a href="../../../wp-content/uploads/2010/04/Sweep-points.png"><img class="size-full wp-image-474" title="Maximum points to compare" src="../../../wp-content/uploads/2010/04/Sweep-points.png" alt="Maximum points to compare" width="132" height="232"></a></p>
<p>If all that stuff is not really clear for you, you can watch it in action here <a href="http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairApplet/ClosestPairApplet.html" target="_blank">in a Java applet</a>.</p>
<p>The candidates must also be always sorted. For that, we'll use a Binary Search Tree for good performances.</p>
<p>If we look at the complexity :</p>
<ul>
    <li>Sorting all the points in right axis : Cost O(n ln n) with Quick Sort by example</li>
    <li>Shrinking the list of candidates take O(n) from start to end of the algorithm because we add n points to the candidates and we can remove only n points. So this is constant for each point : O(1).</li>
    <li>Searching all the candidates between two values in y axis cost O(ln n) with binary search</li>
    <li>The comparisons with at maximum 6 points are made in O(1)</li>
    <li>Add the candidates and keep the list of candidates sorted cost O(ln n).</li>
</ul>

<p>So the total complexity is O(n ln(n) + n * ( 1 + ln(n) + 1 + ln(n) ) ) = O(n ln n).</p>
<p>So it's really better than O(n^2) for the naive implementation.</p>
<p>So now, we can go to the implementation in Java.</p>
<p>[java]public static Point[] closestPair(Point[] points) {
    Point[] closestPair = new Point[2];</p>
<div class="code"><pre><span class="c1">//When we start the min distance is the infinity</span>
<span class="n">double</span> <span class="n">crtMinDist</span> <span class="o">=</span> <span class="n">Double</span><span class="p">.</span><span class="no">POSITIVE_INFINITY</span><span class="p">;</span>

<span class="c1">//Get the points and sort them</span>
<span class="n">Point</span><span class="p">[]</span> <span class="n">sorted</span> <span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="n">copyOf</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="n">Arrays</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="no">HORIZONTAL_COMPARATOR</span><span class="p">);</span>

<span class="c1">//When we start the left most candidate is the first one</span>
<span class="k">int</span> <span class="n">leftMostCandidateIndex</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>

<span class="c1">//Vertically sorted set of candidates</span>
<span class="n">SortedSet</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Point</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Point</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;(</span><span class="no">VERTICAL_COMPARATOR</span><span class="p">);</span>

<span class="c1">//For each point from left to right</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">current</span> <span class="o">:</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//Shrink the candidates</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">sorted</span><span class="p">[</span><span class="n">leftMostCandidateIndex</span><span class="p">].</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">gt</span><span class="p">;</span> <span class="n">crtMinDist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">candidates</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sorted</span><span class="p">[</span><span class="n">leftMostCandidateIndex</span><span class="p">]);</span>
        <span class="n">leftMostCandidateIndex</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//Compute the y head and the y tail of the candidates set</span>
    <span class="n">Point</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">crtMinDist</span><span class="p">));</span>
    <span class="n">Point</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">crtMinDist</span><span class="p">));</span>

    <span class="c1">//We take only the interesting candidates in the y axis</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">point</span> <span class="o">:</span> <span class="n">candidates</span><span class="p">.</span><span class="n">subSet</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">double</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>

        <span class="c1">//Simple min computation</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">crtMinDist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">crtMinDist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>

            <span class="n">closestPair</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="n">closestPair</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//The current point is now a candidate</span>
    <span class="n">candidates</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">closestPair</span><span class="p">;</span>
</pre></div>


<p>}[/java]</p>
<p>The code isn't overcomplicated. We see all the steps explained in the article and that works well. The Horizontal and Vertical comparators are really simple : </p>
<p>[java]private static final Comparator&lt;Point&gt; VERTICAL_COMPARATOR = new Comparator&lt;Point&gt;() {
    @Override
    public int compare(Point a, Point b) {
        if (a.y &lt; b.y) {
            return -1;
        }
        if (a.y &gt; b.y) {
            return 1;
        }
        if (a.x &lt; b.x) {
            return -1;
        }
        if (a.x &gt; b.x) {
            return 1;
        }
        return 0;
    }
};</p>
<p>private static final Comparator&lt;Point&gt; HORIZONTAL_COMPARATOR = new Comparator&lt;Point&gt;() {
    @Override
    public int compare(Point a, Point b) {
        if (a.x &lt; b.x) {
            return -1;
        }
        if (a.x &gt; b.x) {
            return 1;
        }
        if (a.y &lt; b.y) {
            return -1;
        }
        if (a.y &gt; b.y) {
            return 1;
        }
        return 0;
    }
}[/java]</p>
<p>Here is a performance comparison for some sizes with <a href="http://www.baptiste-wicht.com/2010/04/write-corrects-benchmarks/" target="_blank">a Benchmark Framework I described here</a> for some sizes of collection points.</p>
<table border="1" cellspacing="0" cellpadding="0">

<tbody>

<tr>

<td width="55" valign="top"><strong> </strong></td>

<td width="91" valign="top"><strong>Naive</strong></td>

<td width="87" valign="top"><strong>Sweeping</strong></td>

</tr>

<tr>

<td width="55" valign="top"><strong>100</strong></td>

<td width="91" valign="top">189.923 us</td>

<td width="87" valign="top">53.685 us</td>

</tr>

<tr>

<td width="55" valign="top"><strong>500</strong></td>

<td width="91" valign="top">4.448 ms</td>

<td width="87" valign="top">279.042 us</td>

</tr>

<tr>

<td width="55" valign="top"><strong>1000</strong></td>

<td width="91" valign="top">17.790 ms</td>

<td width="87" valign="top">556.731 us</td>

</tr>

<tr>

<td width="55" valign="top"><strong>5000</strong></td>

<td width="91" valign="top">458.728 ms</td>

<td width="87" valign="top">3.320 ms</td>

</tr>

</tbody>

</table>

<p>Like you can see, this is really better than the naive implementation. So we make a good job. But if we make one more test with 10 elements :</p>
<table border="1" cellspacing="0" cellpadding="0">

<tbody>

<tr>

<td width="55" valign="top"><strong> </strong></td>

<td width="91" valign="top"><strong>Naive</strong></td>

<td width="87" valign="top"><strong>Sweeping</strong></td>

</tr>

<tr>

<td width="55" valign="top"><strong>10</strong></td>

<td width="91" valign="top">1.932 us</td>

<td width="87" valign="top">4.746 us</td>

</tr>

</tbody>

</table>

<p>Now our good sweeping algorithm is slower than the naive !</p>
<p>When we think about that, we realize that it's logical. In fact we made a lot of computations before starting the algorithm like sorting the points, creating a list of candidantes, ... All that stuff is heavier than make n^2 comparisons in little number. So what can we do to have good performances with small number of points ?</p>
<p>It's really easy to solve. We just have to found the number before which the naive algorithm is quicker than the sweeping and when the size of the points collection is smaller than this pivot number we use the naive implementation. On my computer I found that before 75 elements, the naive implementation was faster than the sweeping algorithm, so we can refactor our method :</p>
<p>[java]public static Point[] closestPair(Point[] points) {
    if(points.length &lt; 75){
        return naiveClosestPair(points);
    }</p>
<div class="code"><pre><span class="c1">//No changes</span>
</pre></div>


<p>}[/java]</p>
<p>And we've good performances for little set of points :)</p>
<p>So our method is now complete. I hope you found that post interesting and that will be useful to someone.</p></div>
    </div>
    </div>
    
        <ul class="pager">
            <li class="previous">
                <a href="write-corrects-benchmarks.html" rel="prev">← Previous post</a>
            </li>
            <li class="next">
                <a href="ubuntu-lucid-lynx-10-04.html" rel="next">Next post →</a>
            </li>
        </ul>

        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://wichtounet.github.io/posts/2010/04/closest-pair-of-point-plane-sweep-algorithm.html",
        disqus_title="Find closest pair of point with Plane Sweep Algorithm in O(n ln n)",
        disqus_identifier="cache/posts/2010/04/closest-pair-of-point-plane-sweep-algorithm.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


    

    </article>

            </div>
        </div>
    </div>
</div>

<!-- Footer -->

<footer>
    Contents © 2014         <a href="mailto:baptistewicht@gmail.com">Baptiste Wicht</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/88x31.png"></a>
        <ul class="footer_inline_ul">
            
    <li>
    <a href="closest-pair-of-point-plane-sweep-algorithm.wp" id="sourcelink">Source</a>
    </li>

        </ul>
</footer>


            <script src="../../../assets/js/all-nocdn.js" type="text/javascript"></script>


    
<script type="text/javascript" src="https://apis.google.com/js/platform.js"></script>


    
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5327566b264df4ee"></script>
<script type="text/javascript">
  addthis.layers({
    'theme' : 'dark',
    'share' : {
      'position' : 'right',
      //'services' : 'google_plusone,facebook_like,tweet',
      'services' : 'google_plusone_share,facebook,twitter'
    }, 
    'follow' : {
      'services' : [
        {'service': 'twitter', 'id': 'wichtounet'},
        {'service': 'google_follow', 'id': '+BaptisteWicht'}
      ]
    }   
  });
</script>



<!-- Search -->

<!--
    <script type="text/javascript" src="/assets/js/tipuesearch_set.js"></script>
    <script type="text/javascript" src="/assets/js/tipuesearch.js"></script>
    <script type="text/javascript">
        $(document).ready(function() {
            $('#tipue_search_input').tipuesearch({
            'mode': 'json',
            'contentLocation': '/assets/js/tipuesearch_content.json',
            'showUrl': false
            });
            });
    </script>
-->

<script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>






</body>
</html>