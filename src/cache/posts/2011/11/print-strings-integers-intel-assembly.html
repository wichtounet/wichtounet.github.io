<p><html><body><p>In this post, we'll learn how to print strings and integers to the console on Linux using Intel Assembly. In this post, I'll use the AT&amp;T notation, because it's the notation used in EDDI. </p>
<p>In EDDI, I have to print strings and numbers to the console, as this is not an easy exercise, I wanted to share my experience here. </p>
<p>On Linux, the only way to print something on the console is to use a system call. For that, we have to use the 0x08 interrupt code. </p>
<p></p><h3>Declare strings</h3></p>
<p>First, we'll see how to declare strings in an Intel Assembly file. You can use the <strong>.string</strong> instruction to achieve that : </p>
<p>[assembly]StringToPrint:</p>
<p>.string "Hello"[/assembly]</p>
<h3>Print strings</h3>

<p>Then, to print, we will call the <em>sys_write</em> system call : </p>
<p>[assembly]movl $4, %eax</p>
<p>movl $1, %ebx</p>
<p>movl $StringToPrint, %ecx</p>
<p>movl $5, %edx</p>
<p>int $0x80[/assembly]</p>
<p>The value in <strong>%eax</strong> (4) indicates the system call we need (<em>sys_write</em>). The 1 in <strong>%ebx</strong> indicates that we want to write in the console. Finally the two last parameters indicates the string to print and the size of the string. In Intel assembly, the <strong>int</strong> instruction launch an interrupt and the 0x80 in the interrupt table is set to the system call in the Linux Kernel. </p>
<p>As you can see, this code does use 4 registers and does not save any of them. Ideally, you will save the registers before and restore them. It depends on when you use this routine. </p>
<h3>Print integers</h3>

<p>Writing an integer is a bit more complicated. If you have the integer in the string, there is no problem, but if you have only a long on your assembly, you'll have to convert the int into a string to print it. We will convert the integer char after char and use the stack as storage for our string. Then every char will be printed to the console using the same system as before. </p>
<p>So let's say we have our number in the <strong>%eax</strong> register : </p>
<p>[assembly]movl $9234, %eax[/assembly]</p>
<p>So let's take a look at the code : </p>
<p>[assembly]xorl %esi, %esi</p>
<p>loop:</p>
<p>movl $0, %edx</p>
<p>movl $10, %ebx</p>
<p>divl %ebx</p>
<p>addl $48, %edx</p>
<p>pushl %edx</p>
<p>incl %esi</p>
<p>cmpl $0, %eax</p>
<p>jz   next</p>
<p>jmp loop</p>
<p>next:</p>
<p>cmpl $0, %esi</p>
<p>jz   exit</p>
<p>decl %esi</p>
<p>movl $4, %eax</p>
<p>movl %esp, %ecx</p>
<p>movl $1, %ebx</p>
<p>movl $1, %edx</p>
<p>int  $0x80</p>
<p>addl $4, %esp</p>
<p>jmp  next</p>
<p>exit:[/assembly]</p>
<p>The first part of the code consists in dividing the value by 10 until we reach zero. The remainder of the division is pushed onto the stack. For example, for our number, after this part, we'll have 4-3-2-9 on the stack. The order is reversed, which is logic because we stack the remainders from the right. During this phase, we count the number of elements using the <strong>%esi</strong> register. </p>
<p>Once this is done, we print each characters one by one starting with the last that has been pushed. Here we decrement the counter for each char and we use the <strong>sys_write</strong> call with <strong>%esp</strong> as the address of the string of one character. After each character, we incremetn the <strong>%esp</strong> to cancel the push that we used. </p>
<p>We have to do this in two phases in order to get the characters in the good order and not in reverse order. </p>
<h3>Handle negative numbers</h3>

<p>As you may have noticed, we do not manage negative numbers in our code. They will be printed, but it will be positive number. Indeed, in Intel Assembly (and in processors in general), negative numbers are handled with two's complement. Handling negative numbers in our code is not a big deal. We can add this code at the beginning : </p>
<p>[assembly]cmpl $0, %eax</p>
<p>jge loop</p>
<p>neg %eax</p>
<p>pushl %eax</p>
<p>//Print "-" </p>
<p>popl %eax[/assembly]</p>
<p>First of all, we check if the number is smaller than 0, if it's not the case, we directly jump to the code we used before. If it's smaller, we negate the number and print a - before printing the real number. We have to save the <strong>%eax</strong> register before printing the - character because <strong>%eax</strong> is used for printing. </p>
<p>You'll now have a complete procedure to print an integer on the console in assembly. </p>
<p>I hope that this could be of some help for somebody. </body></html></p>