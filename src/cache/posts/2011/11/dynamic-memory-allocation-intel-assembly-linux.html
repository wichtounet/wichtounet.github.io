<p><html><body><p>For the version 0.6.0 of the EDDI Compiler, I have written a simple dynamic memory allocation function in assembly. I did that to avoid using malloc in my assembly code. As this is not an easy subject, this article will explain the main parts of writing this function.</p>
<p>As the EDDI Compiler creates program for Linux platform, this article will focus on writing a little memory allocator for Linux in Intel Assembly.</p>
<p>In this article I will follow the <em>AT&amp;T notation</em>.</p>
<p></p><h3>Specifications</h3></p>
<p>The function works like malloc but is simpler. The specifications are the following ones:</p>
<ul>
    <li>We call the function with one argument: the dynamic memory size we need</li>
    <li>The function returns the start address of the allocated memory in the <strong>%eax</strong> register</li>
    <li>There is no need to deallocate the allocated memory</li>
    <li>The size that we ask will generally small and always less than 16384 octets</li>
    <li>Having some gaps in the memory is not a problem for now</li>
</ul>

<p>So as you can see there are several limitations to this memory allocator. These limitations are the one I had for EDDI, so I'll follow them in this article.</p>
<h3>Dynamic memory allocation</h3>

<p>In Linux, there are two ways for performing dynamic memory allocation:</p>
<ul>
    <li><strong>brk</strong>: Increment the size of the data segment after the end of the program. This memory is directly after the program and is always contiguous. It's the easiest way for allocating memory. This technique is not perfect for large blocks of data.</li>
    <li><strong>mmap</strong>: Creates a new memory mapping in the virtual address space. The kernel gives you memory in virtually every place of the memory.</li>
</ul>

<p>In our case, as we need only small blocks, we will use <strong>brk</strong> to dynamically allocate memory.</p>
<p>We can call these procedures using system calls. In assembly, you can use system calls with interruptions (0x80).</p>
<h3>Implementation</h3>

<p>We need two variables for this function. One to keep track of the remaining size and another one to keep track of the current address of the allocated memory.</p>
<p>[assembly].data</p>
<p>.size VIeddi_remaining, 4</p>
<p>VIeddi_remaining:</p>
<p>.long 0</p>
<p>.size VIeddi_current, 4</p>
<p>VIeddi_current:</p>
<p>.long 0[/assembly]</p>
<p>Both variables are initialized to 0.</p>
<p>And here is the function I've developed :</p>
<p>[assembly]eddi_alloc:</p>
<p>pushl %ebp</p>
<p>movl %esp, %ebp</p>
<p>movl 8(%ebp), %ecx</p>
<p>movl VIeddi_remaining, %ebx</p>
<p>cmpl %ebx, %ecx</p>
<p>jle alloc_normal</p>
<p>movl $45, %eax</p>
<p>xorl %ebx, %ebx</p>
<p>int  $0x80</p>
<p>movl %eax, %esi</p>
<p>movl %eax, %ebx</p>
<p>addl $16384, %ebx</p>
<p>movl $45, %eax</p>
<p>int  $0x80</p>
<p>movl %esi, %eax</p>
<p>movl $16384, VIeddi_remaining</p>
<p>movl %esi, VIeddi_current</p>
<p>alloc_normal:</p>
<p>movl VIeddi_current, %eax</p>
<p>movl VIeddi_current, %ebx</p>
<p>addl %ecx, %ebx</p>
<p>movl %ebx, VIeddi_current</p>
<p>movl VIeddi_remaining, %ebx</p>
<p>subl %ecx, %ebx</p>
<p>movl %ebx, VIeddi_remaining</p>
<p>leave</p>
<p>ret[/assembly]</p>
<p>I will describe now each part of the alloc function.</p>
<p>[assembly]movl 8(%ebp), %ecx</p>
<p>movl VIeddi_remaining, %ebx</p>
<p>cmpl %ebx, %ecx</p>
<p>jle alloc_normal[/assembly]</p>
<p>In this part we test if there is enough remaining size for the dynamic memory allocation request. It's equivalent to <em>if(remaining &gt;= size)</em>. If there is enough size, we jump to the normal allocation part :</p>
<p>[assembly]alloc_normal:</p>
<p>movl VIeddi_current, %eax</p>
<p>movl VIeddi_current, %ebx</p>
<p>addl %ecx, %ebx</p>
<p>movl %ebx, VIeddi_current</p>
<p>movl VIeddi_remaining, %ebx</p>
<p>subl %ecx, %ebx</p>
<p>movl %ebx, VIeddi_remaining[/assembly]</p>
<p>First, we move the current address of memory into the <strong>%eax</strong> register for the return value. Then we add the size of the new allocated block to the current address. Finally we remove the size of the new allocated block from the remaining size. After that, we can leave the function.</p>
<p>The most interesting part is what we do when we have to allocate more memory :</p>
<p>[assembly]movl $45, %eax</p>
<p>xorl %ebx, %ebx</p>
<p>int  $0x80</p>
<p>movl %eax, %esi</p>
<p>movl %eax, %ebx</p>
<p>addl $16384, %ebx</p>
<p>movl $45, %eax</p>
<p>int  $0x80</p>
<p>movl $16384, VIeddi_remaining</p>
<p>movl %esi, VIeddi_current[/assembly]</p>
<p>We start by doing an interruption to execute a system call. The <strong>45</strong> in the <strong>%eax</strong> register indicates a <strong>sys_brk</strong> call. The 0 in the <strong>%ebx</strong> register, indicates that we want the current position of brk space. We save this current position into the <strong>%esi</strong> register. Then we add 16384 bits (4K octets) to this address. We call again the <strong>sys_brk</strong> routine to set the address of the brk space to the calculated address. This is the way to dynamically allocates 4K of memory. Finally, we add 4K to the remaining size in octets and we put the current address (before the add) as the current address.</p>
<h3>Possible improvements</h3>

<p>We should make some optimization if this function has to be invoked frequently. The first interruption (call to sys_brk) has only to be done once. The very first time we need to get the start address. Then, we can use the current address as the base address when we do the new allocation.</p>
<p>Another improvement is to avoid having gaps between the used blocks. For that, we can avoid setting the current address directly to the newly allocated address but just add 4K to the remaining size. The blocks will overlap 2 allocated blocks.</p>
<p>We could also check that the value returned by the <strong>sys_brk</strong> is valid. On error, the procedure can return -1.</p>
<h3>Conclusion</h3>

<p>In this post, we developed a basic dynamic memory allocation function in Intel assembly on the Linux platform. I hope that this information can helps some of you.</p>
<p>Don't hesitate if you have a question or a comment on my implementation.</body></html></p>