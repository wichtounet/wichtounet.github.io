<p><html><body><p>With <strong>Java 7</strong> (Dolphin), we'll have some <strong>concurrency </strong>and <strong>collections </strong>updates with the <strong>JSR166y</strong>, extension of the JSR166 of Doug Lea.</p>
<p>In this post, we'll see the most important news :</p>
<p></p><ul>
    <li>Fork/Join Framework</li>
    <li>TrasnferQueue&lt;E&gt;</li>
    <li>ThreadLocalRandom</li>
</ul></p>
<!--more-->

<h3>Fork/Join Framework</h3>

<p>The most important improvement is a new <strong>Fork/Join</strong> Framework. Fork/Join is basically the parralel version of the divide-and-conquer algorithm resolution. Here is the typical form of that problems (taken from Doug Lea) :</p>
<p>[java]Result solve(Problem problem) {
    if (problem is small)
        directly solve problem
    else {
        split problem into independent parts
        fork new subtasks to solve each part
        join all subtasks
        compose result from subresults
    }
}[/java]</p>
<p>Java 7 provide a new class <strong>ForkJoinPool </strong>to run <strong>ForkJoinTask</strong>. A ForkJoinTask is lighter than a thread. If you have a lot of ForkJoinTask, you can host them with a smallest number of threads. Two implementations of ForkJoinTask are provided :</p>
<ul>
    <li><strong>RecursiveAction </strong>: A recursive resultless ForkJoinTask</li>
    <li><strong>RecursiveTask</strong>&lt;E&gt; : A recursive ForkJoinTask that return an object of type E</li>
</ul>

<p>Of course, you can also directly use the ForkJoinTask class but the recursive actions are enough in almost all the cases.</p>
<p>From a ForkJoinTask you can invoke other task (fork them) using <em>invokeAll </em>methods.</p>
<p>So, now that we have covered the main concepts of this framework, we could start with a little example (directly taken from Javadoc <strong>build 87</strong>). We'll use divide and conquer to increment all the elements of an array. To know if the problem is small enough to solve it directly, we'll use a threshold representing the number of elements that we can increment directly. If we have more elements than the threshold, we will fork in two task otherwise, we'll compute directly the incrementation on the array. So here is our task :</p>
<p>[java]public class IncrementTask extends RecursiveAction {
   private final long[] array;
   private final int low;
   private final int high;</p>
<p>private static final int THRESHOLD = 5000;</p>
<p>public IncrementTask(long[] array, int low, int high) {
      super();</p>
<div class="code"><pre>  <span class="n">this</span><span class="p">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
  <span class="n">this</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
  <span class="n">this</span><span class="p">.</span><span class="n">high</span><span class="o">=</span> <span class="n">high</span><span class="p">;</span>
</pre></div>


<p>}</p>
<p>@Override
   protected void compute() {
      if (high - low &lt; THRESHOLD) {
           for (int i = low; i &lt; high; ++i){
              array[i]++;
           }
        } else {
           int mid = (low + high) &gt;&gt;&gt; 1;</p>
<div class="code"><pre>       <span class="n">invokeAll</span><span class="p">(</span><span class="n">new</span> <span class="n">IncrementTask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span> <span class="n">new</span> <span class="n">IncrementTask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>


<p>}
}[/java]</p>
<p>And you can launch that on an array using ForkJoinPool :</p>
<p>[java]RecursiveAction mainTask = new IncrementTask (anArray, 0, anArray.length);</p>
<p>ForkJoinPool mainPool = new ForkJoinPool();</p>
<p>mainPool.invoke(mainTask[/java]e&gt;</p>
<p>All the elements of the array will be incremented. Depending on the size of the array and of the threshold, the problem will be divided in several sub problems and all these task will be managed by the ForkJoinPool.</p>
<p>You can also make action that return something. By example, we can compute the sum of all the elements of an array :</p>
<p>[java]public class SumTask extends RecursiveTask {
   private final long[] array;
   private final int low;
   private final int high;</p>
<p>private static final int THRESHOLD = 5000;</p>
<p>public SumTask(long[] array, int low, int high) {
      super();</p>
<div class="code"><pre>  <span class="n">this</span><span class="p">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
  <span class="n">this</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
  <span class="n">this</span><span class="p">.</span><span class="n">high</span><span class="o">=</span> <span class="n">high</span><span class="p">;</span>
</pre></div>


<p>}</p>
<p>@Override
   protected Long compute() {
      if (high - low &lt; THRESHOLD) {
          long sum = 0;</p>
<div class="code"><pre>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">high</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
          <span class="n">sum</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
       <span class="p">}</span>

       <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span>

      <span class="n">RecursiveTask</span> <span class="n">left</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SumTask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
      <span class="n">RecursiveTask</span> <span class="n">right</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SumTask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

      <span class="n">right</span><span class="p">.</span><span class="n">fork</span><span class="p">();</span>

      <span class="k">return</span> <span class="n">left</span><span class="p">.</span><span class="n">compute</span><span class="p">()</span> <span class="o">+</span> <span class="n">right</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>


<p>}
}[/java]</p>
<p>And you can use it like that :</p>
<p>[java]RecursiveTask sumTask = new SumTask(anArray, 0, anArray.length);</p>
<p>ForkJoinPool mainPool = new ForkJoinPool();</p>
<p>Long sum = mainPool.invoke(sumTask);[/java]</p>
<p>I think it's a clean way to solve big problems with divide-and-conquer.</p>
<p>You can also imagine others ways to divide the problems. An example is to compute the <em>THRESOLD</em> left elements in the task and create a new task to compute the right elements. With that, we create less tasks, but it depends on the context and on the problems. In practive, you'll have  normally more complex problems but if you can find a way to divide the problems, you can use that new framework and have a very clean code.</p>
<h3>TransferQueue&lt;E&gt;</h3>

<p>A new interesting collection. This collection is a blocking queue especially made for producers/consumers. With that kind of queue, the producers can await for receipt of by the consumers with a new transfer(E) method or like normal queue without waiting for receipt with the <em>put</em>(E) method. It's also possible to make a transfer with timeout with the tryTransfer method. There is no change in the consumer part, you always use take() to get an element and waiting for an element. You've also access to the number of waiting consumer with the <em>getWaitingConsumerCount</em>().</p>
<p>The implementation to use is the <strong>LinkedTransferQueue&lt;E&gt;</strong> based on linked nodes. The elements are ordered with FIFO. Here are some methods you can use with that new collection :</p>
<p>[java]TransferQueue&lt;String&gt; transfer = new LinkedTransferQueue&lt;String&gt;();</p>
<p>transfer.transfer("Hello"); //Wait for a consumer</p>
<p>if(transfer.tryTransfer("World")){//Don't wait for a consumer
    //The element has been transfered to a consumer
} else {
    //There were no waiting consumer. The element has not been enqueued.
}</p>
<p>boolean transfered = transfer.tryTransfer("Goodbye", 5, TimeUnit.SECONDS);</p>
<p>while(transfer.hasWaitingConsumer()){
    //There is at least one consumer waiting for a transfer
}[/java]</p>
<p>It's also an interesting stuff. Useful by example in the case of message passing.</p>
<h3>ThreadLocalRandom</h3>

<p>A really simple but useful enhancement is the add of the <strong>ThreadLocalRandom</strong> class. This class is a random number generator linked to the current <strong>Thread</strong>. It seems that if you use this generator from two different thread, you will have two different random generators. The generator is initialized with a generated seed that you cannot modify (<em>setSeed()</em> throws an <em>UnsupportedOperationException</em>).</p>
<p>You can use that class like that :</p>
<p>[java]long l = ThreadLocalRandom.current().nextLong(22L);[/java]</p>
<p>If you always use this form, you have the guarantee that the random generator will never be shared between two threads. Moreover, this new class provide  methods to generate a bounded numbers. By example, to generate a pseudo-random number between 10, inclusive and 33, exclusive, you can type :</p>
<p>[java]int i = ThreadLocalRandom.current().nextInt(10, 33);[/java]</p>
<p>This is a little improvement but really useful, i think.</p>
<p>So here we are. I've covered the main features added on Java 7 for concurrency. I hope you find that stuff interesting and that discovering this features will help you to make concurrent programming in Java 7.</body></html></p>