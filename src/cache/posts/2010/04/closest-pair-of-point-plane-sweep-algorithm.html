<p><html><body><p>Finding the closest pair of Point in a given collection of points is a standard problem in computational geometry. In this article I'll explain an efficient algorithm using plane sweep, compare it to the naive implementation and discuss its complexity.</p>
<!--more-->

<p>This problem is standard, but not really easy to solve in an efficient way. The first implementation we think of is the naive one, comparing each point to each other point.</p>
<p>In my examples, I'll use the java.awt.Point class to represent a point. This naive implementation is really easy to implement :</p>
<p>[java]public static Point[] naiveClosestPair(Point[] points) {
    double min = Double.MAX_VALUE;</p>
<div class="code"><pre><span class="n">Point</span><span class="p">[]</span> <span class="n">closestPair</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Point</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>

                <span class="n">closestPair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
                <span class="n">closestPair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">closestPair</span><span class="p">;</span>
</pre></div>


<p>}[/java]</p>
<p>As you can directly see, this naive implementation has a complexity of O(n^2). But we can do a lot better using a plane sweep algorithm.</p>
<p>With that algorithm, we'll sweep the plane from left to right (right to left is also a possibility) and when we reach a point we'll compute all the interesting candidates (the candidates that can be in the closest pair).</p>
<p>For that we'll make the following operations :</p>
<p></p><ol>
    <li>We sort the list of points from left to right in the x axis</li>
    <li>And then for each point :
<ol>
    <li>We remove from the candidates all the point that are further in x axis that the current min distance</li>
    <li>We take all the candidates that are located more or less current min distance from the current point in y axis</li>
    <li>We test for the min distance all the founded candidates with the current point</li>
    <li>And finally we add the current point to the list of candidates</li>
</ol></p>
</li>

</ol>

<p>So when we found a new min distance, we can make the rectangle of candidates smaller in the x axis and smaller in the y axis. So we make a lot less comparisons between the points.</p>
<p>Here is a picture illustrating that :</p>
<p><a href="/wp-content/uploads/2010/04/Sweep.png"><img class="size-full wp-image-473" title="Plane Sweep Algorithm" src="/wp-content/uploads/2010/04/Sweep.png" alt="Plane Sweep Algorithm" width="500" height="436"></a></p>
<p>The red points are the closest pair at this time of the algorithm. The red rectangle is the rectangle of the candidates delimited in right by the current point. And the yellow rectangle contains only the candidates interesting for the current point.</p>
<p>There is always a maximum of 6 points in the yellow rectangle, the 4 vertices, the point with the same coordinates as the current point and finally the point in the same y coordinate and in the limit of the x axis. Even if the maximum is 6, you'll almost never have more than 2 points in that list (the maximum is see in my test was 3 with a collection of 1'000'000 random points). You can see this 6 points here :</p>
<p><a href="/wp-content/uploads/2010/04/Sweep-points.png"><img class="size-full wp-image-474" title="Maximum points to compare" src="/wp-content/uploads/2010/04/Sweep-points.png" alt="Maximum points to compare" width="132" height="232"></a></p>
<p>If all that stuff is not really clear for you, you can watch it in action here <a href="http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairApplet/ClosestPairApplet.html" target="_blank">in a Java applet</a>.</p>
<p>The candidates must also be always sorted. For that, we'll use a Binary Search Tree for good performances.</p>
<p>If we look at the complexity :</p>
<ul>
    <li>Sorting all the points in right axis : Cost O(n ln n) with Quick Sort by example</li>
    <li>Shrinking the list of candidates take O(n) from start to end of the algorithm because we add n points to the candidates and we can remove only n points. So this is constant for each point : O(1).</li>
    <li>Searching all the candidates between two values in y axis cost O(ln n) with binary search</li>
    <li>The comparisons with at maximum 6 points are made in O(1)</li>
    <li>Add the candidates and keep the list of candidates sorted cost O(ln n).</li>
</ul>

<p>So the total complexity is O(n ln(n) + n * ( 1 + ln(n) + 1 + ln(n) ) ) = O(n ln n).</p>
<p>So it's really better than O(n^2) for the naive implementation.</p>
<p>So now, we can go to the implementation in Java.</p>
<p>[java]public static Point[] closestPair(Point[] points) {
    Point[] closestPair = new Point[2];</p>
<div class="code"><pre><span class="c1">//When we start the min distance is the infinity</span>
<span class="n">double</span> <span class="n">crtMinDist</span> <span class="o">=</span> <span class="n">Double</span><span class="p">.</span><span class="no">POSITIVE_INFINITY</span><span class="p">;</span>

<span class="c1">//Get the points and sort them</span>
<span class="n">Point</span><span class="p">[]</span> <span class="n">sorted</span> <span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="n">copyOf</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="n">Arrays</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="no">HORIZONTAL_COMPARATOR</span><span class="p">);</span>

<span class="c1">//When we start the left most candidate is the first one</span>
<span class="k">int</span> <span class="n">leftMostCandidateIndex</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>

<span class="c1">//Vertically sorted set of candidates</span>
<span class="n">SortedSet</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Point</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Point</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;(</span><span class="no">VERTICAL_COMPARATOR</span><span class="p">);</span>

<span class="c1">//For each point from left to right</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">current</span> <span class="o">:</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//Shrink the candidates</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">sorted</span><span class="p">[</span><span class="n">leftMostCandidateIndex</span><span class="p">].</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">gt</span><span class="p">;</span> <span class="n">crtMinDist</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">candidates</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sorted</span><span class="p">[</span><span class="n">leftMostCandidateIndex</span><span class="p">]);</span>
        <span class="n">leftMostCandidateIndex</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//Compute the y head and the y tail of the candidates set</span>
    <span class="n">Point</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">crtMinDist</span><span class="p">));</span>
    <span class="n">Point</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="k">int</span><span class="p">)</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">crtMinDist</span><span class="p">));</span>

    <span class="c1">//We take only the interesting candidates in the y axis</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Point</span> <span class="n">point</span> <span class="o">:</span> <span class="n">candidates</span><span class="p">.</span><span class="n">subSet</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">double</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>

        <span class="c1">//Simple min computation</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">crtMinDist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">crtMinDist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>

            <span class="n">closestPair</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="n">closestPair</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//The current point is now a candidate</span>
    <span class="n">candidates</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">closestPair</span><span class="p">;</span>
</pre></div>


<p>}[/java]</p>
<p>The code isn't overcomplicated. We see all the steps explained in the article and that works well. The Horizontal and Vertical comparators are really simple : </p>
<p>[java]private static final Comparator&lt;Point&gt; VERTICAL_COMPARATOR = new Comparator&lt;Point&gt;() {
    @Override
    public int compare(Point a, Point b) {
        if (a.y &lt; b.y) {
            return -1;
        }
        if (a.y &gt; b.y) {
            return 1;
        }
        if (a.x &lt; b.x) {
            return -1;
        }
        if (a.x &gt; b.x) {
            return 1;
        }
        return 0;
    }
};</p>
<p>private static final Comparator&lt;Point&gt; HORIZONTAL_COMPARATOR = new Comparator&lt;Point&gt;() {
    @Override
    public int compare(Point a, Point b) {
        if (a.x &lt; b.x) {
            return -1;
        }
        if (a.x &gt; b.x) {
            return 1;
        }
        if (a.y &lt; b.y) {
            return -1;
        }
        if (a.y &gt; b.y) {
            return 1;
        }
        return 0;
    }
}[/java]</p>
<p>Here is a performance comparison for some sizes with <a href="http://www.baptiste-wicht.com/2010/04/write-corrects-benchmarks/" target="_blank">a Benchmark Framework I described here</a> for some sizes of collection points.</p>
<table border="1" cellspacing="0" cellpadding="0">

<tbody>

<tr>

<td width="55" valign="top"><strong> </strong></td>

<td width="91" valign="top"><strong>Naive</strong></td>

<td width="87" valign="top"><strong>Sweeping</strong></td>

</tr>

<tr>

<td width="55" valign="top"><strong>100</strong></td>

<td width="91" valign="top">189.923 us</td>

<td width="87" valign="top">53.685 us</td>

</tr>

<tr>

<td width="55" valign="top"><strong>500</strong></td>

<td width="91" valign="top">4.448 ms</td>

<td width="87" valign="top">279.042 us</td>

</tr>

<tr>

<td width="55" valign="top"><strong>1000</strong></td>

<td width="91" valign="top">17.790 ms</td>

<td width="87" valign="top">556.731 us</td>

</tr>

<tr>

<td width="55" valign="top"><strong>5000</strong></td>

<td width="91" valign="top">458.728 ms</td>

<td width="87" valign="top">3.320 ms</td>

</tr>

</tbody>

</table>

<p>Like you can see, this is really better than the naive implementation. So we make a good job. But if we make one more test with 10 elements :</p>
<table border="1" cellspacing="0" cellpadding="0">

<tbody>

<tr>

<td width="55" valign="top"><strong> </strong></td>

<td width="91" valign="top"><strong>Naive</strong></td>

<td width="87" valign="top"><strong>Sweeping</strong></td>

</tr>

<tr>

<td width="55" valign="top"><strong>10</strong></td>

<td width="91" valign="top">1.932 us</td>

<td width="87" valign="top">4.746 us</td>

</tr>

</tbody>

</table>

<p>Now our good sweeping algorithm is slower than the naive !</p>
<p>When we think about that, we realize that it's logical. In fact we made a lot of computations before starting the algorithm like sorting the points, creating a list of candidantes, ... All that stuff is heavier than make n^2 comparisons in little number. So what can we do to have good performances with small number of points ?</p>
<p>It's really easy to solve. We just have to found the number before which the naive algorithm is quicker than the sweeping and when the size of the points collection is smaller than this pivot number we use the naive implementation. On my computer I found that before 75 elements, the naive implementation was faster than the sweeping algorithm, so we can refactor our method :</p>
<p>[java]public static Point[] closestPair(Point[] points) {
    if(points.length &lt; 75){
        return naiveClosestPair(points);
    }</p>
<div class="code"><pre><span class="c1">//No changes</span>
</pre></div>


<p>}[/java]</p>
<p>And we've good performances for little set of points :)</p>
<p>So our method is now complete. I hope you found that post interesting and that will be useful to someone.</body></html></p>