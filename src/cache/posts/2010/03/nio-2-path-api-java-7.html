<p><html><body><p>In Java 7 we'll see a new API to manipulate file paths. This is part of the NIO.2 API.</p>
<p>Instead of using the class <strong>java.io.File</strong> to manipulate a file of the file system of the computer we will now use the <strong>java.nio.file.Path</strong> class to manipulate a file in any file system (<strong>FileSystem</strong>). This <strong>FileSystem </strong>can use any storage place (<strong>FileStorage</strong>). To support several implementations, this new API is based on factories. With that, you doesn't have to care about the real implementation.</p>
<!--more-->

<p>A little example to start : In Java &lt; 7, you do that :</p>
<p>[java]File file = new File("index.html");[/java]</p>
<p>and with Java 7, you can do that :</p>
<p>[java]Path path = Paths.get("index.html");[/java]</p>
<p>To make the migration easier, the File class has a new method toPath() that allows you to transform File to Path :</p>
<p>[java]Path path = new File("index.html").toPath();[/java]</p>
<p>But, it's only useful for migration purpose, we will not use that normally.</p>
<p>By default, all the Path will refers to files in the basic file system (the file system of the computer), but this new API is totally modular. We could imagine an implementation of FileSystem for data in memory, on the network or a virtual file system.</p>
<p>Like File, a Path can also refer to a not existing file. That's only file path, not the data containing in a file.</p>
<p>If we look at the methods of this new class, we can see that we have almost the same methods than the File class. But there is an important difference. The methods of the Path class throws Exception and that's a really good points. In fact, with the old File methods, we doesn't know anything if there is a problem. Sometimes we know that a problem occured with a simple boolean, but that's all.</p>
<p>Now we can have the cause of the Exception, that's far better. Here is a little example to delete a file using File :</p>
<p>[java]if (!file.delete()){
    //What happens ?
}[/java]</p>
<p>and now using Path :</p>
<p>[java]try {      
    path.delete();    
} catch (IOException e) {
    // We can know the cause and have a good reaction
}[/java]</p>
<p>An other enormous difference is the access to the attributes of the denoted file. In the old style, we have only access to the properties available in all the operating system. Now with views we can access the basic views, existing for all the operating systems and more specific views (DOS and POSIX) for properties available only in certain operating systems.</p>
<p>Here is a little example to get the basic attributes of a Path :</p>
<p>[java]BasicFileAttributeView basicView = path.getFileAttributeView(BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS); </p>
<p>//This attribute view is perhaps not available in this system</p>
<p>if (basicView != null) {
    BasicFileAttributes basic = basicView.readAttributes(); //Get the attributes of the view</p>
<div class="code"><pre><span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a regular file : &quot;</span> <span class="o">+</span> <span class="n">basic</span><span class="p">.</span><span class="n">isRegularFile</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a directory : &quot;</span> <span class="o">+</span> <span class="n">basic</span><span class="p">.</span><span class="n">isDirectory</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a symbolic link : &quot;</span> <span class="o">+</span> <span class="n">basic</span><span class="p">.</span><span class="n">isSymbolicLink</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a file with a size of : &quot;</span> <span class="o">+</span> <span class="n">basic</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a file last created at : &quot;</span> <span class="o">+</span> <span class="n">basic</span><span class="p">.</span><span class="n">creationTime</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a file last accessed at : &quot;</span> <span class="o">+</span> <span class="n">basic</span><span class="p">.</span><span class="n">lastAccessTime</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a file last modified at  : &quot;</span> <span class="o">+</span> <span class="n">basic</span><span class="p">.</span><span class="n">lastModifiedTime</span><span class="p">());</span>
</pre></div>


<p>}</p>
<p>[/java]</p>
<p>This methods can return null if the attribute is not supported. We can also do that for the DOS attributes :</p>
<p>[java]DosFileAttributeView dosView = path.getFileAttributeView(DosFileAttributeView.class); </p>
<p>//This attribute view is perhaps not available in this system</p>
<p>if (dosView != null) {
    DosFileAttributes dos = dosView.readAttributes(); //Get the attributes of the view</p>
<div class="code"><pre><span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a hidden file : &quot;</span> <span class="o">+</span> <span class="n">dos</span> <span class="p">.</span><span class="n">isHidden</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a read only file : &quot;</span> <span class="o">+</span> <span class="n">dos</span> <span class="p">.</span><span class="n">isReadOnly</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to a system file: &quot;</span> <span class="o">+</span> <span class="n">dos</span> <span class="p">.</span><span class="n">isSystem</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Path refers to an archive file : &quot;</span> <span class="o">+</span> <span class="n">dos</span> <span class="p">.</span><span class="n">isArchive</span><span class="p">());</span>
</pre></div>


<p>}</p>
<p>[/java]</p>
<p>You're really lucky if that works in Unix ;)</p>
<p>All the DOS and POSIX implementations extends the Basic view, so you can access all the basic attributes from an implementation view.</p>
<p>To make easier, there is also static methods in the Attributes class to access the attributes. By example :</p>
<p>[java]BasicFileAttributes basic = Attributes.readBasicFileAttributes(path);[/java]</p>
<p>In the other functionalities, we can note that this new API supports symbolic links (only if the system supports them, of course). Next, the Path class has also flows factories methods like newInputStream() or newByteChannel() to easily create streams to or from the Path. That's also an advantage because the system can choose the good stream implementations to open depending on the system specifications.</p>
<p>An other facility offered by Path, is stream on directories. It seems that you can iterate through a directory with an iterator. That's better than File.listFiles() because not all the File are loaded in memory and that's also a bit clearer in code :</p>
<p>[java]DirectoryStream directory = path.newDirectoryStream(); </p>
<p>try {
    for (Path p : directory) {
        System.out.println(p);
    }
} finally {
    directory.close();
}[/java]</p>
<p>And last, but not least, you can now watch for modifications in a directory with WatchService :</p>
<p>[java]WatchService watcher = path.getFileSystem().newWatchService(); </p>
<p>path.register(watcher,
      StandardWatchEventKind.ENTRY_CREATE,
      StandardWatchEventKind.ENTRY_MODIFY,
      StandardWatchEventKind.ENTRY_DELETE); </p>
<p>while (true) {
    WatchKey watchKey = watcher.take(); </p>
<div class="code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">WatchEvent</span> <span class="n">event</span> <span class="o">:</span> <span class="n">watchKey</span> <span class="p">.</span><span class="n">pollEvents</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot; : &quot;</span> <span class="o">+</span> <span class="n">event</span><span class="p">.</span><span class="n">context</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">watchKey</span> <span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</pre></div>


<p>}[/java]</p>
<p>That will use the services offered by the operating system (Notification, inotify, FSEvents). This is really easier than writing native code to do that, isn't it ?</p>
<p>Here we are. We've covered the main functionalities of the new Path API in Java 7.</p>
<p>I hope you find this article interesting and that helped you discovering the new features of Java 7.</p></body></html></p>