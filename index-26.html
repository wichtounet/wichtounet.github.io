<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang=en> <head><meta charset=utf-8><meta name=description content="Website about vtechnologies Java, Spring, OSGi, Hardware,..."><meta name=viewport content="width=device-width"><title>@Blog("Baptiste Wicht") (old posts, page 26) | @Blog("Baptiste Wicht")</title><link href=assets/css/all-nocdn.css rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title=RSS href=rss.xml><link rel=canonical href=http://baptiste-wicht.com/index-26.html><script type=text/javascript>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2175227-7']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script><link href=favicon.ico rel=icon type=image/x-icon></head><body><div class=social_container> <div class=social_container_gplus> <a target=_blank title="Share on Google+" href="https://plusone.google.com/_/+1/confirm?hl=en&amp;url=http://baptiste-wicht.com/index-26.html"><img src=assets/img/google_plus.png></a> </div> <div class=social_container_facebook> <a target=_blank title="Share on Facebook" href="http://www.facebook.com/sharer/sharer.php?u=#url"><img src=assets/img/facebook.png></a> </div> <div class=social_container_twitter> <a target=_blank title="Tweet on Twitter" href="http://twitter.com/home?status=#url"><img src=assets/img/twitter.svg></a> </div></div><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class=navbar-toggle data-toggle=collapse data-target=.navbar-ex1-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=http://baptiste-wicht.com/> <span id=blog-title>@Blog("Baptiste Wicht")</span> </a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href=stories/about.html>About</a> </li><li><a href=stories/publications.html>Publications</a> </li><li><a href=stories/donate.html>Donate</a> </li><li><a href=stories/contact.html>Contact</a> </li><li><a href=stories/faq.html>FAQ</a> </li><li><a href=stories/legal.html>Legal</a> </li><li><a href=categories/index.html>Tags</a> </li><li><a href=archive.html>Archives</a> </li><li><a href=http://feeds.feedburner.com/BaptisteWicht>RSS</a> </li></ul> <span class="navbar-form pull-left"> <form action=stories/search.html> <input type=text name=q id=tipue_search_input> </form> </span> <ul class="nav navbar-nav navbar-right"> <li> <a target=_blank title="Follow @wichtounet on Twitter" href=https://twitter.com/wichtounet> <img src=assets/img/twitter.svg alt="Follow @wichtounet on Twitter"> </a> </li> <li> <a target=_blank title="Follow +BaptisteWicht on Google+" href=https://plus.google.com/+BaptisteWicht> <img src=assets/img/google_plus.svg alt="Follow +BaptisteWicht on Google+"> </a> </li> </ul> </div> </div></nav><div class=body-container> <div class=left-sidebar> <div class=left-sidebar-widget> <h3>Welcome to my blog</h3> <div class=left-sidebar-widget-content> <div class=g-person data-width=275 data-href=//plus.google.com/u/0/103113673902796202116 data-theme=dark data-layout=landscape data-rel=author></div> </div> </div> <div class=left-sidebar-widget> <h3>Tags</h3> <div class=left-sidebar-widget-content> <div id=tags_container> <canvas width=275 height=250 id=tags_canvas> <p>Anything in here will be replaced on browsers that support the canvas element</p> </canvas> </div> </div> </div> <div class=left-sidebar-widget> <h3>Recent comments</h3> <div class=left-sidebar-widget-content> <div id=recentcomments class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=28&amp;excerpt_length=50"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Blogroll</h3> <div class=left-sidebar-widget-content> <ul> <li><a target=_blank href=http://www.asjava.com/>AsJava.com : Java Tutorial</a></li> <li><a target=_blank href=http://www.mkyong.com/>Mkyong : Java Tutorials</a></li> </ul> </div> </div> </div> <div class=container> <div class=body-content> <div class=row> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2014/07/compile-integer-square-roots-at-compile-time-in-cpp.html class=u-url>Compile integer Square Roots at compile-time in C++</a> <br><small>   Posted: <time class="published dt-published" datetime=2014-07-02T21:05:11+02:00>2014-07-02 21:05</time> </small></h1> <hr> <div class=p-summary> <p>For one of my projects, I needed to evaluate a square root at compile-time. There are several ways to implement it and some are better than the others.</p><p>In this post, I'll show several versions, both with Template Metaprogramming (TMP) and constexpr functions.</p><div class=section id=naive-version><h2>Naive version</h2><p>The easiest way to implement it is to enumerate the integers until we find two integers that when multiplied are equal to our number. This can easily be implemented in C++ with class template and partial specialization:</p><pre class="code c++ literal-block">
<span class=k>template</span> <span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>N</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>I</span><span class=o>=</span><span class=mi>1</span><span class=o>&gt;</span>
<span class=k>struct</span> <span class=n>ct_sqrt</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>integral_constant</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=p>,</span> <span class=p>(</span><span class=n>I</span><span class=o>*</span><span class=n>I</span><span class=o>&lt;</span><span class=n>N</span><span class=p>)</span> <span class=o>?</span> <span class=n>ct_sqrt</span><span class=o>&lt;</span><span class=n>N</span><span class=p>,</span><span class=n>I</span><span class=o>+</span><span class=mi>1</span><span class=o>&gt;::</span><span class=n>value</span> <span class=o>:</span> <span class=n>I</span><span class=o>&gt;</span> <span class=p>{};</span>

<span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>N</span><span class=o>&gt;</span>
<span class=k>struct</span> <span class=n>ct_sqrt</span><span class=o>&lt;</span><span class=n>N</span><span class=p>,</span><span class=n>N</span><span class=o>&gt;</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>integral_constant</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=p>,</span> <span class=n>N</span><span class=o>&gt;</span> <span class=p>{};</span>
</pre><p>Really easy, isn't it ? If we test it with 100, it gives 10. But, if we try with higher values, we are going to run into problem. For instance, when compiled with 289, here is what clang++ gives me:</p><pre class=literal-block>
src/sqrt/tmp.cpp:5:64: fatal error: recursive template instantiation exceeded maximum depth of 256
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 257&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 256&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 255&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 254&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 253&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: (skipping 247 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 5&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 4&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 3&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:5:64: note: in instantiation of template class 'ct_sqrt&lt;289, 2&gt;' requested here
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
src/sqrt/tmp.cpp:11:18: note: in instantiation of template class 'ct_sqrt&lt;289, 1&gt;' requested here
    std::cout &lt;&lt; ct_sqrt&lt;289&gt;::value &lt;&lt; std::endl;
                 ^
src/sqrt/tmp.cpp:5:64: note: use -ftemplate-depth=N to increase recursive template instantiation depth
struct ct_sqrt : std::integral_constant&lt;std::size_t, (I*I&lt;N) ? ct_sqrt&lt;N,I+1&gt;::value : I &gt; {};
                                                               ^
</pre><p>And it is only to compute the square root for 289, not a big number. We could of course increase the template depth limit (-ftemplate-depth=X), but that would only get us a bit farther. If you try with g++, you should see that this works, that is because g++ has a higher template depth limit (900 for 4.8.2 on my machine) where clang has a default limit of 256. It can be noted too that with g++ no context is skipped, therefore the error is quite long.</p><p>Now that C++11 gives us constexpr function, we can rewrite it more cleanly:</p><pre class="code c++ literal-block">
<span class=n>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>n</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>){</span>
    <span class=k>return</span> <span class=n>n</span> <span class=o>==</span> <span class=n>i</span> <span class=o>?</span> <span class=n>n</span> <span class=o>:</span> <span class=p>(</span><span class=n>i</span> <span class=o>*</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>?</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>:</span> <span class=n>i</span><span class=p>);</span>
<span class=p>}</span>
</pre><p>Much nicer :) And it works perfectly with 289. And it works quite well up to a large number. But it still fails once we git large numbers. For instance, here is what clang++ gives me with 302500 (550*550):</p><pre class=literal-block>
src/sqrt/constexpr.cpp:8:36: error: constexpr variable 'result' must be initialized by a constant expression
static constexpr const std::size_t result = ct_sqrt(SQRT_VALUE);
                                   ^        ~~~~~~~~~~~~~~~~~~~
src/sqrt/constexpr.cpp:5:38: note: constexpr evaluation exceeded maximum depth of 512 calls
    return n == i ? n : (i * i &lt; n ? ct_sqrt(n, i + 1) : i);
                                     ^
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 512)'
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 511)'
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 510)'
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 509)'
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 508)'
src/sqrt/constexpr.cpp:5:38: note: (skipping 502 calls in backtrace; use -fconstexpr-backtrace-limit=0 to see all)
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 5)'
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 4)'
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 3)'
src/sqrt/constexpr.cpp:5:38: note: in call to 'ct_sqrt(302500, 2)'
src/sqrt/constexpr.cpp:8:45: note: in call to 'ct_sqrt(302500, 1)'
static constexpr const std::size_t result = ct_sqrt(SQRT_VALUE);
                                            ^
</pre><p>Again, we run into the limits of the compiler. And again, the limit can be change with fconstexpr-backtrace-limit=X. With g++, the result is the same (without the skipped part, which makes the error horribly long), but the command to change the depth is -fconstexpr-depth=X.</p><p>So, if we need to compute higher square roots at compile-time, we need a better version.</p></div><div class=section id=binary-search-version><h2>Binary Search version</h2><p>To find the good square root, you don't need to iterate through all the numbers from 1 to N, you can perform a binary search to find the numbers to test. I found a very nice implementation by John Khvatov (<a class="reference external" href=http://jkhvatov.blogspot.ch/2009/11/c-compile-time-square-root-sqrt-using.html>source</a>).</p><p>Here is an adaptation of its code:</p><pre class="code c++ literal-block">
<span class=cp>#define MID(a, b) ((a+b)/2)
#define POW(a) (a*a)
</span>
<span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>res</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>r</span> <span class=o>=</span> <span class=n>res</span><span class=o>&gt;</span>
<span class=k>struct</span> <span class=n>ct_sqrt</span><span class=p>;</span>

<span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>res</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>r</span><span class=o>&gt;</span>
<span class=k>struct</span> <span class=n>ct_sqrt</span><span class=o>&lt;</span><span class=n>res</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>r</span><span class=o>&gt;</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>integral_constant</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=p>,</span> <span class=n>r</span><span class=o>&gt;</span> <span class=p>{};</span>

<span class=k>template</span> <span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>res</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>l</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>r</span><span class=o>&gt;</span>
<span class=k>struct</span> <span class=n>ct_sqrt</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>integral_constant</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span><span class=p>,</span> <span class=n>ct_sqrt</span><span class=o>&lt;</span><span class=n>res</span><span class=p>,</span>
        <span class=p>(</span><span class=n>POW</span><span class=p>(</span><span class=n>MID</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>))</span> <span class=o>&gt;=</span> <span class=n>res</span> <span class=o>?</span> <span class=n>l</span> <span class=o>:</span> <span class=n>MID</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span>
        <span class=p>(</span><span class=n>POW</span><span class=p>(</span><span class=n>MID</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>))</span> <span class=o>&gt;=</span> <span class=n>res</span> <span class=o>?</span> <span class=n>MID</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>)</span> <span class=o>:</span> <span class=n>r</span><span class=p>)</span><span class=o>&gt;::</span><span class=n>value</span><span class=o>&gt;</span> <span class=p>{};</span>
</pre><p>With smart binary search, you can reduce A LOT the numbers that needs to be tested in order to find the answer. It very easily found the answer for 302500. It can find the square root of almost all integers, until it fails due to overflows. I think it is really great :)</p><p>Of course, we can also do the constexpr version:</p><pre class="code c++ literal-block">
<span class=k>static</span> <span class=n>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>ct_mid</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>a</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>b</span><span class=p>){</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>ct_pow</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>a</span><span class=p>){</span>
    <span class=k>return</span> <span class=n>a</span><span class=o>*</span><span class=n>a</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>res</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>l</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>r</span><span class=p>){</span>
    <span class=k>return</span>
        <span class=n>l</span> <span class=o>==</span> <span class=n>r</span> <span class=o>?</span> <span class=n>r</span>
        <span class=o>:</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=n>ct_pow</span><span class=p>(</span>
            <span class=n>ct_mid</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>))</span> <span class=o>&gt;=</span> <span class=n>res</span> <span class=o>?</span> <span class=n>l</span> <span class=o>:</span> <span class=n>ct_mid</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span>
            <span class=n>ct_pow</span><span class=p>(</span><span class=n>ct_mid</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>))</span> <span class=o>&gt;=</span> <span class=n>res</span> <span class=o>?</span> <span class=n>ct_mid</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>l</span><span class=p>)</span> <span class=o>:</span> <span class=n>r</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>res</span><span class=p>){</span>
    <span class=k>return</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
<span class=p>}</span>
</pre><p>Which is a bit more understandable. It works the same way than the previous one and is only limited by numeric overflow.</p></div><div class=section id=c-14-fun><h2>C++14 Fun</h2><p>In C++14, the constraints on constexpr functions have been highly relaxed, we can now use variables, if/then/else statements, loops and so on... in constexpr functions making them much more readable. Here is the C++14 version of the previous code:</p><pre class="code c++ literal-block">
<span class=k>static</span> <span class=n>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>res</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>l</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>r</span><span class=p>){</span>
    <span class=k>if</span><span class=p>(</span><span class=n>l</span> <span class=o>==</span> <span class=n>r</span><span class=p>){</span>
        <span class=k>return</span> <span class=n>r</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>const</span> <span class=k>auto</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>r</span> <span class=o>+</span> <span class=n>l</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>

        <span class=k>if</span><span class=p>(</span><span class=n>mid</span> <span class=o>*</span> <span class=n>mid</span> <span class=o>&gt;=</span> <span class=n>res</span><span class=p>){</span>
            <span class=k>return</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>static</span> <span class=n>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>res</span><span class=p>){</span>
    <span class=k>return</span> <span class=n>ct_sqrt</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
<span class=p>}</span>
</pre><p>I think this version is highly superior than the previous version. Don't you think ?</p><p>It performs exactly the same as the previous. This can only be done in clang for now, but that will come eventually to gcc too.</p></div><div class=section id=conclusion><h2>Conclusion</h2><p>As you saw, there are several ways to compute a square root at compile-time in C++. The constexpr versions are much more readable and generally more scalable than the template metaprogramming version. Moreover, now, with C++14, we can write constexpr functions almost as standard function, which makes really great.</p><p>I hope that is is helpful to some of you :)</p><p>All the sources are available on Github: <a class="reference external" href=https://github.com/wichtounet/articles/tree/master/src/sqrt>https://github.com/wichtounet/articles/tree/master/src/sqrt</a></p></div> </div> <a href=posts/2014/07/compile-integer-square-roots-at-compile-time-in-cpp.html#disqus_thread data-disqus-identifier=cache/posts/2014/07/compile-integer-square-roots-at-compile-time-in-cpp.html>Comments</a> </article> <nav class=postindexpager> <ul class=pager> <li class=previous> <a href=index.html rel=prev>Newer posts</a> </li> <li class=next> <a href=index-25.html rel=next>Older posts</a> </li> </ul> </nav> <script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script> </div> </div> </div></div><footer> Contents © 2014 <a href=mailto:baptistewicht@gmail.com>Baptiste Wicht</a> - Powered by <a href=http://getnikola.com rel=nofollow>Nikola</a><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons License" style=padding-left:5px;border-width:0 src=assets/img/cc.png></a> <ul class=footer_inline_ul> </ul></footer> <script src=assets/js/all-nocdn.js></script> <script type=text/javascript>
      $(document).ready(function() {
        jQuery.getJSON('/assets/js/tag_cloud_data.json', function(data) {
            var items = [];

            $.each(data, function(key, val) {
                items.push('<li><a href="' + val[1] +'" '+'data-weight="'+val[0]+'"'+'>' + key + '</a></li>');
            });

            $('<div/>', {
                'id': 'tags',
                html: '<ul>' + items.join('') + '</ul>'
            }).appendTo('body');

            if(!$('#tags_canvas').tagcanvas({
                textColour: '#FFFFFF',
                outlineColour: '#ff00ff',
                reverse: true,
                depth: 0.8,
                maxSpeed: 0.05,
                weight: true,
                weightFrom: "data-weight",
                weightSizeMin: 8,
                weightSizeMax: 24
            },'tags')) {
                //something went wrong, hide the canvas container
                $('#tags_container').hide();
            }});
        });
    </script><script type=text/javascript src=https://apis.google.com/js/platform.js></script></body></html>