<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<base href="http://baptiste-wicht.com/index-19.html">
<meta name="description" content="Tutorials and short posts about programming, C++, Java, Assembly, Operating Systems Development, Compilers, ...">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>@Blog("Baptiste Wicht") (old posts, page 19) | @Blog("Baptiste Wicht")</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://baptiste-wicht.com/index-19.html">
<link rel="prev" href="index-20.html" type="text/html">
<link rel="next" href="index-18.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2175227-7']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script><link href="favicon.ico" rel="icon" type="image/x-icon">
</head>
<body>

<!-- Menubar -->

<div class="container-fluid">
<!-- This keeps the margins nice -->
    <div class="row">
        <div class="col-sm-3 col-lg-2">
            <nav class="navbar navbar-inverse navbar-fixed-side"><div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="http://baptiste-wicht.com/">
                        <span id="blog-title">@Blog("Baptiste Wicht")</span>
                    </a>
                </div>
<!-- /.navbar-header -->

                <div class="collapse navbar-collapse navbar-ex1-collapse">
                    <ul class="nav navbar-nav">
<li>
                            <div class="g-person" data-width="275" data-href="//plus.google.com/u/0/103113673902796202116" data-theme="dark" data-layout="landscape" data-rel="author"></div>
                        </li>

                        
                <li>
<a href="stories/about.html">About</a>
                </li>
<li>
<a href="stories/publications.html">Publications</a>
                </li>
<li>
<a href="categories/index.html">Tags</a>
                </li>
<li>
<a href="archive.html">Archives</a>
                </li>
<li>
<a href="http://feeds.feedburner.com/BaptisteWicht">RSS</a>


                            </li>
<li class="navbar-content">
                                <h3>Tags</h3>
                            </li>
                            <li class="navbar-empty">
                                <div id="tag_cloud_left_container" style="line-height: 18px !important;"></div>
                            </li>
                            <li class="navbar-block">


                        <li class="wicht-navbar-right">
                            <a target="_blank" title="Follow @wichtounet on Twitter" href="https://twitter.com/wichtounet">
                                <img src="assets/img/twitter.svg" alt="Follow @wichtounet on Twitter"></a>
                        </li>

                        <li class="wicht-navbar-right">
                            <a target="_blank" title="Follow +BaptisteWicht on Google+" href="https://plus.google.com/+BaptisteWicht">
                                <img src="assets/img/google_plus.svg" alt="Follow +BaptisteWicht on Google+"></a>
                        </li>


                    </ul>
</div>
<!-- /.navbar-collapse -->
            </nav>
</div> <!-- col -->
        <div class="col-sm-9 col-lg-10">
            
        <article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/06/the-site-now-running-wordpress-3-4.html" class="u-url">The site is now running WordPress 3.4</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-06-24T02:36:37+02:00">2012-06-24 02:36</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>I just updated the site to run WordPress 3.4</p>
<p>Normally, you should not see any differences as most of the new features of this version are in the admin side, but if you see something that doesn't work, don't hesitate to contact me.</p>
</div>
        </div>
            
        
    <a href="posts/2012/06/the-site-now-running-wordpress-3-4.html#disqus_thread" data-disqus-identifier="cache/posts/2012/06/the-site-now-running-wordpress-3-4.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/06/eddic-1-0-structures-global-optimizations.html" class="u-url">EDDI Compiler 1.0 - Structures and Global Optimizations</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-06-04T08:32:46+02:00">2012-06-04 08:32</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>I've the pleasure to announce the availability of <strong>version 1.0</strong> of the <strong>EDDI Compiler</strong> (eddic). </p>
<p>This release adds one big enhancement to the language: <strong>Structures</strong></p>
<p>Structures are used like in the C programming language: </p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">Complex</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">imag</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">real</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">Complex</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">imag</span> <span class="o">=</span> <span class="mi">222</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>

    <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
    <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">);</span>

    <span class="n">c</span><span class="p">.</span><span class="n">imag</span> <span class="o">+=</span> <span class="mi">111</span><span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">+=</span> <span class="mi">222</span><span class="p">;</span>

    <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
    <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">);</span>

    <span class="n">test</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">b</span><span class="p">){</span>
        <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
    <span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>For now on, you can declare structures, use local variables of the struct type and pass them as parameter. But the usage of structure is still limited, there are no way to return a structure from a function and no way to pass a structure by reference. Another limitation is that a member of struct cannot be of a struct type. At least, the last limitation will be addressed in the next version of eddic. </p>
<p>Another main change is the use of a new low-level Intermediate Representation (LTAC). This change is describe more in details in <a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/" title="Compiler Architecture refinements for eddic" target="_blank">this article</a>. </p>
<p>The main other change is the use of a data-flow framework for global optimization in the optimization engine. An optimization is global if it takes into account all the basic blocks of the function being optimized. For that, it takes a Control-Flow graph of the function and follow the logical flow of the function to determine what can be optimized. Two old optimization have been transformed from local to global: Constant Propagation and Copy Propagation. They have also been merged for being more efficient, so they are done both in one pass of the flow. I also implemented a new technique: Common Subexpression Elimination. This optimization make sure that no computation is made when the result is still available. The control flow graph is handled with the <em>Boost Graph Library</em>. </p>
<p>I also fixed a performance issue on the Optimization Engine. Before, the optimization were done for the whole program and if one optimization was successful, all the optimization techniques were tried again on the whole program. Now, there are made one function at a time and restarted only for this function. It should prove faster on problem with a lot of functions. </p>
<p>In the side of the assembly generation, I changed the way the floats constants are handled. Before, a general purpose register was used to load the constant and then load it in the SSE register. To avoid having to use a GP Register, I used a constant float pool and loaded the float directly from memory to the SSE Register. </p>
<p>On the compiler side, I added several new unit test and fixed the old tests. They were lots of bugs in the tests itself that made that they were not working at all. The test suite is now much more robust and showed me lots of other bugs. </p>
<p>I removed the dependency to <em>Boost Chrono</em> by relying on the new std::chrono library. </p>
<h4>Future work</h4>

<p>The next version will be the <strong>1.0.1 version</strong>. There will be several changes with this version. </p>
<p>I will improve the support of structures. I will add the support for struct inside structs and perhaps passing struct by reference (which would also means adding supports for references for other types as well). </p>
<p>I will also make more improvements to the optimization engine. I will add at least one new data-flow optimization and I will try to make the optimization pass faster. </p>
<p>Finally, as ever, I will certainly make some refactorings on some parts of the Compiler, but it starts looking good. </p>
<h4>Download</h4>

<p>You can find the compiler sources on the Github repository: <a title="eddic on GitHub" href="https://github.com/wichtounet/eddic">https://github.com/wichtounet/eddic</a></p>
<p>The exact version I refer to is the v1.0 available in the GitHub tags or directly as the release branch.</p>
</div>
        </div>
            
        
    <a href="posts/2012/06/eddic-1-0-structures-global-optimizations.html#disqus_thread" data-disqus-identifier="cache/posts/2012/06/eddic-1-0-structures-global-optimizations.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/05/advanced-compiler-design-and-implementation-book-review.html" class="u-url">Advanced Compiler Design and Implementation - Book Review</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-05-15T08:54:36+02:00">2012-05-15 08:54</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>After <a title="Compilers : Principles, Techniques &amp; Tools – Book Review" href="http://www.baptiste-wicht.com/2012/01/compilers-principles-techniques-tools/">having read my first book about compilers</a>, I decided to try another one more focused on optimizations. For that, I chose "<strong>Advanced Compiler Design and Implementation</strong>", by Steven S. Muchnick.</p>
<p>This book covers several subjects about compilers, but more than 60% of the text is about compiler optimizations.</p>
<p>The first chapter introduces the main concepts of compiler design. It also explains why optimization is so important in a compiler.</p>
<p>The algorithms of this book are presented in ICAN (Informal Compiler Algorithm Notation) notation. The chapter two provides both a brief and a full description of this notation. In my case, the brief description has been enough to understand the algorithms presented in the following chapters, but it can be useful for a deep understanding of the notation to read the full description.</p>
<p>The next chapter covers Symbol Table. It also includes a way to generate load and store instructions directly based on the information contained in the Symbol Table. Then, the fourth chapter presents the intermediate representations used in that book. This book uses three different intermediate languages: A high-level one, a medium-level one and a low-level. This chapter covers each of them in details. The importance of the design of an intermediate representation is also discussed here. There will be two more intermediate forms used in the book, static single-assignment (SSA) and program dependence graphs that are discussed later in the book.</p>
<p>The chapter five gives some information about the different runtime support of some architectures. It is very useful to know how to handle high-level languages at runtime. The next one is about producing code generators automatically from machine descriptions. Three approaches are covered in this chapter.</p>
<p>With the seventh chapter, the optimization techniques start. This chapter covers control-flow analysis. It will introduce several techniques that can be used to perform this kind of analysis, namely depth first search and dominators, interval analysis and structural analysis. These analysis can be used to identify structures like loops and branches in the intermediate representations. The chapter eight covers data-flow analysis. This chapter introduces a lot of mathematical concepts like lattices or flow functions. It takes some time to understand completely the concepts of this chapter, but the explanations are very good. Again, three methods of doing this analysis are studied. It covers iterative data-flow analysis, control-tree techniques and slotwise analysis. Another techniques are also introduced, but not covered in details. The chapter 9 covers dependence analysis. This analysis will be vital for optimizations on arrays and loops and to instruction scheduling techniques that will be studied later. Finally, the chapter ten introduces alias-analysis techniques.</p>
<p>Once the analysis techniques have been covered, the other chapters are about optimization themselves. The chapter 11 introduces optimizations. It explains which optimizations should be performed at which level and in which order. It also describes briefly the optimizations that are covered in the next chapters. You will see that the following chapters are very rich, each of them containing a lot of optimizations that can be performed.</p>
<p>The first optimizations that are covered (in chapter 12) are the so-called early optimizations. It includes scalar replacement of aggregates, value numbering, copy propagation and sparse conditional constant propagation. It also covers constant folding and algebraic simplifications. After that, the optimizations that reduce redundancy are covered. Again, several techniques are covered, common subexpression elimination, forward substitution, loop invariant code motion, partial redundancy elimination and code hoisting. Then, the loop optimizations are introduced. This chapter first introduces a way to identify induction variables in a loop and then covers some optimization that can be used. For example, strength reduction and unnecessary bounds checking optimizations are covered.</p>
<p>The next two chapters are more related to low-level problematic. The chapter 15 covers optimizations that can be applied to reduce the cost of procedures. It discusses tail-call optimization, procedure integration, in-line expansion, leaf-routine optimization and shrink wrapping. The, the chapter 16 covers a very important subject that is Register Allocation. It covers several techniques like cost based methods and global graph coloring.</p>
<p>The chapter 17 deals with code scheduling. It is a technique that reorder instructions to take best advantage of the pipelines built into ,modern processors. First, local approaches (within a basic block) are discussed and then optimization for scheduling across basic-block boundaries are covered. For the two subjects, several techniques are discussed. The chapter 18 covers low-level optimizations like unreachable-code elimination, loop inversion, dead-code elimination, etc... This chapter is very broad and very interesting too.</p>
<p>The chapter 19 covers more complex optimization: the inteprocedural optimizations. Several techniques for doing inteprocedural analysis are covered in details as well as several optimizations depending on these analysis, like constant propagation. This chapter is not very simple to understand and even less to apply, but it is very interesting. The chapter 20 is the last about optimizations. It covers techniques to improve the memory hierarchy usage. The first optimizations are about instruction-cache: instruction prefetching, procedure sorting and procedure splitting for example. Then, data-cache optimizations are covered. It includes data prefetching and scalar replacement of array elements in details and gives an outline for some other optimizations.</p>
<p>Finally, the chapter 21 studies four different compilers to see what optimizations are applied and in which order. Their intermediate forms are also studied. It is very interesting how this is done in real-world compiler.</p>
<p>To conclude, I think that this book is really great. It covers a lot of optimizations that can be implemented in a compiler. All the optimizations are covered in details with code samples and examples of applying the optimization on some code. However, it has to be said that this book is not easy to read and sometimes it is hard to understand exactly what means a specific optimization and in what it differs from some close technique. If you want to write an aggressive optimizer compiler or just write some optimizations for an existing one, you should consider to take a look at this book.</p>
<p>If you know another good book on Compilers, I will be glad to hear about it.</p>
</div>
        </div>
            
        
    <a href="posts/2012/05/advanced-compiler-design-and-implementation-book-review.html#disqus_thread" data-disqus-identifier="cache/posts/2012/05/advanced-compiler-design-and-implementation-book-review.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/05/compiler-architecture-refinements-eddic.html" class="u-url">Compiler Architecture refinements for eddic</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-05-07T09:34:30+02:00">2012-05-07 09:34</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>The next version of eddic will see an <strong>improved compiler architecture</strong>. There are two new main changes in this version:</p>
<ol>
<li>A better separation between the front end and the back end</li>
    <li>A new intermediate representation to improve and ease code generation</li>
</ol>
<h4>Front end and Back End</h4>

<p>First, the front and back ends have been clearly separated. The general compiler architecture is currently something like that:</p>
<p><a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/general-architecture/" rel="attachment wp-att-1973"><img class="aligncenter size-full wp-image-1973" title="EDDI Compiler General Architecture" src="wp-content/uploads/2012/05/general-architecture.svg" alt="EDDI Compiler General Architecture"></a></p>
<p>The first part didn't change, but the Compiler was part was clearly separated between front and back ends:</p>
<p><a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/compiler-architecture/" rel="attachment wp-att-1976"><img class="aligncenter size-full wp-image-1976" title="EDDI Compiler Architecture" src="wp-content/uploads/2012/05/compiler-architecture.svg" alt="EDDI Compiler Architecture"></a></p>
<p>The backend has no information about the source language. It only sees the intermediate representation provided by the front-end, named: Medium-Level Three Address Code (MTAC).</p>
<p>There are several advantages to this model. The main one is that it is easy to add support for a new programming language to the compiler. Only the front end needs to be changed. The same can be achieved if a new output is necessary, for example output ARM assembly instead of Intel assembly.</p>
<h4>New intermediate representation</h4>

<p>In the previous versions of the compiler, the code generators were fairly complex. Indeed, they had to transform the MTAC intermediate representation directly into assembly. This process involves several things:</p>
<ul>
<li>instruction selection</li>
    <li>register allocation</li>
    <li>low-level optimization (replace a  mov rax, 0 with xor rax, rax for example)</li>
    <li>handle basic blocks management</li>
</ul>
<p>In this version, I decided to change it to a better architecture. This architecture uses a new intermediate representation: Low-Level Three Address Code (LTAC). As its name states, it is a low-level representation, close to assembly. In this  representation there are addresses, registers and abstracted instructions. This representation is platform independent (the differences between 32 and 64 bits are moved to the code generators). There are no more basic blocks here, only functions containing statements.</p>
<p>The next figure presents the structure of the backend:</p>
<p><a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/backend-architecture/" rel="attachment wp-att-1977"><img class="aligncenter size-full wp-image-1977" title="EDDI Compiler Backend architecture" src="wp-content/uploads/2012/05/backend-architecture.svg" alt="EDDI Compiler Backend architecture"></a></p>
<p>The compiler is responsible for transforming the MTAC Representation in LTAC Representation. It does not do any low-level optimization. The instruction selection is easier as it is platform independent. The peephole optimizer is responsible for the low-levels optimizations. In the 1.0 release, there would be only few things done at this level. In the future, I will try to invest some time to complete it to generate better assembly code. The optimizations are far simpler than the one done in the MTAC optimization engine. Indeed, a peephole optimizer is generally working only in a small window of instructions, like three or four instructions at a time. And finally, the code generators performs the instruction selection process and address resolving. It also has to translate symbolic registers into physical ones.</p>
<h4>Conclusion</h4>

<p>I hope that these refinements in the compiler architecture will allow the compiler to produce better code.</p>
<p>The 1.0 version of the compiler will include another new features:</p>
<ul>
<li>Basic support for custom structures</li>
    <li>Global optimizations</li>
    <li>Some bug fixes found with the new set of unit tests</li>
</ul>
<p>As always, feel free to comment on the new architecture, the compiler itself, the project or whatever</p>
</div>
        </div>
            
        
    <a href="posts/2012/05/compiler-architecture-refinements-eddic.html#disqus_thread" data-disqus-identifier="cache/posts/2012/05/compiler-architecture-refinements-eddic.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/04/install-valgrind-on-gentoo-linux.html" class="u-url">Install Valgrind on Gentoo Linux</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-04-13T08:57:38+02:00">2012-04-13 08:57</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p><strong>Valgrind</strong> is very powerful suite of software for dynamic analysis of binary programs. Valgrind is available in an ebuild on the Gentoo portage tree, but if you want to install valgrind on your Gentoo distribution, there is a problem with the build with the standard library. On Gentoo, the standard C library (glibc) is stripped and Valgrind needs the debug symbols to work. If you try to launch valgrind without the debug symbols, you will get the following error: </p>
<pre>valgrind:  Fatal error at startup: a function redirection
valgrind:  which is mandatory for this platform-tool combination
valgrind:  cannot be set up.  Details of the redirection are:
valgrind:  
valgrind:  A must-be-redirected function
valgrind:  whose name matches the pattern:      strlen
valgrind:  in an object with soname matching:   ld-linux-x86-64.so.2
valgrind:  was not found whilst processing
valgrind:  symbols from the object with soname: ld-linux-x86-64.so.2
valgrind:  
valgrind:  Possible fixes: (1, short term): install glibc's debuginfo
valgrind:  package on this machine.  (2, longer term): ask the packagers
valgrind:  for your Linux distribution to please in future ship a non-
valgrind:  stripped ld.so (or whatever the dynamic linker .so is called)
valgrind:  that exports the above-named function using the standard
valgrind:  calling conventions for this platform.
valgrind:  
valgrind:  Cannot continue -- exiting now.  Sorry.</pre>

<p>So first, you have to activate the debug symbols for the libraries in your <em>/etc/make.conf</em>:</p>
<pre>FEATURES="splitdebug"</pre>

<p>Then, you can emerge again the glibc: </p>
<pre>sudo emerge glibc</pre>

<p>If you already had emerged valgrind, there is no need to emerge it again, it should work now. </p>
<p>And finally, you can emerge valgrind: </p>
<pre>sudo emerge valgrind</pre>

<p>And everything will work fine.</p>
</div>
        </div>
            
        
    <a href="posts/2012/04/install-valgrind-on-gentoo-linux.html#disqus_thread" data-disqus-identifier="cache/posts/2012/04/install-valgrind-on-gentoo-linux.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/04/switching-gentoo-linux.html" class="u-url">Switching to Gentoo Linux</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-04-10T09:28:37+02:00">2012-04-10 09:28</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>After having switched to Mint from Ubuntu, I'm on the verge of switching to <strong>Gentoo Linux</strong>.</p>
<p>Gentoo is a powerful operating system base on Linux. This operating system provides extreme configurability and performance. Gentoo is very lightweight on its own, by default, there is not even a window manager installed. A big advantage of this system is that you can customize your system to your exact needs. You can use it as a server, a desktop distribution or whatever you needs. You install only the program you needs. This advantage leads to an inconvenient: you will need an advanced knowledge on Linux to install your system. Indeed, you will have to configure your kernel, choose compilation flags, choose your packages carefully and know your hardware as well.</p>
<p>Gentoo is based on a very powerful software distribution system, <strong>Portage</strong>. Portage is used to install new packages, get the latest software for Gentoo or upgrade your system. Except for some proprietary software, all the packages are built from the sources. This allow to a deep customization of your software. The installation of some package can take a big amount of time to compile. Count at least several hours to install a system based on Gnome Shell for example.</p>
<p>If you plan to install a full installation of Gentoo, reserve some days for that. I've spent several days working on my installation before getting to something fully working.</p>
<p>Here is my current configuration:</p>
<ul>
<li>Gentoo operating system</li>
    <li>Linux Kernel 3.3</li>
    <li>Gnome Shell 3.2.1</li>
    <li>Google Chrome 18</li>
    <li>NVidia Drivers 295.33</li>
    <li>...</li>
</ul>
<p>As I've stripped my kernel and my init scripts to the maximum, my boot time is much faster and my installation takes much less space than my Mint installation.</p>
<p>I said that I'm on the verge of switching because I still have some applications that are not installed on my new Gentoo distribution. For example, I have no multimedia support for now, but I already spent most of my time on my new distribution.</p>
<p>I will try to write some posts on Gentoo in the future.</p>
</div>
        </div>
            
        
    <a href="posts/2012/04/switching-gentoo-linux.html#disqus_thread" data-disqus-identifier="cache/posts/2012/04/switching-gentoo-linux.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html" class="u-url">C++11 Concurrency Tutorial - Part 3: Advanced locking and condition variables</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-04-10T08:37:37+02:00">2012-04-10 08:37</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>In the previous article, we saw how to use mutexes to fix concurrency problems. In this post, we will continue to work on mutexes with more advanced techniques. We will also study another concurrency technique of the C++11 Concurrency Library: condition variables.</p>
<h4>Recursive locking</h4>

<p>Let's imagine that you have a simple class like this one:</p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">Complex</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">Complex</span><span class="p">()</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">mul</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">div</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">/=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>And you want to add an operation doing both operations with no problems, so you add a new function:</p>
<pre class="code literal-block"><span class="kt">void</span> <span class="nf">both</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">div</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>Now, it's time to test this function:</p>
<pre class="code literal-block"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Complex</span> <span class="n">complex</span><span class="p">;</span>
    <span class="n">complex</span><span class="p">.</span><span class="n">both</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>If you launch this application, you'll see that the program will never terminates. The problem is very simple. In the <em>both()</em> function, the thread acquires the lock and then calls the <em>mul()</em> function. In this function, the threads tries to acquire the lock again, but the lock is already locked. This is a case of deadlock. By default, a thread cannot acquire the same mutex twice.</p>
<p>There is a simple solution to this problem: <strong>std::recursive_mutex</strong>. This mutex can be acquired several times by the same thread. Here is the correct version of the Complex struct:</p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">Complex</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">Complex</span><span class="p">()</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">mul</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">div</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">/=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">both</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">div</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>This time, the application works correctly.</p>
<h4>Timed locking</h4>

<p>Sometimes, you doesn't want a thread to wait ad infinitum for a mutex. For example, if your thread can do something else when waiting for the thread. For this purpose, the standard library has a solution: <strong>std::timed_mutex</strong> and <strong>std::recursive_timed_mutex</strong> (if you need the recursivity properties of the mutex). You have access to the same functions as a <strong>std::mutex</strong>: <em>lock()</em> and <em>unlock()</em>, but you have also two new functions: <em>try_lock_for()</em> and <em>try_lock_until()</em>.</p>
<p>The first one is also the most useful. It allows you to set a timeout after when the function automatically returns even if the lock was not acquired. The function returns true if the lock has been acquired, false otherwise. Let's try it with a simple example:</p>
<pre class="code literal-block"><span class="n">std</span><span class="o">::</span><span class="n">timed_mutex</span> <span class="n">mutex</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">work</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">timeout</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mutex</span><span class="p">.</span><span class="n">try_lock_for</span><span class="p">(</span><span class="n">timeout</span><span class="p">)){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">": do work with the mutex"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">sleepDuration</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">sleepDuration</span><span class="p">);</span>

            <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">sleepDuration</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">": do work without mutex"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">sleepDuration</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">sleepDuration</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>(The example is completely useless in practice)</p>
<p>The first interesting thing in this example is the declaration of the duration with <strong>std::chrono::milliseconds</strong>. This is also a new feature of the C++11 standard. You have access to several time unit: nanoseconds, microseconds, milliseconds, seconds, minutes and hours. We use a variable of this kind to set the timeout of the try_lock_for function. We also use this to make a thread sleeps with <strong>std::this_thread::sleep_for(duration)</strong>. The rest of the example has nothing exciting in it, just some prints to see the results visually. Note that the program never stops, you have to kill it.</p>
<h4>Call once</h4>

<p>Sometimes you want a function to be called only once no matter the number of threads that are used. Imagine a function that has two parts. The first part has to be called only once and the second has to be executed every time the function gets called. We can use the std::call_once function to fix this problem very easily. Here is an example using this mechanism:</p>
<pre class="code literal-block"><span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">flag</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">do_something</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="p">[](){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Called once"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;});</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Called each time"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">do_something</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">do_something</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">do_something</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t4</span><span class="p">(</span><span class="n">do_something</span><span class="p">);</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Each <strong>std::call_once</strong> is matched to a <strong>std::once_flag</strong> variable. Here I put a closure to be executed only once, but a function pointer or a std::function will make the trick.</p>
<h4>Condition variables</h4>

<p>A condition variable manages a list of threads waiting until another thread notify them. Each thread that wants to wait on the condition variable has to acquire a lock first. The lock is then released when the thread starts to wait on the condition and the lock is acquired again when the thread is awakened.</p>
<p>A very good example is a concurrent Bounded Buffer. It’s a cyclic buffer with a certain capacity with a start and an end. Here is our implementation of a Bounded Buffer using condition variables:</p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">BoundedBuffer</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">front</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rear</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">not_full</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">not_empty</span><span class="p">;</span>

    <span class="n">BoundedBuffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="o">:</span> <span class="n">capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span> <span class="n">front</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rear</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">capacity</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">BoundedBuffer</span><span class="p">(){</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">deposit</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

        <span class="n">not_full</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">](){</span><span class="k">return</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">capacity</span><span class="p">;</span> <span class="p">});</span>

        <span class="n">buffer</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>

        <span class="n">not_empty</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">fetch</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

        <span class="n">not_empty</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">](){</span><span class="k">return</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
        <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="o">--</span><span class="n">count</span><span class="p">;</span>

        <span class="n">not_full</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>The mutexes are managed by a <strong>std::unique_lock</strong>. It is a wrapper to manage a lock. This is necessary to be used with the condition variables. To wake up a thread that is waiting on a condition variable, the <em>notify_one()</em> function is used. The wait function is a bit special. It takes as the first argument the unique lock and a the second one a predicate. The predicate must return false when the waiting must be continued (it is equivalent to while(!pred()){cv.wait(l);}). The rest of the example has nothing special.</p>
<p>We can use this structure to fix multiple consumers / multiple producers problem. This problem is very common in concurrent programming. Several threads (consumers) are waiting from data produced by another several threads (producers). Here is an example with several threads using the structure:</p>
<pre class="code literal-block"><span class="kt">void</span> <span class="nf">consumer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">BoundedBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">fetch</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Consumer "</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" fetched "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">250</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">producer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">BoundedBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">75</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">buffer</span><span class="p">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Produced "</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" produced "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">BoundedBuffer</span> <span class="n">buffer</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">c1</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">c2</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">c3</span><span class="p">(</span><span class="n">consumer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">p1</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">p2</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="n">c1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">c2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">c3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Three consumer threads and two producer threads are created and query the structure constantly. An interesting thing about this example is the use of std::ref to pass the buffer by reference, it is necessary to avoid a copy of the buffer.</p>
<h4>Wrap-Up</h4>

<p>In this article we saw several things. First, we saw how to use a recursive_mutex to allow a thread to acquire a thread more than once. Then, we saw how to acquire a mutex with a timeout. After that, a method to call a function only once has been studied. And finally, condition variables were used to solve the multiple consumers / multiple producers problem.</p>
<p>The source code for this article can be found on <a title="Source code of this article" href="https://github.com/wichtounet/articles/tree/master/src/threads/part3/">Github</a>.</p>
<h4>Next</h4>

<p>In the next post of this series, we will another technique of this new C++11 Concurrency Library, the Atomics.</p>
</div>
        </div>
            
        
    <a href="posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html#disqus_thread" data-disqus-identifier="cache/posts/2012/04/c11-concurrency-tutorial-advanced-locking-and-condition-variables.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/04/linux-kernel-tip-do-not-disable-system-v-ipc-for-x-org-and-chrome.html" class="u-url">Linux Kernel Tip : Do not disable System V IPC for X.Org and Chrome</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-04-07T09:02:01+02:00">2012-04-07 09:02</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>Yesterday I recompiled my Linux Kernel stripping it again and I found out that X.org was not working very anymore. Some windows were frozen and there was some troubles with the mouse. Another problem was that Google Chrome wouldn't display anything but blank pages. </p>
<p>The solution was easy: Do not disable the <strong>System V IPC</strong> option on the kernel.</p>
</div>
        </div>
            
        
    <a href="posts/2012/04/linux-kernel-tip-do-not-disable-system-v-ipc-for-x-org-and-chrome.html#disqus_thread" data-disqus-identifier="cache/posts/2012/04/linux-kernel-tip-do-not-disable-system-v-ipc-for-x-org-and-chrome.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/03/enhanced-code-snippets-syntaxhighlighter-evolved.html" class="u-url">Enhanced Code Snippets with SyntaxHighlighter Evolved</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-03-30T08:53:48+02:00">2012-03-30 08:53</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>After a long time of service, I decided to replace the old WP-Syntax plugin with a more modern one: <a href="http://wordpress.org/extend/plugins/syntaxhighlighter/" title="SyntaxHighlighter Evolved">SyntaxHighlighter Evolved</a>. </p>
<p>I thought that the style of the code snippets of WP-Syntax started looking a bit old. The new plugin has several advantages:</p>
<ul>
<li>The code snippets look better</li>
    <li>A useful toolbar is available on each snippet allowing you to copy the code, to print it or to view the source only</li>
    <li>The configuration is more complete</li>
</ul>
<p>This plugin use the <a href="http://alexgorbatchev.com/SyntaxHighlighter/" title="SyntaxHighlighter JavaScript package by Alex Gorbatchev">SyntaxHighlighter JavaScript package by Alex Gorbatchev</a>.</p>
<p>Here is an example using this new plugin: </p>
<pre class="code literal-block"><span class="n">ExecutorService</span> <span class="n">threadPool</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

<span class="n">CompletionService</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExecutorCompletionService</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">threadPool</span><span class="o">);</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
   <span class="n">pool</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">StringTask</span><span class="o">());</span>
<span class="o">}</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
   <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">take</span><span class="o">().</span><span class="na">get</span><span class="o">();</span>

   <span class="c1">//Compute the result</span>
<span class="o">}</span>

<span class="n">threadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</pre>


<p>For now, only two posts are using this new plugin:</p>
<ul>
<li><a href="http://www.baptiste-wicht.com/2012/03/cpp11-concurrency-part1-start-threads/" title="C++11 Concurrency – Part 1 : Start Threads">C++11 Concurrency – Part 1 : Start Threads</a></li>
    <li><a href="http://www.baptiste-wicht.com/2012/03/cp11-concurrency-tutorial-part-2-protect-shared-data/" title="C++11 Concurrency Tutorial – Part 2 : Protect shared data">C++11 Concurrency Tutorial – Part 2 : Protect shared data</a></li>
</ul>
<p>The other ones are still using the old plugin. I will convert the other posts when I will find some time. </p>
<p>I hope that this change will makes the site better for you.</p>
</div>
        </div>
            
        
    <a href="posts/2012/03/enhanced-code-snippets-syntaxhighlighter-evolved.html#disqus_thread" data-disqus-identifier="cache/posts/2012/03/enhanced-code-snippets-syntaxhighlighter-evolved.html">Comments</a>


        </article><article class="postbox h-entry post-text"><h1 class="p-name">
<a href="posts/2012/03/cp11-concurrency-tutorial-part-2-protect-shared-data.html" class="u-url">C++11 Concurrency Tutorial - Part 2 : Protect shared data</a>
        <br><small>  
             Posted: <time class="published dt-published" datetime="2012-03-26T09:04:28+02:00">2012-03-26 09:04</time></small>
</h1>
        <hr>
<div class="p-summary">
        <div>
<p>In the previous article, we saw how to start threads to execute some code in parallel. All the code executed in the threads were independant. In the general case, you often use shared objects between the threads. And when you do it, you will face another problem: synchronization. </p>
<p>We will see what is this problem in a simple code. </p>
<h4>Synchronization issues</h4>

<p>As an example, we will take a simple Counter structure. This structure has a value and methods to increment or decrement the value. Here is the structure:</p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">Counter</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

    <span class="n">Counter</span><span class="p">()</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>

    <span class="kt">void</span> <span class="n">increment</span><span class="p">(){</span>
        <span class="o">++</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>There is nothing new here. Now, let's start some threads and make some increments: </p>
<pre class="code literal-block"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Counter</span> <span class="n">counter</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">](){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
                <span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}));</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="kr">thread</span> <span class="o">:</span> <span class="n">threads</span><span class="p">){</span>
        <span class="kr">thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Again, nothing new there. We launch 5 threads and each one increment the counter hundred times. After all thread have finished their work, we print the value of the counter. </p>
<p>If we launch this program, we should expect that it will print 500. But this is not the case. No one can say what this program will print. Here are some results I obtained on my computer: </p>
<pre class="code literal-block">442
500
477
400
422
487
</pre>


<p>The problem is that the incrementation is not an atomic operation. As a matter of fact, an incrementation is made of three operations: </p>
<ul>
<li>Read the current value of <em>value</em>
</li>
    <li>Add one to the current value</li>
    <li>Write that new value to <em>value</em>
</li>
</ul>
<p>When you run that code using a single thread, there are no problems. It will execute each part of the  operation one after another. But when you have several threads, you can start having troubles. Imagine this situation:</p>
<ol>
<li>Thread 1 : read the value, get 0, add 1, so value = 1</li>
    <li>Thread 2 : read the value, get 0, add 1, so value = 1</li>
    <li>Thread 1 : write 1 to the field value and return 1</li>
    <li>Thread 2 : write 1 to the field value and return 1</li>
</ol>
<p>These situations come from what we call interleaving. Interleaving describe the possible situations of several threads executing some statements. Even for three operations and two threads, there is a lot of possible interleavings. When you have more threads and more operations, it is almost impossible to enumerate the possibles interleavings. The problem can also occurs when a thread gets preempted between instructions of the operation. </p>
<p>There are several solutions to fix this problem: </p>
<ul>
<li>Semaphores</li>
    <li>Atomic references</li>
    <li>Monitors</li>
    <li>Condition codes</li>
    <li>Compare and swap</li>
    <li>etc.</li>
</ul>
<p>In this blog post we will learn how to use semaphores to fix this problem. As a matter of fact, we will a special kind of semaphores called mutexes. A mutex is a very simple object. Only one thread can obtain the lock on a mutex at the same time. This simple (and powerful) property of a mutex allow us to use it to fix synchronization problems. </p>
<h4>Use a mutex to make our Counter thread-safe</h4>

<p>In the C++11 threading library, the mutexes are in the mutex header and the class representing a mutex is the std::mutex class. There are two important methods on a mutex: lock() and unlock(). As their names indicate, the first one enable a thread to obtain the lock and the second releases the lock. The lock() method is blocking. The thread will only return from the lock() method when the lock has been obtained. </p>
<p>To make our Counter struct thread-safe, we have to add a std::mutex member to it and then to lock()/unlock() the mutex in every function of the object: </p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">Counter</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

    <span class="n">Counter</span><span class="p">()</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">increment</span><span class="p">(){</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="o">++</span><span class="n">value</span><span class="p">;</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>If we now test this implementation with the same code as before for starting the threads, the program will always display 500. </p>
<h4>Exceptions and locks</h4>

<p>Now, let's see what happens in another case. Imagine that the Counter has a decrement operation that throws an exception if the value is 0: </p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">Counter</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

    <span class="n">Counter</span><span class="p">()</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">increment</span><span class="p">(){</span>
        <span class="o">++</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">decrement</span><span class="p">(){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">throw</span> <span class="s">"Value cannot be less than 0"</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">--</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>You want to access this structure concurrently without modifying the class. So you create a wrapper with locks for this class: </p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">ConcurrentCounter</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="n">Counter</span> <span class="n">counter</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">increment</span><span class="p">(){</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">decrement</span><span class="p">(){</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">decrement</span><span class="p">();</span>        
        <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>This wrapper works well in most of the cases, but when an exception occurs in the decrement method, you have a big problem. Indeed, if an exception occurs, the unlock() function is not called and so the lock is left in a blocked state. Then, you program is completely blocked. To fix this problem, you have to use a try/catch structure to unlock the lock before throwing again the exception:</p>
<pre class="code literal-block"><span class="kt">void</span> <span class="nf">decrement</span><span class="p">(){</span>
    <span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">decrement</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">e</span><span class="p">){</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="k">throw</span> <span class="n">e</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</pre>


<p>The code is not difficult but starts looking ugly. Now imagine you are in a function with 10 different exit points. You will have to call unlock() from each of these points and the probability that you will forget one is big. Even bigger is the risk that you won't add a call to unlock when you add a new exit point to a function. </p>
<p>The next section gives a very nice solution to this problem.</p>
<h4>Automatic management of locks</h4>

<p>When you want to protect a whole block of code (a function in our case, but can be inside a loop or another control structure), it exists a good solution to avoid forgetting to release the lock: std::lock_guard. </p>
<p>This class is a simple smart manager for a lock. When the std::lock_guard is created, it automatically calls lock() on the mutex. When the guard gets destructed, it also releases the lock. You can use it like this: </p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">ConcurrentSafeCounter</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="n">Counter</span> <span class="n">counter</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">increment</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">decrement</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">decrement</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre>


<p>Much nicer, isn't it :)</p>
<p>With that solution, you do not have to handle all the cases of exit of the function, they are all handled by the destructor of the std::lock_guard instance. </p>
<h4>Conclusion</h4>

<p>We are now done with semaphores. In this article, you learned how to protect shared data using mutexes from the C++ Threads Library. </p>
<p>Keep in mind that locks are slow. Indeed, when you use locks you make sections of the code sequential. If you want an highly parallel application, there are other solutions than locks that are performing much better but this is out of the scope of this article. </p>
<h4>Next</h4>

<p>In the next blog post of this serie, I will talk about advanced concepts for mutexes and how to use condition variables to fix little concurrent programming problem. </p>
<p>The source code for each sample is available <a title="Source code for this blog post" href="https://github.com/wichtounet/articles/tree/master/src/threads/part2/">on Github</a>.</p>
</div>
        </div>
            
        
    <a href="posts/2012/03/cp11-concurrency-tutorial-part-2-protect-shared-data.html#disqus_thread" data-disqus-identifier="cache/posts/2012/03/cp11-concurrency-tutorial-part-2-protect-shared-data.html">Comments</a>


        </article><nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-20.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-18.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div> <!-- col -->
    </div>
<!-- row  -->
</div>
<!-- container-fluid -->

<!-- End of Menubar -->

<!-- Footer -->

<footer>
    Contents © 2016         <a href="mailto:baptistewicht@gmail.com">Baptiste Wicht</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="padding-left:5px;border-width:0" src="assets/img/cc.png"></a>
        <ul class="footer_inline_ul"></ul></footer><!-- Late loading stuff  --><script src="assets/js/all-nocdn.js"></script><script type="text/javascript">
      $(document).ready(function() {
        $.getJSON("/assets/js/tx3_tag_cloud.json", function(data){
            var items = [];
            $.each(data, function(key, val){
                var count = val[0];
                var url = val[1];
                var posts = val[2];

                if(count > 9){
                    items.push("<li data-weight='" + count + "'><a href='" + url + "'>" + key + "</a></li>");
                }
            });

            $("<ul/>", {
                "id": "tag_cloud_left",
                html: items.join("")
            }).appendTo("#tag_cloud_left_container");

            $("#tag_cloud_left").tx3TagCloud({
                multiplier: 0.6 // default multiplier is "1"
            });
        });
      });
    </script><!-- Google platform JS --><script type="text/javascript" src="https://apis.google.com/js/platform.js"></script>
</body>
</html>
