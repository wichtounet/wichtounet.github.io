<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang=en> <head><meta charset=utf-8><meta name=description content="Website about vtechnologies Java, Spring, OSGi, Hardware,..."><meta name=viewport content="width=device-width"><title>@Blog("Baptiste Wicht") (old posts, page 11) | @Blog("Baptiste Wicht")</title><link href=assets/css/all-nocdn.css rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title=RSS href=rss.xml><link rel=canonical href=http://baptiste-wicht.com/index-11.html><script type=text/javascript>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2175227-7']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script><link href=favicon.ico rel=icon type=image/x-icon></head><body><div class=social_container> <div class=social_container_gplus> <a target=_blank title="Share on Google+" href="https://plusone.google.com/_/+1/confirm?hl=en&amp;url=http://baptiste-wicht.com/index-11.html"><img src=assets/img/google_plus.png></a> </div> <div class=social_container_facebook> <a target=_blank title="Share on Facebook" href="http://www.facebook.com/sharer/sharer.php?u=#url"><img src=assets/img/facebook.png></a> </div> <div class=social_container_twitter> <a target=_blank title="Tweet on Twitter" href="http://twitter.com/home?status=#url"><img src=assets/img/twitter.svg></a> </div></div><nav class="navbar navbar-inverse navbar-fixed-top" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class=navbar-toggle data-toggle=collapse data-target=.navbar-ex1-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=http://baptiste-wicht.com/> <span id=blog-title>@Blog("Baptiste Wicht")</span> </a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href=stories/about.html>About</a> </li><li><a href=stories/publications.html>Publications</a> </li><li><a href=stories/donate.html>Donate</a> </li><li><a href=stories/contact.html>Contact</a> </li><li><a href=stories/faq.html>FAQ</a> </li><li><a href=stories/legal.html>Legal</a> </li><li><a href=categories/index.html>Tags</a> </li><li><a href=archive.html>Archives</a> </li><li><a href=http://feeds.feedburner.com/BaptisteWicht>RSS</a> </li></ul> <span class="navbar-form pull-left"> <form action=stories/search.html> <input type=text name=q id=tipue_search_input> </form> </span> <ul class="nav navbar-nav navbar-right"> <li> <a target=_blank title="Follow @wichtounet on Twitter" href=https://twitter.com/wichtounet> <img src=assets/img/twitter.svg alt="Follow @wichtounet on Twitter"> </a> </li> <li> <a target=_blank title="Follow +BaptisteWicht on Google+" href=https://plus.google.com/+BaptisteWicht> <img src=assets/img/google_plus.svg alt="Follow +BaptisteWicht on Google+"> </a> </li> </ul> </div> </div></nav><div class=body-container> <div class=left-sidebar> <div class=left-sidebar-widget> <h3>Welcome to my blog</h3> <div class=left-sidebar-widget-content> <div class=g-person data-width=275 data-href=//plus.google.com/u/0/103113673902796202116 data-theme=dark data-layout=landscape data-rel=author></div> </div> </div> <div class=left-sidebar-widget> <h3>Tags</h3> <div class=left-sidebar-widget-content> <div id=tags_container> <canvas width=275 height=250 id=tags_canvas> <p>Anything in here will be replaced on browsers that support the canvas element</p> </canvas> </div> </div> </div> <div class=left-sidebar-widget> <h3>Recent comments</h3> <div class=left-sidebar-widget-content> <div id=recentcomments class=dsq-widget> <script type=text/javascript src="http://blogwichtounet.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=0&amp;avatar_size=28&amp;excerpt_length=50"></script> </div> </div> </div> <div class=left-sidebar-widget> <h3>Blogroll</h3> <div class=left-sidebar-widget-content> <ul> <li><a target=_blank href=http://www.asjava.com/>AsJava.com : Java Tutorial</a></li> <li><a target=_blank href=http://www.mkyong.com/>Mkyong : Java Tutorials</a></li> </ul> </div> </div> </div> <div class=container> <div class=body-content> <div class=row> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/09/tip-batch-resize-images-on-ubuntu-linux.html class=u-url>Tip : Batch resize images on Ubuntu Linux</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-09-08T07:26:01+02:00>2010-09-08 07:26</time> </small></h1> <hr> <div class=p-summary> <p>After needing to <a href=http://www.baptiste-wicht.com/2010/07/tip-optimize-images-on-ubuntu-linux/ target=_blank>optimize a lot of images at once</a>, this weekend I needed to resize a lot of images to the same size because they were too big.</p><p>Like every other thing in Linux, there is a really simple tool to automate that. I used imagemagick to do that. Of course, there is certainly a lot of other things to make that work, but this is the first I've found and it works well.</p><p>So first, you need to install it if you don't have the tool :</p><pre>sudo apt-get install imagemagick</pre><p>And then, you can resize all the JPG images to a width of 640px of the current folder using the single command :</p><pre>mogrify -resize 640 *.jpg</pre><p>If you want the height, just add a x :</p><pre>mogrify -resize x640 *.jpg</pre><p>You can also specify maximum width and height, that can be useful if you have big images and you don't want a width larger than x and a height larger than y but you don't want to resize little images in the same folder. Here is an example resizing images if the width is larger than 1280 or height larger than 1024 :</p><pre>mogrify -resize '1280x1024&gt;' *.jpg</pre><p>With all that commands, the ratio is preserved. If you want more informations on the possible resize options, you can consult the <a href=http://www.imagemagick.org/www/command-line-processing.html#geometry target=_blank>documentation of ImageMagick</a>.</p><p>Hope that will help someone.</p> </div> <a href=posts/2010/09/tip-batch-resize-images-on-ubuntu-linux.html#disqus_thread data-disqus-identifier=cache/posts/2010/09/tip-batch-resize-images-on-ubuntu-linux.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/09/java-concurrency-atomic-variables.html class=u-url>Java Concurrency - Part 6 : Atomic Variables</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-09-08T07:14:18+02:00>2010-09-08 07:14</time> </small></h1> <hr> <div class=p-summary> <p>When a data (typically a variable) can be accessed by several threads, you must synchronize the access to the data to ensure visibility and correctness. </p><p>By example, if you have a simple counter (yes, once again) : </p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Counter</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getPreviousValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>--;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>This class works really well in single-threaded environment, but don't work at all when several threads access the same Counter instance. If you don't know why, read <a target=_blank href=http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/>this post about synchronization</a>. You can solve the problem using synchronized at method level : </p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SynchronizedCounter</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>int</span> <span class=nf>getValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>int</span> <span class=nf>getPreviousValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>--;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>This class now works well. But locking is not a lightweight mechanism and have several disadvantages. When several threads try to acquire the same lock, one or more threads will be suspended and they will be resumed later. When the critical section is little, the overhead is really heavy especially when the lock is often acquired and there is a lot of contention. Another disadvantage is that the other threads waiting of the lock cannot do something else during waiting and if the thread who has the lock is delayed (due to a page fault or the end of the time quanta by example), the others threads cannot take their turn. </p><p>So how to do to avoid this disadvantages ? We must use non-blocking algorithms. This algorithms don't use blocking mechanisms and by that fact are more scalable and performing. These algorithms use low-level machine instructions which are atomic to ensure the atomicity of higher-level operations. While locking is a pessimistic approach, we can also use optimistic technique to develop algorithms. This time, we'll detect collisions between threads in which case, the operation fails and we do something else (often retrying the same operation).</p><p>The actual processors provide several instructions that simplify greatly the implementation of these non-blocking algorithms, the most-used operation today is the compare-and-swap operation (CAS). This operation takes three parameters, the memory address, the expected current value and the new value. It atomically update the value at the given memory address if the current value is the expected, otherwise it do nothing. In both cases, the operation return the value at the address after the operation execution. So when several threads try to execute the CAS operation, one thread wins and the others do nothing. So the caller can choose to retry or to do something else. We often use this operation to implement another operation, the compare-and-set. This method makes exactly the same things as CAS but return a boolean indicating if the operation succeeded or not. </p><p>Before Java 5.0, this operation was not available directly to developer, but in Java 5.0 several atomic variables (for int, long, boolean and reference values) were added. The int and long versions also supports numeric operations. The JVM compiles these classes with the better operations provided by the hardware machine, CAS or a Java implementation of the operation using a lock. Here are the classes : </p><ul><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li></ul><p>All these classes supports compare-and-set (via the compareAndSet() method) and other operations (get(), set() and getAndSet()). The setters operations are implemented using compareAndSet. These classes supports multi-threaded access and have a better scalability than synchronizing all the operations. </p><p>Here is how we can rewrite our counter using an AtomicInteger : </p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AtomicCounter</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>AtomicInteger</span> <span class=n>value</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicInteger</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>.</span><span class=na>incrementAndGet</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getPreviousValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>.</span><span class=na>decrementAndGet</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>The incrementAndGet() and decrementAndGet() methods are two of the numeric operations provided by the AtomicLong and AtomicInteger classes. You also have getAndDecrement(), getAndIncrement(), getAndAdd(int i) and addAndGet(). </p><p>This version is faster than the synchronized one and is also thread safe. </p><p>If you only have the compareAndSet(), here is how we can implement increment() method using it : </p><pre class="code literal-block"><span class=kd>public</span> <span class=kt>void</span> <span class=nf>increment</span><span class=o>(</span><span class=n>AtomicInteger</span> <span class=n>integer</span><span class=o>){</span>
    <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
        <span class=kt>int</span> <span class=n>current</span> <span class=o>=</span> <span class=n>integer</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
        <span class=kt>int</span> <span class=n>next</span> <span class=o>=</span> <span class=n>current</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>

        <span class=k>if</span><span class=o>(</span><span class=n>integer</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>current</span><span class=o>,</span> <span class=n>next</span><span class=o>)){</span>
            <span class=k>return</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>This seems to be complicated, but this is the cost of non-blocking algorithms. When we detect collision, we retry until the operation succeeded. This is the common schema for non-blocking algorithms. </p><p>Here is a thread-safe Stack implemented using AtomicReference : </p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Stack</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>AtomicReference</span><span class=o>&lt;</span><span class=n>Element</span><span class=o>&gt;</span> <span class=n>head</span> <span class=o>=</span> <span class=k>new</span> <span class=n>AtomicReference</span><span class=o>&lt;</span><span class=n>Element</span><span class=o>&gt;(</span><span class=kc>null</span><span class=o>);</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=n>String</span> <span class=n>value</span><span class=o>){</span>
        <span class=n>Element</span> <span class=n>newElement</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Element</span><span class=o>(</span><span class=n>value</span><span class=o>);</span>

        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
            <span class=n>Element</span> <span class=n>oldHead</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
            <span class=n>newElement</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>oldHead</span><span class=o>;</span>

            <span class=c1>//Trying to set the new element as the head</span>
            <span class=k>if</span><span class=o>(</span><span class=n>head</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>oldHead</span><span class=o>,</span> <span class=n>newElement</span><span class=o>)){</span>
                <span class=k>return</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>String</span> <span class=nf>pop</span><span class=o>(){</span>
        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
            <span class=n>Element</span> <span class=n>oldHead</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>

            <span class=c1>//The stack is empty</span>
            <span class=k>if</span><span class=o>(</span><span class=n>oldHead</span> <span class=o>==</span> <span class=kc>null</span><span class=o>){</span>
                <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
            <span class=o>}</span>

            <span class=n>Element</span> <span class=n>newHead</span> <span class=o>=</span> <span class=n>oldHead</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>

            <span class=c1>//Trying to set the new element as the head</span>
            <span class=k>if</span><span class=o>(</span><span class=n>head</span><span class=o>.</span><span class=na>compareAndSet</span><span class=o>(</span><span class=n>oldHead</span><span class=o>,</span> <span class=n>newHead</span><span class=o>)){</span>
                <span class=k>return</span> <span class=n>oldHead</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>Element</span> <span class=o>{</span>
        <span class=kd>private</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>value</span><span class=o>;</span>
        <span class=kd>private</span> <span class=n>Element</span> <span class=n>next</span><span class=o>;</span>

        <span class=kd>private</span> <span class=nf>Element</span><span class=o>(</span><span class=n>String</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>this</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>It's really more complicated than using synchronized on the two methods but also more performing if there is contention (and often even if there is no contention). </p><p>So this ends this post. To conclude, atomic variables classes are a really good way to implement non-blocking algorithms and moreover are also a very good alternative to volatile variables, because they can provide atomicity and visibility.</p> </div> <a href=posts/2010/09/java-concurrency-atomic-variables.html#disqus_thread data-disqus-identifier=cache/posts/2010/09/java-concurrency-atomic-variables.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html class=u-url>Java Concurrency - Part 5 : Monitors (Locks and Conditions)</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-09-06T07:13:27+02:00>2010-09-06 07:13</time> </small></h1> <hr> <div class=p-summary> <p>After seeing <a title="Java Concurrency – Part 4 : Semaphores" href=http://www.baptiste-wicht.com/2010/08/java-concurrency-part-4-semaphores/ target=_blank>how to synchronize code using semaphores</a>, we'll see how to do that using <strong>monitors</strong>.</p><p>Monitors are an other mechanism of concurrent programming. It's a higher level mechanism than semaphores and also more powerful. A monitor is an instance of a class that can be used safely by several threads. All the methods of a monitor are executed with mutual exclusion. So at most one thread can execute a method of the monitor at the same time. This mutual exclusion policy makes easier to work with monitor and to develop the method content of the monitor.</p><p>Monitors have an other feature, the possibility to make a thread waiting for a condition. During the wait time, the thread temporarily gives up its exclusive access and must reacquire it after the condition has been met. You can also signal one or more threads that a condition has been met.</p><p>There is several advantages on using monitors instead of a lower-level mechanisms :</p><ul> <li>All the synchronization code is centralized in one location and the users of this code don’t need to know how it’s implemented.</li> <li>The code doesn't depend on the number of processes, it works for as many processes as you want</li> <li>You don’t need to release something like a mutex, so you cannot forget to do it</li></ul><p>When we must describe a monitor, we simple use the <strong>monitor</strong> keyword and describe the methods as common methods :</p><pre class="code literal-block"><span class=n>monitor</span> <span class=n>SimpleMonitor</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=n>method</span> <span class=kt>void</span> <span class=nf>testA</span><span class=o>(){</span>
        <span class=c1>//Some code</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>method</span> <span class=kt>int</span> <span class=nf>testB</span><span class=o>(){</span>
        <span class=k>return</span> <span class=mi>1</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>To describe a condition variable, we use the <strong>cond</strong> keyword. A condition variable is a kind of queue of process who are waiting on the same condition. You have several operations available on a condition, the most important is to signal a process waiting to be awaken and to wait on a condition. There are some similarities between signal/wait operations and P and V of semaphores, but this is a little different. The signal operation does nothing if the queue is empty and the wait operation put always the thread in the waiting queue. The process queue is served in a first come, first served mode. When a thread wakes up after waiting on a condition, it must reacquire the lock before continuing in the code.</p><p>Before going further, we must have more information about the signal operations. When writing monitors, you normally have the choice between several philosophies for the signaling operation :</p><ol> <li>Signal &amp; Continue (SC) : The process who signal keep the mutual exclusion and the signaled will be awaken but need to acquire the mutual exclusion before going.</li> <li>Signal &amp; Wait (SW) : The signaler is blocked and must wait for mutual exclusion to continue and the signaled thread is directly awaken and can start continue its operations.</li> <li>Signal &amp; Urgent Wait (SU) : Like SW but the signaler thread has the guarantee than it would go just after the signaled thread</li> <li>Signal &amp; Exit (SX) : The signaler exits from the method directly after the signal and the signaled thread can start directly. This philosophy is not often used.</li></ol><p>The available policies depends on the programming language, in Java, there is only one policy available, the SC one.</p><p>In Java there is no keyword to directly create a monitor. To implement a monitor, you must create a new class and use <strong>Lock</strong> and <strong>Condition</strong> classes. Lock is the interface is <strong>ReentrantLock</strong> is the main used implementation, this is the one that we'll learn to use in the current post. To create a ReentrantLock, you have two constructors, a default constructor and a constructor with a boolean argument indicating if the lock is fair or not. A fair lock indicates that the threads will acquire the locks in the order they ask for. Fairness is a little heavier than default locking strategies, so use it only if you need it. To acquire the lock, you just have to use the method <em>lock</em> and <em>unlock</em> to release it.</p><p>The explicit locks have the same memory semantics than the synchronized blocks. So the visibility of the changes is guarantee when you use lock()/unlock() blocks.</p><p>So to implement, the monitor example we've seen before, we just need to create a class and use the lock to make the mutual exclusion :</p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SimpleMonitor</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Lock</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ReentrantLock</span><span class=o>();</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>testA</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>

        <span class=k>try</span> <span class=o>{</span>
            <span class=c1>//Some code</span>
        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
            <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>testB</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>

        <span class=k>try</span> <span class=o>{</span>
            <span class=k>return</span> <span class=mi>1</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
            <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>The person who've already read the other parts of this post set will say that it will be easier to use the synchronized keyword on the two methods. But with synchronized, we will not have the condition variables. If you don't need condition variables but only locking, it will be easier to use the synchronized blocks instead of Locks.</p><p>You can create conditions using the <em>newCondition</em> method on the lock. A condition is a variable of type <strong>Condition</strong>. You can make the current thread wait on the condition using the <em>await</em> method (and its variant with timeout) and you can signal threads using <em>signal</em> and <em>signalAll</em> methods. The signalAll methods wakes up all the threads waiting on the condition variable.</p><p>Let's try with a simple common example : A bounded buffer. It's a cyclic buffer with a certain capacity with a start and an end.</p><pre class="code literal-block"><span class=kn>import</span> <span class=nn>java.util.concurrent.locks.Condition</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.concurrent.locks.Lock</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.concurrent.locks.ReentrantLock</span><span class=o>;</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>BoundedBuffer</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>String</span><span class=o>[]</span> <span class=n>buffer</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>capacity</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kt>int</span> <span class=n>front</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>rear</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>count</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Lock</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ReentrantLock</span><span class=o>();</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Condition</span> <span class=n>notFull</span> <span class=o>=</span> <span class=n>lock</span><span class=o>.</span><span class=na>newCondition</span><span class=o>();</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Condition</span> <span class=n>notEmpty</span> <span class=o>=</span> <span class=n>lock</span><span class=o>.</span><span class=na>newCondition</span><span class=o>();</span>

    <span class=kd>public</span> <span class=nf>BoundedBuffer</span><span class=o>(</span><span class=kt>int</span> <span class=n>capacity</span><span class=o>)</span> <span class=o>{</span>
        <span class=kd>super</span><span class=o>();</span>

        <span class=k>this</span><span class=o>.</span><span class=na>capacity</span> <span class=o>=</span> <span class=n>capacity</span><span class=o>;</span>

        <span class=n>buffer</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>[</span><span class=n>capacity</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>deposit</span><span class=o>(</span><span class=n>String</span> <span class=n>data</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
        <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>

        <span class=k>try</span> <span class=o>{</span>
            <span class=k>while</span> <span class=o>(</span><span class=n>count</span> <span class=o>==</span> <span class=n>capacity</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>notFull</span><span class=o>.</span><span class=na>await</span><span class=o>();</span>
            <span class=o>}</span>

            <span class=n>buffer</span><span class=o>[</span><span class=n>rear</span><span class=o>]</span> <span class=o>=</span> <span class=n>data</span><span class=o>;</span>
            <span class=n>rear</span> <span class=o>=</span> <span class=o>(</span><span class=n>rear</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>capacity</span><span class=o>;</span>
            <span class=n>count</span><span class=o>++;</span>

            <span class=n>notEmpty</span><span class=o>.</span><span class=na>signal</span><span class=o>();</span>
        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
            <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>String</span> <span class=nf>fetch</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
        <span class=n>lock</span><span class=o>.</span><span class=na>lock</span><span class=o>();</span>

        <span class=k>try</span> <span class=o>{</span>
            <span class=k>while</span> <span class=o>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>notEmpty</span><span class=o>.</span><span class=na>await</span><span class=o>();</span>
            <span class=o>}</span>

            <span class=n>String</span> <span class=n>result</span> <span class=o>=</span> <span class=n>buffer</span><span class=o>[</span><span class=n>front</span><span class=o>];</span>
            <span class=n>front</span> <span class=o>=</span> <span class=o>(</span><span class=n>front</span> <span class=o>+</span> <span class=mi>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>capacity</span><span class=o>;</span>
            <span class=n>count</span><span class=o>--;</span>

            <span class=n>notFull</span><span class=o>.</span><span class=na>signal</span><span class=o>();</span>

            <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
            <span class=n>lock</span><span class=o>.</span><span class=na>unlock</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>So some explications :</p><ol> <li>The two methods are protected with the lock to ensure mutual exclusion</li> <li>Then we use two conditions variables. One to wait for the buffer to be not empty and an other one to wait for the buffer to be not full.</li> <li>You can see that I have wrapped the await operation on a while loop. This is to avoid signal stealers problem that can occurs when using Signal &amp; Continue</li></ol><p>And that BoundedBuffer can be easily used with several threads with no problems.</p><p>As you can see, you can use monitors to solve a lot of concurrent programming problems and this mechanism is really powerful and performing.</p><p>I hope you found that article interesting and that this set of posts about Java concurrency brings you some stuff about Java.</p> </div> <a href=posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html#disqus_thread data-disqus-identifier=cache/posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/09/save-time-with-the-gmail-priority-inbox.html class=u-url>Save time with the Gmail Priority Inbox</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-09-04T05:44:27+02:00>2010-09-04 05:44</time> </small></h1> <hr> <div class=p-summary> <p>Some days ago, Gmail released a new feature, the <strong>Priority Inbox</strong>. Actually, the feature is not released on all accounts, but if it is released on yours, you can see a message "Try Gmail Priority Inbox", in top right high corner, just after your user name.</p><p>Once you activated this new inbox, you will see two inbox, the new Priority Inbox on top and the old Inbox. The Inbox has not changed, but now you can use the Priority Inbox. In this view, you will see your messages sorted in two categories, the first one contains the important unread messages and the second one contains all the other messages.</p><p>If you found an error, namely a non-important message tagged as important or the contrary, you have two new buttons :</p><p><a href=wp-content/uploads/2010/09/Gmail-Buttons.png><img class="size-full wp-image-1018" title="GMail Priority Buttons" src=wp-content/uploads/2010/09/Gmail-Buttons.png alt="GMail Priority Buttons" width=77 height=32></a></p><p>With these buttons, you can move a message from the priority messages to the others and vice versa. When you do that, the algorithm between the sorting will save your action and try to improve the efficiency of the Priority Inbox to not make the same error again.</p><p>At this time, I'm completely happy with this new feature, I've had only one message marked as important that was not, but it's all. I think it's a great tool that Google has offerred to us.</p><p>If you want more informations, let's watch this video from Google :</p><p><object width=640 height=385><param name=movie value="http://www.youtube.com/v/5nt3gE9dGHQ?fs=1&amp;amp"><param name=allowFullScreen value=true><param name=allowscriptaccess value=always><embed src="http://www.youtube.com/v/5nt3gE9dGHQ?fs=1&amp;amp" type=application/x-shockwave-flash allowscriptaccess=always allowfullscreen=true width=640 height=385></object></p> </div> <a href=posts/2010/09/save-time-with-the-gmail-priority-inbox.html#disqus_thread data-disqus-identifier=cache/posts/2010/09/save-time-with-the-gmail-priority-inbox.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/09/my-java-benchmarks-on-github.html class=u-url>My Java Benchmarks on GitHub</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-09-03T07:16:20+02:00>2010-09-03 07:16</time> </small></h1> <hr> <div class=p-summary> <p>I've created a new github repository for my <strong>Java Benchmarks</strong> : <a title="java-benchmarks github repository" href=http://github.com/wichtounet/java-benchmarks target=_blank>java-benchmarks</a></p><p>From now all my benchmarks will be pushed to this repository. This is more simple for me to manage and more secure also.</p><p>At this time, there is seven benchmarks on the repository :</p><ol> <li>Closest Pair Search Benchmark : A benchmark to test two closest pair point search algorithms : the naive one and the <strong>sweeping plane</strong> one. <a title="Closest Pair Search Benchmark Results" href=http://www.baptiste-wicht.com/2010/04/closest-pair-of-point-plane-sweep-algorithm/ target=_blank>Results</a>.</li> <li>File Copy Benchmark : A benchmark on the different ways to make <strong>file copy</strong> in Java. <a title="Java File Copy Benchmark Results" href=http://www.baptiste-wicht.com/2010/08/file-copy-in-java-benchmark/ target=_blank>Results</a>.</li> <li>Iteration Remove Benchmark : A simple benchmark to test if it's interesting to remove the read elements from a list when we make several iterations over the list.</li> <li>Reflection Benchmark : A little benchmark to test the performances of <strong>reflection</strong> versus switch cases and direct invocations.</li> <li>Short Indexes Loop Benchmark : A benchmark to test which <strong>primitive type</strong> is the most performing using as iteration index. <a title="Short Indexes Loop Benchmark Results" href=http://www.baptiste-wicht.com/2010/01/dont-use-shorts-in-loop/ target=_blank>Results</a>.</li> <li>Synchronization Benchmark : A benchmark to test the performances of the different <strong>synchronization mechanisms</strong> available in Java to provide mutual exclusion. <a title="Synchronization Benchmark Results" href=http://www.baptiste-wicht.com/2010/09/java-synchronization-mutual-exclusion-benchmark/ target=_blank>Results</a>.</li> <li>Unmodifiable Benchmark : A benchmark to test the performances of <strong>unmodifiable collection</strong> versus creating a copy of the list.</li></ol><p>I hope you'll find these sources interesting. If you found errors or improvements, don't hesitate to comment to tell me what.</p> </div> <a href=posts/2010/09/my-java-benchmarks-on-github.html#disqus_thread data-disqus-identifier=cache/posts/2010/09/my-java-benchmarks-on-github.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html class=u-url>Java Synchronization (Mutual Exclusion) Benchmark</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-09-01T07:13:18+02:00>2010-09-01 07:13</time> </small></h1> <hr> <div class=p-summary> <p>I've created another benchmark. This time, I've benchmarked the different ways of synchronizing a little code using <strong>mutual exclusion</strong> on this code.</p><p>The code to protect will be very simple. It's a simple counter :</p><pre class="code literal-block"><span class=c1>//Init</span>
<span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> 
<span class=c1>//Critical section</span>
<span class=n>counter</span><span class=o>++;</span>
</pre><p>The critical section, if not protected with synchronization system, will not function properly due to possible <strong>interleavings</strong> (read <a href=http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/ target=_blank>the article on synchronization</a> if you don't know what is <strong>interleaving</strong>).</p><p class=more><a href=posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html>Read more…</a></p> </div> <a href=posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html#disqus_thread data-disqus-identifier=cache/posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/08/java-concurrency-part-4-semaphores.html class=u-url>Java Concurrency - Part 4 : Semaphores</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-08-30T07:11:55+02:00>2010-08-30 07:11</time> </small></h1> <hr> <div class=p-summary> <p>We continue in Java Concurrency with the semaphores. Semaphores is also a way to synchronize threads.</p><p>Semaphores are a really simple concept, invented by the famous Dutch computer scientist Edsger Dijkstra. Basically a semaphore is a counter (integer) that allows a thread to get into a critical region if the value of the counter is greater than 0. If it's the case, the counter is decremented by one otherwise, the thread is waiting until it can go. And when the thread go away from the critical region, the counter is incremented by one to allow one more thread to pass the critical region. A semaphore is created with a certain value for its counter. So, you can execute two actions on a semaphore P and V.</p><p>By example, if you have a critical that cannot be executed concurrently, you can use a semaphore :</p><pre class="code literal-block"><span class=n>sem</span> <span class=n>mutex</span> <span class=o>=</span> <span class=k>new</span> <span class=n>sem</span><span class=o>(</span><span class=mi>1</span><span class=o>)</span>
<span class=n>P</span><span class=o>(</span><span class=n>mutex</span><span class=o>)</span>
<span class=c1>//Critical region</span>
<span class=n>V</span><span class=o>(</span><span class=n>mutex</span><span class=o>)</span>
</pre><p>So you must always call by yourself the P operation before the critical region and V after it. We call a mutex (mutual exclusion) a semaphore with a value of one. So only one thread can enter the region guarded by the semaphore. This is the most used semaphore. The other use of semaphore is to guard a set of resources like database connections or a data pool.</p><p>In Java, a semaphore is created using the java.util.concurrent.Semaphore class. You can create easily :</p><pre class="code literal-block"><span class=n>Semaphore</span> <span class=n>mutex</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Semaphore</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
<span class=n>Semaphore</span> <span class=n>available</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Semaphore</span><span class=o>(</span><span class=mi>100</span><span class=o>);</span>
</pre><p>The P and V operations are represented using the acquire and release methods. The method acquire can be interrupted if the thread is interrupted. There is an uninterruptible version with the method acquireUninterruptibly(). There is also a third version with the tryAcquire method. This method acquire a permit only if there is one permit available, otherwise, this method return false directly. All the waiting methods have also an overloaded version with a timeout. You can also acquire several permits at once using the permits argument to the different versions of acquire methods.</p><p>A little example with a mutex using the same example as the previous post on Java concurrency :</p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Example</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Semaphore</span> <span class=n>mutex</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Semaphore</span><span class=o>(</span><span class=mi>1</span><span class=o>)</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
        <span class=k>try</span> <span class=o>{</span>
            <span class=n>mutex</span><span class=o>.</span><span class=na>acquire</span><span class=o>();</span>
            <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
        <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
            <span class=n>mutex</span><span class=o>.</span><span class=na>release</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>For more informations about Semaphore in Java, the best is to consult <a href=http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Semaphore.html>the Javadoc of the Semaphore class</a>.</p><p>To conclude, semaphores are a powerful ways to solve concurrency problems, but this is not adapted to all problems. If you need only mutual exclusion, <a title="Java Concurrency – Part 3 : Synchronization with intrinsic locks" href=http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/ target=_blank>synchronized blocks</a> are a better solutions. The problems with semaphores is that you can forget to call the release method and that can cause deadlock sometimes difficult to find.</p> </div> <a href=posts/2010/08/java-concurrency-part-4-semaphores.html#disqus_thread data-disqus-identifier=cache/posts/2010/08/java-concurrency-part-4-semaphores.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/08/java-concurrrency-synchronization-locks.html class=u-url>Java Concurrency – Part 3 : Synchronization with intrinsic locks</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-08-27T07:15:59+02:00>2010-08-27 07:15</time> </small></h1> <hr> <div class=p-summary> <p><after learning how to title="Java Concurrency - Part 1 : Threads" href=http://www.baptiste-wicht.com/2010/05/java-concurrency-part-1-threads/ target=_blank>create threads and <a title="Java Concurrency - Part 2 : Manipulate threads" href=http://www.baptiste-wicht.com/2010/05/java-concurrency-part-2-manipulate-threads/ target=_blank>manipulate them</a>, it's time to go to most important things : synchronization.</after></p><p>Synchronization is a way to make some code thread safe. A code that can be accessed by multiple threads must be made thread safe. Thread Safe describe some code that can be called from multiple threads without corrupting the state of the object or simply doing the thing the code must do in right order.</p><p>For example, we can take this little class :</p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Example</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>    

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>It's really simple and works well with one thread, but absolutely not with multiple threads. An increment like this is not a simple action, but three actions :</p><p></p><ul> <li>Read the current value of "value"</li> <li>Add one to the current value</li> <li>Write that new value to "value"</li></ul><p>Normally, if you have two threads invoking the getNextValue(), you can think that the first will get 1 and the next will get 2, but it is possible that the two threads get the value 1. Imagine this situation :</p><ul><li>Thread 1 : read the value, get 0, add 1, so value = 1</li><li>Thread 2 : read the value, get 0, add 1, so value = 1</li><li>Thread 1 : write 1 to the field value and return 1</li><li>Thread 2 : write 1 to the field value and return 1</li></ul><p>These situations come from what we call interleaving. Interleaving describe the possible situations of several threads executing some statements. Only for three operations and two threads, there is a lot of possible interleavings.</p><p>So we must made the operations atomic to works with multiple threads. In Java, the first way to make that is to use a lock. All Java objects contains an intrinsic locks, we'll use that lock to make methods or statement atomic. When a thread has a lock, no other thread can acquire it and must wait for the first thread to release the lock. To acquire the lock, you have to use the synchronized keyword to automatically acquire and release a lock for a code. You can add the synchronized keyword to a method to acquire the lock before invoking the method and release it after the method execution. You can refactor the getNextValue() method using the synchronized keyword :</p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Example</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>    

    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>(){</span>
        <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>With that, you have the guarantee that only thread can execute the method at the same time. The used lock is the intrinsic lock of the instance. If the method is static, the used lock is the Class object of Example. If you have two methods with the synchronized keyword, only one method of the two will be executed at the same time because the same lock is used for the two methods. You can also write it using a synchronized block :</p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Example</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>()</span> <span class=o>{</span>
        <span class=kd>synchronized</span> <span class=o>(</span><span class=k>this</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>This is exactly the same as using the synchronized keyword on the method signature. Using synchronized blocks, you can choose the lock to block on. By example, if you don't want to use the intrinsic lock of the current object but an other object, you can use an other object just as a lock :</p><pre class="code literal-block"><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Example</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>

    <span class=kd>private</span> <span class=kd>final</span> <span class=n>Object</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>();</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getNextValue</span><span class=o>()</span> <span class=o>{</span>
        <span class=kd>synchronized</span> <span class=o>(</span><span class=n>lock</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=n>value</span><span class=o>++;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>The result is the same but has one difference, the lock is internal to the object so no other code can use the lock. With complex classes, it not rare to use several locks to provide thread safety on the class.</p><p>There is an other issue with multiple threads : the visibility of the variables. This seems when a change made by a thread is visible by an other thread. For performance improvements, the Java compiler and virtual machines can made some improvements using registers and cache. By default, you have no guarantee that a change made by a thread is visible to an other thread. To make a change visible to an other thread, you must use synchronized blocks to ensure visibility of the change. You must use synchronized blocks for the read and for the write of the shared values. You must make that for every read/write of a value shared between multiple threads.</p><p>You can also use the volatile keyword on the field to ensure the visibility of read/write between multiple threads. The volatile keyword ensure only visibility, not atomicity. The synchronized blocks ensure visibility and atomicity. So you can use the volatile keyword on fields that doesn't need atomicity (if you make only read and write to the field without depending on the current value of the field by example).</p><p>You can also note that this simple example can be solved using AtomicInteger, but that will be covered later in an other part of the posts.</p><p>Pay attention that trying to solve thread safety on a problem can add new issues of deadlock. By example, if thread A owns the lock 1 and are waiting for the lock 2 and if lock 2 is acquired by thread B who waits on lock 1, there is a deadlock. Your program is dead. So you have to pay great attention to the locks.</p><p>There is several rules that we must keep in mind when using locks :</p><ol> <li>Every mutable fields shared between multiple threads must be guarded with a lock or made volatile, if you only need visibility</li> <li>Synchronize only the operations that must synchronized, this improve the performances. But don't synchronize too few operations. Try to keep the lock only for short operations.</li> <li>Always know which locks are acquired and when there are acquired and by which thread</li> <li>An immutable object is always thread safe</li></ol><p>Here we are, I hope that this post helps you to understand thread safety and how to achieve it using intrinsic locks. In the next posts, we'll see another synchronization methods.</p> </div> <a href=posts/2010/08/java-concurrrency-synchronization-locks.html#disqus_thread data-disqus-identifier=cache/posts/2010/08/java-concurrrency-synchronization-locks.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/08/file-copy-benchmark-updates-once-again.html class=u-url>Java File Copy Benchmark Updates (once again)</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-08-25T07:26:11+02:00>2010-08-25 07:26</time> </small></h1> <hr> <div class=p-summary> <p>I've made another updates to my file copy benchmark.</p><p>First of all, I used my <a title="Utility class to create graphs of benchmark results" href=http://www.baptiste-wicht.com/2010/08/generate-graphs-benchmarks-easily/ target=_blank>little utility class to automatically create the graphs</a>. The graph are a little less clean, but I spare a lot of time not creating them myself.</p><p>Then, I've also made some corrections on the code :</p><ul> <li>I''ve used a buffer size of 8192 instead of 4096</li> <li>I've made some corrections using the channels because the old code can forgot to write some portions of the file</li> <li>I used allocateDirect() instead of allocate() for the ByteBuffer.</li></ul><p>And I've added a new method using Java 7 : Path.copyTo(Path path).</p><p>So the new results are all based on a Java 7 Virtual Machine.</p><p>You'll find all the new informations and result, on the original post : <a title="Java File Copy Benchmark" href=http://www.baptiste-wicht.com/2010/08/file-copy-in-java-benchmark/ target=_self>File Copy in Java - Benchmark</a></p><p>I hope this new informations will interest you.</p> </div> <a href=posts/2010/08/file-copy-benchmark-updates-once-again.html#disqus_thread data-disqus-identifier=cache/posts/2010/08/file-copy-benchmark-updates-once-again.html>Comments</a> </article> <article class="postbox h-entry post-text"> <h1 class=p-name><a href=posts/2010/08/java-7-try-with-resources-statement.html class=u-url>Java 7 : The new try-with-resources statement</a> <br><small>   Posted: <time class="published dt-published" datetime=2010-08-24T07:30:53+02:00>2010-08-24 07:30</time> </small></h1> <hr> <div class=p-summary> <p>From the build 105, the compiler and runtime of Java 7 Releases have support for the new form of try : try-with-resources, also called ARM (Automatic Resource Management) blocks. </p><p>This new statement make working with streams and all kind of closeable resources easier. By example, in Java, you can have this kind of code : </p><pre class="code literal-block"><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>customBufferStreamCopy</span><span class=o>(</span><span class=n>File</span> <span class=n>source</span><span class=o>,</span> <span class=n>File</span> <span class=n>target</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>InputStream</span> <span class=n>fis</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>OutputStream</span> <span class=n>fos</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=k>try</span> <span class=o>{</span>
        <span class=n>fis</span> <span class=o>=</span> <span class=k>new</span> <span class=n>FileInputStream</span><span class=o>(</span><span class=n>source</span><span class=o>);</span>
        <span class=n>fos</span> <span class=o>=</span> <span class=k>new</span> <span class=n>FileOutputStream</span><span class=o>(</span><span class=n>target</span><span class=o>);</span>

        <span class=kt>byte</span><span class=o>[]</span> <span class=n>buf</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>byte</span><span class=o>[</span><span class=mi>8192</span><span class=o>];</span>

        <span class=kt>int</span> <span class=n>i</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>((</span><span class=n>i</span> <span class=o>=</span> <span class=n>fis</span><span class=o>.</span><span class=na>read</span><span class=o>(</span><span class=n>buf</span><span class=o>))</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>fos</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=n>buf</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>i</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
    <span class=o>}</span> <span class=k>finally</span> <span class=o>{</span>
        <span class=n>close</span><span class=o>(</span><span class=n>fis</span><span class=o>);</span>
        <span class=n>close</span><span class=o>(</span><span class=n>fos</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>close</span><span class=o>(</span><span class=n>Closeable</span> <span class=n>closable</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>closable</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>try</span> <span class=o>{</span>
            <span class=n>closable</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
        <span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>IOException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>A little bit heavy, isn't it ? This is only an example, here the management of exceptions is not good. </p><p>So let's use try-with-resources statement to simplify this code, who becomes : </p><pre class="code literal-block"><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>customBufferStreamCopy</span><span class=o>(</span><span class=n>File</span> <span class=n>source</span><span class=o>,</span> <span class=n>File</span> <span class=n>target</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>try</span> <span class=o>(</span><span class=n>InputStream</span> <span class=n>fis</span> <span class=o>=</span> <span class=k>new</span> <span class=n>FileInputStream</span><span class=o>(</span><span class=n>source</span><span class=o>);</span>
        <span class=n>OutputStream</span> <span class=n>fos</span> <span class=o>=</span> <span class=k>new</span> <span class=n>FileOutputStream</span><span class=o>(</span><span class=n>target</span><span class=o>)){</span>

        <span class=kt>byte</span><span class=o>[]</span> <span class=n>buf</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>byte</span><span class=o>[</span><span class=mi>8192</span><span class=o>];</span>

        <span class=kt>int</span> <span class=n>i</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>((</span><span class=n>i</span> <span class=o>=</span> <span class=n>fis</span><span class=o>.</span><span class=na>read</span><span class=o>(</span><span class=n>buf</span><span class=o>))</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>fos</span><span class=o>.</span><span class=na>write</span><span class=o>(</span><span class=n>buf</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>i</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre><p>A lot cleaner, no ? With that code, the resources are automatically closed after the try. In the try resources list, you can declare several resources, but all these resources must implement the java.lang.AutoCloseable interface. </p><p>If you want more informations, about this new statement read <a target=_blank href=http://blogs.sun.com/darcy/entry/project_coin_updated_arm_spec>try-with-resources specifications</a>.</p> </div> <a href=posts/2010/08/java-7-try-with-resources-statement.html#disqus_thread data-disqus-identifier=cache/posts/2010/08/java-7-try-with-resources-statement.html>Comments</a> </article> <nav class=postindexpager> <ul class=pager> <li class=previous> <a href=index-12.html rel=prev>Newer posts</a> </li> <li class=next> <a href=index-10.html rel=next>Older posts</a> </li> </ul> </nav> <script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script> </div> </div> </div></div><footer> Contents © 2014 <a href=mailto:baptistewicht@gmail.com>Baptiste Wicht</a> - Powered by <a href=http://getnikola.com rel=nofollow>Nikola</a><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons License" style=padding-left:5px;border-width:0 src=assets/img/cc.png></a> <ul class=footer_inline_ul> </ul></footer> <script src=assets/js/all-nocdn.js></script> <script type=text/javascript>
      $(document).ready(function() {
        jQuery.getJSON('/assets/js/tag_cloud_data.json', function(data) {
            var items = [];

            $.each(data, function(key, val) {
                items.push('<li><a href="' + val[1] +'" '+'data-weight="'+val[0]+'"'+'>' + key + '</a></li>');
            });

            $('<div/>', {
                'id': 'tags',
                html: '<ul>' + items.join('') + '</ul>'
            }).appendTo('body');

            if(!$('#tags_canvas').tagcanvas({
                textColour: '#FFFFFF',
                outlineColour: '#ff00ff',
                reverse: true,
                depth: 0.8,
                maxSpeed: 0.05,
                weight: true,
                weightFrom: "data-weight",
                weightSizeMin: 8,
                weightSizeMax: 24
            },'tags')) {
                //something went wrong, hide the canvas container
                $('#tags_container').hide();
            }});
        });
    </script><script type=text/javascript src=https://apis.google.com/js/platform.js></script></body></html>