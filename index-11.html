<!DOCTYPE html><html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Website about vtechnologies Java, Spring, OSGi, Hardware,...">
    <meta name="author" content="Baptiste Wicht">
    <title>@Blog("Baptiste Wicht") (old posts, page 11) | @Blog("Baptiste Wicht")</title>
    
            <link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
      <link rel="canonical" href="http://wichtounet.github.io/index-11.html">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

    
    
    
<link rel="stylesheet" type="text/css" href="assets/css/tipuesearch.css">
</head><body><div id="tipue_search_content" style="margin-left: auto; margin-right: auto; padding: 20px;"></div>



<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container-fluid"><!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://wichtounet.github.io/">@Blog("Baptiste Wicht")</a>
        </div><!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li><a href="stories/about.html">About</a>
                </li><li><a href="stories/publications.html">Publications</a>
                </li><li><a href="stories/donate.html">Donate</a>
                </li><li><a href="stories/faq.html">FAQ</a>
                </li><li><a href="stories/legal.html">Legal</a>
                </li><li><a href="archive.html">Archives</a>
                </li><li><a href="categories/index.html">Tags</a>
                </li><li><a href="rss.xml">RSS</a>

            </li></ul>
                
<span class="navbar-form pull-left">
<input type="text" id="tipue_search_input">
</span>

            <ul class="nav navbar-nav navbar-right">
                
                
                    
            </ul>
        </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
</nav>

<!-- End of Menubar -->

<div class="container">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/09/tip-batch-resize-images-on-ubuntu-linux.html" class="u-url">Tip : Batch resize images on Ubuntu Linux</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-09-08T07:26:01+00:00">2010-09-08 07:26</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>After needing to <a href="http://www.baptiste-wicht.com/2010/07/tip-optimize-images-on-ubuntu-linux/" target="_blank">optimize a lot of images at once</a>, this weekend I needed to resize a lot of images to the same size because they were too big.</p>
<p>Like every other thing in Linux, there is a really simple tool to automate that. I used imagemagick to do that. Of course, there is certainly a lot of other things to make that work, but this is the first I've found and it works well.</p>
<p>So first, you need to install it if you don't have the tool :</p>
<p></p><pre>sudo apt-get install imagemagick</pre>
<p>And then, you can resize all the JPG images to a width of 640px of the current folder using the single command :</p>
<pre>mogrify -resize 640 *.jpg</pre>

<p>If you want the height, just add a x :</p>
<pre>mogrify -resize x640 *.jpg</pre>

<p>You can also specify maximum width and height, that can be useful if you have big images and you don't want a width larger than x and a height larger than y but you don't want to resize little images in the same folder. Here is an example resizing images if the width is larger than 1280 or height larger than 1024 :</p>
<pre>mogrify -resize '1280x1024&gt;' *.jpg</pre>

<p>With all that commands, the ratio is preserved. If you want more informations on the possible resize options, you can consult the <a href="http://www.imagemagick.org/www/command-line-processing.html#geometry" target="_blank">documentation of ImageMagick</a>.</p>
<p>Hope that will help someone.</p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/09/tip-batch-resize-images-on-ubuntu-linux.html#disqus_thread" data-disqus-identifier="cache/posts/2010/09/tip-batch-resize-images-on-ubuntu-linux.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/09/java-concurrency-atomic-variables.html" class="u-url">Java Concurrency - Part 6 : Atomic Variables</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-09-08T07:14:18+00:00">2010-09-08 07:14</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>When a data (typically a variable) can be accessed by several threads, you must synchronize the access to the data to ensure visibility and correctness. </p>
<p>By example, if you have a simple counter (yes, once again) : </p>
<p>[java]public class Counter {
    private int value;</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getPreviousValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>This class works really well in single-threaded environment, but don't work at all when several threads access the same Counter instance. If you don't know why, read <a target="_blank" href="http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/">this post about synchronization</a>. You can solve the problem using synchronized at method level : </p>
<p>[java]public class SynchronizedCounter {
    private int value;</p>
<div class="code"><pre><span class="n">public</span> <span class="n">synchronized</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="n">synchronized</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">public</span> <span class="n">synchronized</span> <span class="kt">int</span> <span class="nf">getPreviousValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>This class now works well. But locking is not a lightweight mechanism and have several disadvantages. When several threads try to acquire the same lock, one or more threads will be suspended and they will be resumed later. When the critical section is little, the overhead is really heavy especially when the lock is often acquired and there is a lot of contention. Another disadvantage is that the other threads waiting of the lock cannot do something else during waiting and if the thread who has the lock is delayed (due to a page fault or the end of the time quanta by example), the others threads cannot take their turn. </p>
<p>So how to do to avoid this disadvantages ? We must use non-blocking algorithms. This algorithms don't use blocking mechanisms and by that fact are more scalable and performing. These algorithms use low-level machine instructions which are atomic to ensure the atomicity of higher-level operations. While locking is a pessimistic approach, we can also use optimistic technique to develop algorithms. This time, we'll detect collisions between threads in which case, the operation fails and we do something else (often retrying the same operation).</p>
<p>The actual processors provide several instructions that simplify greatly the implementation of these non-blocking algorithms, the most-used operation today is the compare-and-swap operation (CAS). This operation takes three parameters, the memory address, the expected current value and the new value. It atomically update the value at the given memory address if the current value is the expected, otherwise it do nothing. In both cases, the operation return the value at the address after the operation execution. So when several threads try to execute the CAS operation, one thread wins and the others do nothing. So the caller can choose to retry or to do something else. We often use this operation to implement another operation, the compare-and-set. This method makes exactly the same things as CAS but return a boolean indicating if the operation succeeded or not. </p>
<p>Before Java 5.0, this operation was not available directly to developer, but in Java 5.0 several atomic variables (for int, long, boolean and reference values) were added. The int and long versions also supports numeric operations. The JVM compiles these classes with the better operations provided by the hardware machine, CAS or a Java implementation of the operation using a lock. Here are the classes : </p>
<p></p><ul>
<li>AtomicInteger</li>

<li>AtomicLong</li>

<li>AtomicBoolean</li>

<li>AtomicReference</li>

</ul>

<p>All these classes supports compare-and-set (via the compareAndSet() method) and other operations (get(), set() and getAndSet()). The setters operations are implemented using compareAndSet. These classes supports multi-threaded access and have a better scalability than synchronizing all the operations. </p>
<p>Here is how we can rewrite our counter using an AtomicInteger : </p>
<p>[java]public class AtomicCounter {
    private final AtomicInteger value = new AtomicInteger(0);</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getPreviousValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">decrementAndGet</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>The incrementAndGet() and decrementAndGet() methods are two of the numeric operations provided by the AtomicLong and AtomicInteger classes. You also have getAndDecrement(), getAndIncrement(), getAndAdd(int i) and addAndGet(). </p>
<p>This version is faster than the synchronized one and is also thread safe. </p>
<p>If you only have the compareAndSet(), here is how we can implement increment() method using it : </p>
<p>[java]public void increment(AtomicInteger integer){
    while(true){
        int current = integer.get();
        int next = current + 1;</p>
<div class="code"><pre>    <span class="k">if</span><span class="p">(</span><span class="n">integer</span><span class="p">.</span><span class="n">compareAndSet</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next</span><span class="p">)){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>This seems to be complicated, but this is the cost of non-blocking algorithms. When we detect collision, we retry until the operation succeeded. This is the common schema for non-blocking algorithms. </p>
<p>Here is a thread-safe Stack implemented using AtomicReference : </p>
<p>[java]public class Stack {
    private final AtomicReference&lt;Element&gt; head = new AtomicReference&lt;Element&gt;(null);</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">String</span> <span class="n">value</span><span class="p">){</span>
    <span class="n">Element</span> <span class="n">newElement</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Element</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">Element</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="n">newElement</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="p">;</span>

        <span class="c1">//Trying to set the new element as the head</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">compareAndSet</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">newElement</span><span class="p">)){</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">public</span> <span class="n">String</span> <span class="nf">pop</span><span class="p">(){</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">Element</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

        <span class="c1">//The stack is empty</span>
        <span class="k">if</span><span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">null</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Element</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">oldHead</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

        <span class="c1">//Trying to set the new element as the head</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">compareAndSet</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">newHead</span><span class="p">)){</span>
            <span class="k">return</span> <span class="n">oldHead</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="n">class</span> <span class="n">Element</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">final</span> <span class="n">String</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">Element</span> <span class="n">next</span><span class="p">;</span>

    <span class="n">private</span> <span class="nf">Element</span><span class="p">(</span><span class="n">String</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>It's really more complicated than using synchronized on the two methods but also more performing if there is contention (and often even if there is no contention). </p>
<p>So this ends this post. To conclude, atomic variables classes are a really good way to implement non-blocking algorithms and moreover are also a very good alternative to volatile variables, because they can provide atomicity and visibility. </p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/09/java-concurrency-atomic-variables.html#disqus_thread" data-disqus-identifier="cache/posts/2010/09/java-concurrency-atomic-variables.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html" class="u-url">Java Concurrency - Part 5 : Monitors (Locks and Conditions)</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-09-06T07:13:27+00:00">2010-09-06 07:13</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>After seeing <a title="Java Concurrency – Part 4 : Semaphores" href="http://www.baptiste-wicht.com/2010/08/java-concurrency-part-4-semaphores/" target="_blank">how to synchronize code using semaphores</a>, we'll see how to do that using <strong>monitors</strong>.</p>
<p>Monitors are an other mechanism of concurrent programming. It's a higher level mechanism than semaphores and also more powerful. A monitor is an instance of a class that can be used safely by several threads. All the methods of a monitor are executed with mutual exclusion. So at most one thread can execute a method of the monitor at the same time. This mutual exclusion policy makes easier to work with monitor and to develop the method content of the monitor.</p>
<p>Monitors have an other feature, the possibility to make a thread waiting for a condition. During the wait time, the thread temporarily gives up its exclusive access and must reacquire it after the condition has been met. You can also signal one or more threads that a condition has been met.</p>
<p>There is several advantages on using monitors instead of a lower-level mechanisms :</p>
<p></p><ul>
    <li>All the synchronization code is centralized in one location and the users of this code don’t need to know how it’s implemented.</li>
    <li>The code doesn't depend on the number of processes, it works for as many processes as you want</li>
    <li>You don’t need to release something like a mutex, so you cannot forget to do it</li>
</ul>
<p>When we must describe a monitor, we simple use the <strong>monitor</strong> keyword and describe the methods as common methods :</p>
<p>[java]monitor SimpleMonitor {
    public method void testA(){
        //Some code
    }</p>
<div class="code"><pre><span class="n">public</span> <span class="n">method</span> <span class="kt">int</span> <span class="nf">testB</span><span class="p">(){</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>To describe a condition variable, we use the <strong>cond</strong> keyword. A condition variable is a kind of queue of process who are waiting on the same condition. You have several operations available on a condition, the most important is to signal a process waiting to be awaken and to wait on a condition. There are some similarities between signal/wait operations and P and V of semaphores, but this is a little different. The signal operation does nothing if the queue is empty and the wait operation put always the thread in the waiting queue. The process queue is served in a first come, first served mode.   When a thread wakes up after waiting on a condition, it must reacquire the lock before continuing in the code.</p>
<p>Before going further, we must have more information about the signal operations. When writing monitors, you normally have the choice between several philosophies for the signaling operation :</p>
<ol>
    <li>Signal &amp; Continue (SC) : The process who signal keep the mutual exclusion and the signaled will be awaken but need to acquire the mutual exclusion before going.</li>
    <li>Signal &amp; Wait (SW) : The signaler is blocked and must wait for mutual exclusion to continue and the signaled thread is directly awaken and can start continue its operations.</li>
    <li>Signal &amp; Urgent Wait (SU) : Like SW but the signaler thread has the guarantee than it would go just after the signaled thread</li>
    <li>Signal &amp; Exit (SX) : The signaler exits from the method directly after the signal and the signaled thread can start directly. This philosophy is not often used.</li>
</ol>

<p>The available policies depends on the programming language, in Java, there is only one policy available, the SC one.</p>
<p>In Java there is no keyword to directly create a monitor. To implement a monitor, you must create a new class and use <strong>Lock</strong> and <strong>Condition</strong> classes. Lock is the interface is <strong>ReentrantLock</strong> is the main used implementation, this is the one that we'll learn to use in the current post. To create a ReentrantLock, you have two constructors, a default constructor and a constructor with a boolean argument indicating if the lock is fair or not. A fair lock indicates that the threads will acquire the locks in the order they ask for. Fairness is a little heavier than default locking strategies, so use it only if you need it. To acquire the lock, you just have to use the method <em>lock</em> and <em>unlock</em> to release it.</p>
<p>The explicit locks have the same memory semantics than the synchronized blocks. So the visibility of the changes is guarantee when you use lock()/unlock() blocks.</p>
<p>So to implement, the monitor example we've seen before, we just need to create a class and use the lock to make the mutual exclusion :</p>
<p>[java]public class SimpleMonitor {
    private final Lock lock = new ReentrantLock();</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">void</span> <span class="nf">testA</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="c1">//Some code</span>
    <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">testB</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>The person who've already read the other parts of this post set will say that it will be easier to use the synchronized keyword on the two methods. But with synchronized, we will not have the condition variables. If you don't need condition variables but only locking, it will be easier to use the synchronized blocks instead of Locks.</p>
<p>You can create conditions using the <em>newCondition</em> method on the lock. A condition is a variable of type <strong>Condition</strong>. You can make the current thread wait on the condition using the <em>await</em> method (and its variant with timeout) and you can signal threads using <em>signal</em> and <em>signalAll</em> methods. The signalAll methods wakes up all the threads waiting on the condition variable.</p>
<p>Let's try with a simple common example : A bounded buffer. It's a cyclic buffer with a certain capacity with a start and an end.</p>
<p>[java]import java.util.concurrent.locks.Condition;</p>
<p>import java.util.concurrent.locks.Lock;</p>
<p>import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class BoundedBuffer {
    private final String[] buffer;
    private final int capacity;</p>
<div class="code"><pre><span class="n">private</span> <span class="kt">int</span> <span class="n">front</span><span class="p">;</span>
<span class="n">private</span> <span class="kt">int</span> <span class="n">rear</span><span class="p">;</span>
<span class="n">private</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

<span class="n">private</span> <span class="n">final</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ReentrantLock</span><span class="p">();</span>

<span class="n">private</span> <span class="n">final</span> <span class="n">Condition</span> <span class="n">notFull</span> <span class="o">=</span> <span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="p">();</span>
<span class="n">private</span> <span class="n">final</span> <span class="n">Condition</span> <span class="n">notEmpty</span> <span class="o">=</span> <span class="n">lock</span><span class="p">.</span><span class="n">newCondition</span><span class="p">();</span>

<span class="n">public</span> <span class="nf">BoundedBuffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">super</span><span class="p">();</span>

    <span class="n">this</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>

    <span class="n">buffer</span> <span class="o">=</span> <span class="n">new</span> <span class="n">String</span><span class="p">[</span><span class="n">capacity</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="p">(</span><span class="n">String</span> <span class="n">data</span><span class="p">)</span> <span class="n">throws</span> <span class="n">InterruptedException</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">notFull</span><span class="p">.</span><span class="n">await</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">buffer</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>

        <span class="n">notEmpty</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>
    <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">public</span> <span class="n">String</span> <span class="n">fetch</span><span class="p">()</span> <span class="n">throws</span> <span class="n">InterruptedException</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">notEmpty</span><span class="p">.</span><span class="n">await</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
        <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="p">;</span>
        <span class="n">count</span><span class="o">--</span><span class="p">;</span>

        <span class="n">notFull</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>So some explications :</p>
<ol>
    <li>The two methods are protected with the lock to ensure mutual exclusion</li>
    <li>Then we use two conditions variables. One to wait for the buffer to be not empty and an other one to wait for the buffer to be not full.</li>
    <li>You can see that I have wrapped the await operation on a while loop. This is to avoid signal stealers problem that can occurs when using Signal &amp; Continue</li>
</ol>

<p>And that BoundedBuffer can be easily used with several threads with no problems.</p>
<p>As you can see, you can use monitors to solve a lot of concurrent programming problems and this mechanism is really powerful and performing.</p>
<p>I hope you found that article interesting and that this set of posts about Java concurrency brings you some stuff about Java.</p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html#disqus_thread" data-disqus-identifier="cache/posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/09/save-time-with-the-gmail-priority-inbox.html" class="u-url">Save time with the Gmail Priority Inbox</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-09-04T05:44:27+00:00">2010-09-04 05:44</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>Hi,</p>
<p>Some days ago, Gmail released a new feature, the <strong>Priority Inbox</strong>. Actually, the feature is not released on all accounts, but if it is released on yours, you can see a message "Try Gmail Priority Inbox", in top right high corner, just after your user name.</p>
<p>Once you activated this new inbox, you will see two inbox, the new Priority Inbox on top and the old Inbox. The Inbox has not changed, but now you can use the Priority Inbox. In this view, you will see your messages sorted in two categories, the first one contains the important unread messages and the second one contains all the other messages.</p>
<p>If you found an error, namely a non-important message tagged as important or the contrary, you have two new buttons :</p>
<p><a href="wp-content/uploads/2010/09/Gmail-Buttons.png"><img class="size-full wp-image-1018" title="GMail Priority Buttons" src="wp-content/uploads/2010/09/Gmail-Buttons.png" alt="GMail Priority Buttons" width="77" height="32"></a></p>
<p>With these buttons, you can move a message from the priority messages to the others and vice versa. When you do that, the algorithm between the sorting will save your action and try to improve the efficiency of the Priority Inbox to not make the same error again.</p>
<p>At this time, I'm completely happy with this new feature, I've had only one message marked as important that was not, but it's all. I think it's a great tool that Google has offerred to us.</p>
<p>If you want more informations, let's watch this video from Google :</p>
<p><object width="640" height="385"><param name="movie" value="http://www.youtube.com/v/5nt3gE9dGHQ?fs=1&amp;amp"><param name="allowFullScreen" value="true"><param name="allowscriptaccess" value="always"><embed src="http://www.youtube.com/v/5nt3gE9dGHQ?fs=1&amp;amp" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="640" height="385"></embed></object></p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/09/save-time-with-the-gmail-priority-inbox.html#disqus_thread" data-disqus-identifier="cache/posts/2010/09/save-time-with-the-gmail-priority-inbox.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/09/my-java-benchmarks-on-github.html" class="u-url">My Java Benchmarks on GitHub</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-09-03T07:16:20+00:00">2010-09-03 07:16</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>Hi,</p>
<p>I've created a new github repository for my <strong>Java Benchmarks</strong> : <a title="java-benchmarks github repository" href="http://github.com/wichtounet/java-benchmarks" target="_blank">java-benchmarks</a></p>
<p>From now all my benchmarks will be pushed to this repository. This is more simple for me to manage and more secure also.</p>
<p>At this time, there is seven benchmarks on the repository :</p>
<p></p><ol>
    <li>Closest Pair Search Benchmark : A benchmark to test two closest pair point search algorithms : the naive one and the <strong>sweeping plane</strong> one. <a title="Closest Pair Search Benchmark Results" href="http://www.baptiste-wicht.com/2010/04/closest-pair-of-point-plane-sweep-algorithm/" target="_blank">Results</a>.</li>
    <li>File Copy Benchmark : A benchmark on the different ways to make <strong>file copy</strong> in Java. <a title="Java File Copy Benchmark Results" href="http://www.baptiste-wicht.com/2010/08/file-copy-in-java-benchmark/" target="_blank">Results</a>.</li>
    <li>Iteration Remove Benchmark : A simple benchmark to test if it's interesting to remove the read elements from a list when we make several iterations over the list.</li>
    <li>Reflection Benchmark : A little benchmark to test the performances of <strong>reflection</strong> versus switch cases and direct invocations.</li>
    <li>Short Indexes Loop Benchmark : A benchmark to test which <strong>primitive type</strong> is the most performing using as iteration index. <a title="Short Indexes Loop Benchmark Results" href="http://www.baptiste-wicht.com/2010/01/dont-use-shorts-in-loop/" target="_blank">Results</a>.</li>
    <li>Synchronization Benchmark : A benchmark to test the performances of the different <strong>synchronization mechanisms</strong> available in Java to provide mutual exclusion. <a title="Synchronization Benchmark Results" href="http://www.baptiste-wicht.com/2010/09/java-synchronization-mutual-exclusion-benchmark/" target="_blank">Results</a>.</li>
    <li>Unmodifiable Benchmark : A benchmark to test the performances of <strong>unmodifiable collection</strong> versus creating a copy of the list.</li>
</ol>
<p>I hope you'll find these sources interesting. If you found errors or improvements, don't hesitate to comment to tell me what.</p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/09/my-java-benchmarks-on-github.html#disqus_thread" data-disqus-identifier="cache/posts/2010/09/my-java-benchmarks-on-github.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html" class="u-url">Java Synchronization (Mutual Exclusion) Benchmark</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-09-01T07:13:18+00:00">2010-09-01 07:13</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>I've created another benchmark. This time, I've benchmarked the different ways of synchronizing a little code using <strong>mutual exclusion</strong> on this code.</p>
<p>The code to protect will be very simple. It's a simple counter :</p>
<p>[java]//Init</p>
<p>int counter = 0; </p>
<p>//Critical section</p>
<p>counter++;[/java]</p>
<p>The critical section, if not protected with synchronization system, will not function properly due to possible <strong>interleavings</strong> (read <a href="http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/" target="_blank">the article on synchronization</a> if you don't know what is <strong>interleaving</strong>).</p>
<!--more-->

<p>I've used 3 different synchronizers to synchronize this increment :</p>
<p></p><ol>
    <li>synchronized block</li>
    <li>Semaphores (fair and unfair)</li>
    <li>Explicit locks (fair and unfair)</li>
</ol>
<p>I've also used a third way to solve the problem with AtomicInteger. This is not the same as the other ways because it does not provide mutual exclusion but this is a good way to synchronize simple values, like integers or boolean, but also references. The atomicity of the operations of the AtomicInteger is made using the compare-and-swap operation of the operating system. So there is no waiting operations. So there is less context switches and result in more performing code normally.</p>
<p>Here is the code of these 4 ways to solve the problems :</p>
<p>[java]private class SynchronizedRunnable implements Runnable {
    private int counter = 0;</p>
<div class="code"><pre><span class="err">@</span><span class="n">Override</span>
<span class="n">public</span> <span class="n">synchronized</span> <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}</p>
<p>private class ReentrantLockRunnable implements Runnable {
    private int counter = 0;</p>
<div class="code"><pre><span class="n">private</span> <span class="n">Lock</span> <span class="n">lock</span><span class="p">;</span>

<span class="n">private</span> <span class="nf">ReentrantLockRunnable</span><span class="p">(</span><span class="n">boolean</span> <span class="n">fair</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">super</span><span class="p">();</span>

    <span class="n">lock</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ReentrantLock</span><span class="p">(</span><span class="n">fair</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">@</span><span class="n">Override</span>
<span class="n">public</span> <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}</p>
<p>private class SemaphoreRunnable implements Runnable {
    private int counter = 0;</p>
<div class="code"><pre><span class="n">private</span> <span class="n">final</span> <span class="n">Semaphore</span> <span class="n">semaphore</span><span class="p">;</span>

<span class="n">private</span> <span class="nf">SemaphoreRunnable</span><span class="p">(</span><span class="n">boolean</span> <span class="n">fair</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">super</span><span class="p">();</span>

    <span class="n">semaphore</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fair</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">@</span><span class="n">Override</span>
<span class="n">public</span> <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">semaphore</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">throw</span> <span class="n">new</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
        <span class="n">semaphore</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}</p>
<p>private class AtomicIntegerRunnable implements Runnable {
    private AtomicInteger counter = new AtomicInteger(0);</p>
<div class="code"><pre><span class="err">@</span><span class="n">Override</span>
<span class="n">public</span> <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">counter</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>I used Runnable to facilitate the testing and timing of the different mechanisms.</p>
<p>The test is made in two phases :</p>
<ol>
    <li>Test with only one thread with a sophisticated benchmark framework. This act also as warmup for the different code.</li>
    <li>Test with several threads (several test with increasing number of threads). The test is made using a little code I wrote for the occasion. Each method is executed 2²³ times (8388608 times exactly).</li>
</ol>

<p>The source code is available at the end of the post.</p>
<p>The test has been launched on a Ubuntu 10.04 with a Java 6 virtual machine. The computer has a 64 bit Core 2 Duo 3.16 Ghz processor and 6Go of DDR2.</p>
<p>So let's see the results. First with one thread :</p>
<p><a href="wp-content/uploads/2010/08/Synchronization-benchmark.png"><img class="size-full wp-image-999" title="Synchronization Benchmark - One Thread" src="wp-content/uploads/2010/08/Synchronization-benchmark.png" alt="Synchronization Benchmark - One Thread" width="500" height="400"></a></p>
<p>The first thing we see is that the AtomicInteger is the fastest version. This is because AtomicInteger do not use waiting operation, so this result in less context switches and more performances. But this is not exactly the case of the benchmark, so let's concentrate on the 5 others methods. We see that the synchronized method is the fastest and that fair methods are a little slower than unfair, but not a lot.</p>
<p>Now, we'll test the scalability of all these methods using several threads.</p>
<p><a href="wp-content/uploads/2010/08/Synchronization-2-threads.png"><img class="size-full wp-image-1000" title="Synchronization - 2 threads" src="wp-content/uploads/2010/08/Synchronization-2-threads.png" alt="Synchronization - 2 threads" width="500" height="400"></a></p>
<p>This method we can see that the fair methods are awfully slow compared to the the unfair versions. Indeed adding fairness to a synchronizer is really heavy. When fair, the threads acquire the locks in the order they ask for. With nonfair locks, barging is allowed. So when a thread try to acquire the lock and its available, it can acquire it even if there is threads waiing for the lock. It's heavier to provide fairness because there is a lot more context switches. The problem was not here with only one thread because it's always fair.</p>
<p>The results for the other versions are the same as with one thread.</p>
<p>Let's add two more threads :</p>
<p><a href="wp-content/uploads/2010/08/Synchronization-4-threads.png"><img class="size-full wp-image-1001" title="Synchronization - 4 threads" src="wp-content/uploads/2010/08/Synchronization-4-threads.png" alt="Synchronization - 4 threads" width="500" height="400"></a></p>
<p>The fair versions are more and more slows when we add threads. The scalability of these methods is really bad. Let's see the graph without the fair versions :</p>
<p><a href="wp-content/uploads/2010/08/Synchronization-4-threads-sub.png"><img class="size-full wp-image-1002" title="Synchronization - 4 threads" src="wp-content/uploads/2010/08/Synchronization-4-threads-sub.png" alt="Synchronization - 4 threads" width="500" height="400"></a></p>
<p>This time we can see some differences. The synchronized method is the slower this time and semaphore has a little advantage. Let's see with 8 threads :</p>
<p><a href="wp-content/uploads/2010/08/Synchronization-8-threads.png"><img class="size-full wp-image-1003" title="Synchronization - 8 threads" src="wp-content/uploads/2010/08/Synchronization-8-threads.png" alt="Synchronization - 8 threads" width="500" height="400"></a></p>
<p>Here the synchronized method is really slower than the other methods. It appears that the algorithm of the synchronized block is less scalable than the explicit locks and semaphore versions. Let's watch what happens with other number of threads :</p>
<p><a href="wp-content/uploads/2010/08/Synchronization-32-threads.png"><img class="size-full wp-image-1004" title="Synchronization - 32 threads" src="wp-content/uploads/2010/08/Synchronization-32-threads.png" alt="Synchronization - 32 threads" width="500" height="400"></a></p>
<p><a href="wp-content/uploads/2010/08/Synchronization-128-threads.png"><img class="size-full wp-image-1005" title="Synchronization - 128 threads" src="wp-content/uploads/2010/08/Synchronization-128-threads.png" alt="Synchronization - 128 threads" width="500" height="400"></a></p>
<p>I've also made the test with other number of threads (16, 64 and 256), but the results are the same as the other.</p>
<p>We can made several conclusions based on the results :</p>
<ol>
    <li>Fair versions are slow. If you don't absolutely need fairness, don't use fair locks or semaphores</li>
    <li>Semaphores and explicit locks have the same performances. This is because the 2 classes (Semaphore and ReentrantLock) are based on the same class AbstractQueueSynchronizer that is used by almost all synchronization mechanisms of Java</li>
    <li>Explicit locks and semaphores are more scalable than synchronized blocks. But that depend on the virtual machine, I've seen other results indicating that the difference is a lot smaller</li>
    <li>The AtomicInteger is the most performing method. This class doesn't provide mutual exclusion, but provide thread safe methods to works on simple values (there is version for Long, Double, Boolean and even Reference)</li>
</ol>

<p>So that's all for this benchmark. I hope you found it interesting.</p>
<p>The sources of the benchmark : <a href="wp-content/uploads/2010/08/SynchronizationBenchmark.java">Synchronization Benchmark Sources</a></p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html#disqus_thread" data-disqus-identifier="cache/posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/08/java-concurrency-part-4-semaphores.html" class="u-url">Java Concurrency - Part 4 : Semaphores</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-08-30T07:11:55+00:00">2010-08-30 07:11</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>We continue in Java Concurrency with the semaphores. Semaphores is also a way to synchronize threads.</p>
<p>Semaphores are a really simple concept, invented by the famous Dutch computer scientist Edsger Dijkstra. Basically a semaphore is a counter (integer) that allows a thread to get into a critical region if the value of the counter is greater than 0. If it's the case, the counter is decremented by one otherwise, the thread is waiting until it can go. And when the thread go away from the critical region, the counter is incremented by one to allow one more thread to pass the critical region. A semaphore is created with a certain value for its counter. So, you can execute two actions on a semaphore P and V.</p>
<p>By example, if you have a critical that cannot be executed concurrently, you can use a semaphore :</p>
<p>[java]sem mutex = new sem(1)</p>
<p>P(mutex)</p>
<p>//Critical region</p>
<p>V(mutex)[/java]</p>
<p>So you must always call by yourself the P operation before the critical region and V after it. We call a mutex (mutual exclusion) a semaphore with a value of one. So only one thread can enter the region guarded by the semaphore. This is the most used semaphore. The other use of semaphore is to guard a set of resources like database connections or a data pool.</p>
<p>In Java, a semaphore is created using the java.util.concurrent.Semaphore class. You can create easily :</p>
<p>[java]Semaphore mutex = new Semaphore(1);</p>
<p>Semaphore available = new Semaphore(100);[/java]</p>
<p>The P and V operations are represented using the acquire and release methods. The method acquire can be interrupted if the thread is interrupted. There is an uninterruptible version with the method acquireUninterruptibly(). There is also a third version with the tryAcquire method. This method acquire a permit only if there is one permit available, otherwise, this method return false directly. All the waiting methods have also an overloaded version with a timeout. You can also acquire several permits at once using the permits argument to the different versions of acquire methods.</p>
<p>A little example with a mutex using the same example as the previous post on Java concurrency :</p>
<p>[java]public class Example {
    private int value = 0;</p>
<div class="code"><pre><span class="n">private</span> <span class="n">final</span> <span class="n">Semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">public</span> <span class="kt">int</span> <span class="n">getNextValue</span><span class="p">()</span> <span class="n">throws</span> <span class="n">InterruptedException</span> <span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
        <span class="n">mutex</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>For more informations about Semaphore in Java, the best is to consult <a href="http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Semaphore.html">the Javadoc of the Semaphore class</a>.</p>
<p>To conclude, semaphores are a powerful ways to solve concurrency problems, but this is not adapted to all problems. If you need only mutual exclusion, <a title="Java Concurrency – Part 3 : Synchronization with intrinsic locks" href="http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/" target="_blank">synchronized blocks</a> are a better solutions. The problems with semaphores is that you can forget to call the release method and that can cause deadlock sometimes difficult to find.</p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/08/java-concurrency-part-4-semaphores.html#disqus_thread" data-disqus-identifier="cache/posts/2010/08/java-concurrency-part-4-semaphores.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/08/java-concurrrency-synchronization-locks.html" class="u-url">Java Concurrency – Part 3 : Synchronization with intrinsic locks</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-08-27T07:15:59+00:00">2010-08-27 07:15</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>After learning how to <a title="Java Concurrency - Part 1 : Threads" href="http://www.baptiste-wicht.com/2010/05/java-concurrency-part-1-threads/" target="_blank">create threads</a> and <a title="Java Concurrency - Part 2 : Manipulate threads" href="http://www.baptiste-wicht.com/2010/05/java-concurrency-part-2-manipulate-threads/" target="_blank">manipulate them</a>, it's time to go to most important things : synchronization.</p>
<p>Synchronization is a way to make some code thread safe. A code that can be accessed by multiple threads must be made thread safe. Thread Safe describe some code that can be called from multiple threads without corrupting the state of the object or simply doing the thing the code must do in right order.</p>
<p>For example, we can take this little class :</p>
<p>[java]public class Example {
    private int value = 0;    </p>
<div class="code"><pre><span class="n">public</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>It's really simple and works well with one thread, but absolutely not with multiple threads. An increment like this is not a simple action, but three actions :</p>
<p></p><ul>
    <li>Read the current value of "value"</li>
    <li>Add one to the current value</li>
    <li>Write that new value to "value"</li>
</ul>
<p>Normally, if you have two threads invoking the getNextValue(), you can think that the first will get 1 and the next will get 2, but it is possible that the two threads get the value 1. Imagine this situation :</p>
<p>Thread 1 : read the value, get 0, add 1, so value = 1</p>
<p>Thread 2 : read the value, get 0, add 1, so value = 1</p>
<p>Thread 1 : write 1 to the field value and return 1</p>
<p>Thread 2 : write 1 to the field value and return 1</p>
<p>These situations come from what we call interleaving. Interleaving describe the possible situations of several threads executing some statements. Only for three operations and two threads, there is a lot of possible interleavings.</p>
<p>So we must made the operations atomic to works with multiple threads. In Java, the first way to make that is to use a lock. All Java objects contains an intrinsic locks, we'll use that lock to make methods or statement atomic. When a thread has a lock, no other thread can acquire it and must wait for the first thread to release the lock. To acquire the lock, you have to use the synchronized keyword to automatically acquire and release a lock for a code. You can add the synchronized keyword to a method to acquire the lock before invoking the method and release it after the method execution. You can refactor the getNextValue() method using the synchronized keyword :</p>
<p>[java]public class Example {
    private int value = 0;    </p>
<div class="code"><pre><span class="n">public</span> <span class="n">synchronized</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>With that, you have the guarantee that only thread can execute the method at the same time. The used lock is the intrinsic lock of the instance. If the method is static, the used lock is the Class object of Example. If you have two methods with the synchronized keyword, only one method of the two will be executed at the same time because the same lock is used for the two methods. You can also write it using a synchronized block :</p>
<p>[java]public class Example {
    private int value = 0;</p>
<div class="code"><pre><span class="n">public</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">synchronized</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>This is exactly the same as using the synchronized keyword on the method signature. Using synchronized blocks, you can choose the lock to block on. By example, if you don't want to use the intrinsic lock of the current object but an other object, you can use an other object just as a lock :</p>
<p>[java]public class Example {
    private int value = 0;</p>
<div class="code"><pre><span class="n">private</span> <span class="n">final</span> <span class="n">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">();</span>

<span class="n">public</span> <span class="kt">int</span> <span class="nf">getNextValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>The result is the same but has one difference, the lock is internal to the object so no other code can use the lock. With complex classes, it not rare to use several locks to provide thread safety on the class.</p>
<p>There is an other issue with multiple threads : the visibility of the variables. This seems when a change made by a thread is visible by an other thread. For performance improvements, the Java compiler and virtual machines can made some improvements using registers and cache. By default, you have no guarantee that a change made by a thread is visible to an other thread. To make a change visible to an other thread, you must use synchronized blocks to ensure visibility of the change. You must use synchronized blocks for the read and for the write of the shared values. You must make that for every read/write of a value shared between multiple threads.</p>
<p>You can also use the volatile keyword on the field to ensure the visibility of read/write between multiple threads. The volatile keyword ensure only visibility, not atomicity. The synchronized blocks ensure visibility and atomicity. So you can use the volatile keyword on fields that doesn't need atomicity (if you make only read and write to the field without depending on the current value of the field by example).</p>
<p>You can also note that this simple example can be solved using AtomicInteger, but that will be covered later in an other part of the posts.</p>
<p>Pay attention that trying to solve thread safety on a problem can add new issues of deadlock. By example, if thread A owns the lock 1 and are waiting for the lock 2 and if lock 2 is acquired by thread B who waits on lock 1, there is a deadlock. Your program is dead. So you have to pay great attention to the locks.</p>
<p>There is several rules that we must keep in mind when using locks :</p>
<ol>
    <li>Every mutable fields shared between multiple threads must be guarded with a lock or made volatile, if you only need visibility</li>
    <li>Synchronize only the operations that must synchronized, this improve the performances. But don't synchronize too few operations. Try to keep the lock only for short operations.</li>
    <li>Always know which locks are acquired and when there are acquired and by which thread</li>
    <li>An immutable object is always thread safe</li>
</ol>

<p>Here we are, I hope that this post helps you to understand thread safety and how to achieve it using intrinsic locks. In the next posts, we'll see another synchronization methods.</p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/08/java-concurrrency-synchronization-locks.html#disqus_thread" data-disqus-identifier="cache/posts/2010/08/java-concurrrency-synchronization-locks.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/08/file-copy-benchmark-updates-once-again.html" class="u-url">Java File Copy Benchmark Updates (once again)</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-08-25T07:26:11+00:00">2010-08-25 07:26</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>I've made another updates to my file copy benchmark.</p>
<p>First of all, I used my <a title="Utility class to create graphs of benchmark results" href="http://www.baptiste-wicht.com/2010/08/generate-graphs-benchmarks-easily/" target="_blank">little utility class to automatically create the graphs</a>. The graph are a little less clean, but I spare a lot of time not creating them myself.</p>
<p>Then, I've also made some corrections on the code :</p>
<p></p><ul>
    <li>I''ve used a buffer size of 8192 instead of 4096</li>
    <li>I've made some corrections using the channels because the old code can forgot to write some portions of the file</li>
    <li>I used allocateDirect() instead of allocate() for the ByteBuffer.</li>
</ul>
<p>And I've added a new method using Java 7 : Path.copyTo(Path path).</p>
<p>So the new results are all based on a Java 7 Virtual Machine.</p>
<p>You'll find all the new informations and result, on the original post : <a title="Java File Copy Benchmark" href="http://www.baptiste-wicht.com/2010/08/file-copy-in-java-benchmark/" target="_self">File Copy in Java - Benchmark</a></p>
<p>I hope this new informations will interest you.</p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/08/file-copy-benchmark-updates-once-again.html#disqus_thread" data-disqus-identifier="cache/posts/2010/08/file-copy-benchmark-updates-once-again.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2010/08/java-7-try-with-resources-statement.html" class="u-url">Java 7 : The new try-with-resources statement</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2010-08-24T07:30:53+00:00">2010-08-24 07:30</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>From the build 105, the compiler and runtime of Java 7 Releases have support for the new form of try : try-with-resources, also called ARM (Automatic Resource Management) blocks. </p>
<p>This new statement make working with streams and all kind of closeable resources easier. By example, in Java, you can have this kind of code : </p>
<p>[java]private static void customBufferStreamCopy(File source, File target) {
    InputStream fis = null;
    OutputStream fos = null;
    try {
        fis = new FileInputStream(source);
        fos = new FileOutputStream(target);</p>
<div class="code"><pre>    <span class="n">byte</span><span class="p">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">new</span> <span class="n">byte</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">fis</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fos</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">();</span>
<span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fis</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fos</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>}</p>
<p>private static void close(Closeable closable) {
    if (closable != null) {
        try {
            closable.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}[/java]</p>
<p>A little bit heavy, isn't it ? This is only an example, here the management of exceptions is not good. </p>
<p>So let's use try-with-resources statement to simplify this code, who becomes : </p>
<p>[java]private static void customBufferStreamCopy(File source, File target) {
    try (InputStream fis = new FileInputStream(source);
        OutputStream fos = new FileOutputStream(target)){</p>
<div class="code"><pre>    <span class="n">byte</span><span class="p">[]</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">new</span> <span class="n">byte</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">fis</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fos</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>}[/java]</p>
<p>A lot cleaner, no ? With that code, the resources are automatically closed after the try. In the try resources list, you can declare several resources, but all these resources must implement the java.lang.AutoCloseable interface. </p>
<p>If you want more informations, about this new statement read <a target="_blank" href="http://blogs.sun.com/darcy/entry/project_coin_updated_arm_spec">try-with-resources specifications</a>. </p></div>
        </div>
            
        
    <p>
        <a href="posts/2010/08/java-7-try-with-resources-statement.html#disqus_thread" data-disqus-identifier="cache/posts/2010/08/java-7-try-with-resources-statement.html">Comments</a>


        </p></article>
    
        <div>
        <ul class="pager">
            <li class="previous">
                <a href="index-12.html" rel="prev">← Newer posts</a>
            </li>
            <li class="next">
                <a href="index-10.html" rel="next">Older posts →</a>
            </li>
        </ul>
        </div>

    
        
       <script>var disqus_shortname="nikolademo";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>


	


        </div>
        <!--End of body content-->

        <footer>
            Contents © 2014         <a href="mailto:baptistewicht@gmail.com">Baptiste Wicht</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/88x31.png"></a>
        </footer>
    </div>
</div>


            <script src="assets/js/all-nocdn.js" type="text/javascript"></script>


    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul><li><a class="addthis_button_facebook"></a>
</li><li><a class="addthis_button_google_plusone_share"></a>
</li><li><a class="addthis_button_linkedin"></a>
</li><li><a class="addthis_button_twitter"></a>
</li></ul>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    

<script type="text/javascript" src="assets/js/tipuesearch_set.js"></script>
<script type="text/javascript" src="assets/js/tipuesearch.js"></script>
<script type="text/javascript">
$(document).ready(function() {
  $('#tipue_search_input').tipuesearch({
      'mode': 'json',
      'contentLocation': '/assets/js/tipuesearch_content.json',
      'showUrl': false
  });
});
</script>


</body></html>