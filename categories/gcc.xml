<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>@Blog("Baptiste Wicht") (gcc)</title><link>http://www.baptiste-wicht.com/</link><description></description><atom:link href="http://www.baptiste-wicht.com/categories/gcc.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 16 Mar 2014 19:02:05 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>GCC 4.7 vs CLang 3.1 on eddic</title><link>http://www.baptiste-wicht.com/posts/2012/11/gcc-4-7-clang-3-1-eddic.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/11/eddic-compiles-with-clang-3-1/" title="eddic compiles with CLang 3.1"&gt;Now that eddic can be compiled with CLang&lt;/a&gt;, I wanted to compare the differences in compilation time and in performance of the generated executable between those two compilers. The tests are done using GCC 4.7.2 and CLang 3.1 on Gentoo.
&lt;h3&gt;Compilation Time&lt;/h3&gt;
&lt;p&gt;The first thing that I tested has been the compilation time of the two compilers to compile eddic with different flags. I tested the compilation in debug mode and with -O2 and -O3.&lt;/p&gt;
&lt;p&gt;[bar_chart width="400px" height="300px" title="Compilation Time - Less is better" h_title="Options" v_title="Seconds" scale_button="true"]
          ['Options', 'GCC', 'CLang'],
          ['-g',  234.59,   119.59],
          ['-O2',  273.02,   178.22],
          ['-O3',  276.87,   183.78],
[/bar_chart]&lt;/p&gt;
&lt;p&gt;The most interesting fact in these results is that CLang is much faster than GCC. It takes twice less times to compile eddic with CLang in debug mode than with GCC. The impact on optimizations on CLang's compilation is also more important than on GCC. For both compilers, -O3 does not seems to add a lot of overhead.&lt;/p&gt;
&lt;h3&gt;Runtime performance&lt;/h3&gt;

&lt;p&gt;Then, I tested the performance of the generated executable. I tested it on three things, the whole test suite and two test cases that I know are the slowest for the EDDI Compiler. For each case, I took the slowest value of 5 consecutive executions. &lt;/p&gt;
&lt;p&gt;[bar_chart width="600px" height="400px" title="Runtime Performance - Less is better" h_title="Options" v_title="Seconds" scale_button="true"]
          ['Compiler', 'testsuite', 'assembly', 'linked_list'],
          ['GCC -O2',  6.58,   1.2, 0.51],
          ['GCC -O3',  6.59,   1.2, 0.5],
          ['CLang -O2',  6.74,   1.2, 0.49],
          ['CLang -O3',  6.58,   1.2, 0.49],
[/bar_chart]&lt;/p&gt;
&lt;p&gt;The difference are very small. In -02, GCC performs a bit better, but in -O3, the performance are equivalent. I was a bit disappointed by the results, because I thought that there would be higher differences. It seems that CLang is not as far from GCC that some people would like to say. It also certainly depends on the program being compiled. &lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;It is clear that CLang is much faster than GCC to compile eddic. Moreover, the performance of the generated executable are very similar. &lt;/p&gt;
&lt;p&gt;I will continue to use CLang as my development compiler and switches between the two when I'm doing performance benchmarking. I will try to update the benchmark once new versions of GCC / CLang are available. &lt;/p&gt;&lt;/div&gt;</description><category>Benchmarks</category><category>CLang</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>gcc</category><category>Performances</category><guid>http://www.baptiste-wicht.com/posts/2012/11/gcc-4-7-clang-3-1-eddic.html</guid><pubDate>Mon, 12 Nov 2012 09:28:44 GMT</pubDate></item><item><title>eddic compiles with CLang 3.1</title><link>http://www.baptiste-wicht.com/posts/2012/11/eddic-compiles-with-clang-3-1.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I finally added support for compiling eddic with LLVM CLang 3.1 !&lt;/p&gt;
&lt;p&gt;The current development version can be completely compiled with CLang. Starting with the version 1.1.4, all versions of eddic will be support GCC and CLang. &lt;/p&gt;
&lt;p&gt;The changes have not been as painful as I first thought. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;The main problem that I has was about a static const variable of a class that had no user-constructor. GCC allows that, but it is not standard compliant and CLang was complaining. &lt;/li&gt;
    &lt;li&gt;Another problem that I encountered was about the used of bit flags and Template Meta Programming. I simplified that by the use of a simple type traits and it worked. I don't really know why this does not worked at first. &lt;/li&gt;
    &lt;li&gt;The remaining effort was to fix the several warnings that CLang had. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLang also fixed a bug in my code with a warning on a assignment that was not supposed to be an assignment, thanks CLang. &lt;/p&gt;
&lt;p&gt;The most interesting fact about CLang is that &lt;strong&gt;is it twice faster to build eddic than GCC&lt;/strong&gt;. I think I'm gonna use it during development to fasten the compile time. Moreover, even if I only worked two days with it, it seems that the error messages are indeed better than the GCC's ones. &lt;/p&gt;
&lt;p&gt;I haven't tried to compare the performances of eddic in both cases, but I will do that in the future, soon after the 1.1.4 version is released. &lt;/p&gt;
&lt;p&gt;I tried the CLang static analyzer on eddic but it didn't found any bugs. Moreover, it crashed on several of my files. I didn't found why for now, but I will continue to investigate, perhaps I'm not using it correctly. &lt;/p&gt;
&lt;p&gt;I expect to publish the next version of eddic in the next two weeks. This version has much more improvements that I thought at first and I have less time to work now that &lt;a href="http://www.baptiste-wicht.com/2012/09/back-in-berkeley-california/" title="Back in Berkeley, California" target="_blank"&gt;I'm working on my Master thesis&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;More informations on CLang: &lt;a href="http://clang.llvm.org/" title="CLang official site"&gt;The official site&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>CLang</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>gcc</category><category>Linux</category><guid>http://www.baptiste-wicht.com/posts/2012/11/eddic-compiles-with-clang-3-1.html</guid><pubDate>Thu, 01 Nov 2012 09:11:05 GMT</pubDate></item><item><title>Back in Berkeley, California</title><link>http://www.baptiste-wicht.com/posts/2012/09/back-in-berkeley-california.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I arrived yesterday to Berkeley, California.&lt;/p&gt;
&lt;p&gt;Just like I did my Bachelor thesis in Lawrence Berkeley National Laboratory (LBNL), I will do my Master Thesis there too. The thesis will last a bit less than a semester.&lt;/p&gt;
&lt;p&gt;During my Master Thesis I will try to use profiling samples from the Linux perf tools in GCC or Clang to optimize processor cache usage (avoid cache and page faults).&lt;/p&gt;
&lt;p&gt;I will try to publish some posts about that during the semester if I have time.&lt;/p&gt;&lt;/div&gt;</description><category>Compilers</category><category>gcc</category><category>Others</category><category>Personal</category><category>The site</category><guid>http://www.baptiste-wicht.com/posts/2012/09/back-in-berkeley-california.html</guid><pubDate>Thu, 13 Sep 2012 10:35:43 GMT</pubDate></item><item><title>Install the Insight Debugger on Linux Mint (works for Ubuntu too)</title><link>http://www.baptiste-wicht.com/posts/2012/01/install-insight-debugger-linux-mint-ubuntu.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Insight is a very good debugger based on gdb. I prefer it over ddd or kdbg as I find it clearer and easier to use. Moreover, this debugger is also the one used in the book &lt;strong&gt;Assembly language Step by Step, for Linux&lt;/strong&gt;. However, Insight has been removed from Debian packages already more than a year ago. &lt;/p&gt;
&lt;p&gt;But, thanks to SevenMachines, a PPA repository is available to install it on Linux Mint (works also on Ubuntu and Ubuntu-based Linux distributions). &lt;/p&gt;
&lt;p&gt;To add the repository to your apt sources, add the following lines to the /etc/apt/sources.list file:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;deb http://ppa.launchpad.net/sevenmachines/dev/ubuntu natty main 
&lt;p&gt;deb-src http://ppa.launchpad.net/sevenmachines/dev/ubuntu natty main &lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;and update your apt sources: &lt;/p&gt;
&lt;p&gt;[bash]sudo apt-get update[/bash]&lt;/p&gt;
&lt;p&gt;Then you can install insight: &lt;/p&gt;
&lt;p&gt;[bash]sudo apt-get install insight[/bash]&lt;/p&gt;
&lt;p&gt;And now you are ready to use Insight as your debugger. &lt;/p&gt;
&lt;p&gt;If you don't trust this PPA repository, you can also try it to install it from the sources (http://sources.redhat.com/insight/), but doesn't seem to very simple to install it. I wasn't able to build it on my Linux Mint 12. &lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Assembly</category><category>C++</category><category>gcc</category><category>Linux</category><category>Mint</category><category>Tools</category><category>Ubuntu</category><guid>http://www.baptiste-wicht.com/posts/2012/01/install-insight-debugger-linux-mint-ubuntu.html</guid><pubDate>Thu, 26 Jan 2012 09:28:41 GMT</pubDate></item><item><title>Diploma Thesis : Inlining Assistance for large-scale object-oriented applications</title><link>http://www.baptiste-wicht.com/posts/2011/10/diploma-thesis-inlining-assistance-for-large-scale-object-oriented-applications.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;One month ago, my diploma thesis has been accepted and I got my Bachelor of Science in Computer Science.&lt;/p&gt;
&lt;p&gt;I made my diploma thesis at Lawrence Berkeley National Laboratory, Berkeley, California. I was in the team responsible of the developmenet of the ATLAS Software for the LHC in Cern. The title of my thesis is &lt;strong&gt;Inlining Assistance for large-scale object-oriented applications&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The goal of this project was to create a C++ analyzer to find the best functions and call sites to inline. The input of the analyzer is a call graph generated by CallGrind of the Valgrind project.&lt;/p&gt;
&lt;p&gt;The functions and call sites to inline are computed using a heuristic, called the temperature. This heuristic is based on the cost of calling the given function, the frequency of calls and the size of the function. The cost of calling a function is based on the number of parameters, the virtuality of the function and the shared object the function is located in.&lt;/p&gt;
&lt;p&gt;The analyzer is also able to find clusters of call sites. A cluster is a set of hot call sites related to each other. It can also finds the functions that should be moved from one library to the other or the function that should not be virtual by testing the use of each function in a class hierarchy.&lt;/p&gt;
&lt;p&gt;To achieve this project, it has been necessary to study in details how a function is called on the Linux platform. The inlining optimization has also been studied to know what were the advantages and the problems of this technique.&lt;/p&gt;
&lt;p&gt;To retrieve the information about the sizes and the virtuality of the function, it has been necessary to read the shared libraries and executables files. For that, we used &lt;em&gt;libelf&lt;/em&gt;. The virtuality of a function is calculated by reading each virtual table and searching for the function in the virtual tables content.&lt;/p&gt;
&lt;p&gt;The graph manipulation is made by the &lt;em&gt;Boost Graph Library&lt;/em&gt;. As it was an advanced library, it has helped me improving my skills in specific topics like templates, traits or Template Metaprogramming.&lt;/p&gt;
&lt;p&gt;The analyzer is able to run on the Linux platform on any program that has been compiled using gcc.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;We have tested the analyzer on the CLang compiler and have been able to obtain these results :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/wp-content/uploads/2011/09/Results.png"&gt;&lt;img class="size-medium wp-image-1359" title="Results on CLang" src="http://www.baptiste-wicht.com/wp-content/uploads/2011/09/Results-300x203.png" alt="Results on CLang" width="300" height="203"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cluster 1 and 2 indicates that we have inlined the first, respectively the second, cluster. Callsites_5 indicates that the first five call sites have been inlined and Functions_3 indicates that we inlined the first three functions. As we can see, the results are not really impressive, but we have only done inlining. Moreover, in some large applications, even little savings are really interesting. For example, in the ATLAS software, 1% of saving represents 100K$/year.&lt;/p&gt;
&lt;p&gt;Here is the base outline of my work:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Analysis&lt;/strong&gt; : Function Call, Inlining, Compiler Inlining&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Information Extraction&lt;/strong&gt; : Graph manipulation, parsing object files&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Information analysis&lt;/strong&gt; : Heuristc, library issues, clustering, virtual hierarchy issues&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Design&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Tests&lt;/strong&gt; : Tests on CLang, Tests on ATLAS&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Performance analysis&lt;/strong&gt; : Performance of the analyzer&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Refactorings&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Problems&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Tools&lt;/strong&gt; : Application used during the project&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;You can download a PDF version of my thesis here : &lt;strong&gt;&lt;a href="http://www.baptiste-wicht.com/wp-content/uploads/2011/09/report.pdf"&gt;Inlining Assistance for large-scale object-oriented applications&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Boost</category><category>C++</category><category>C++</category><category>Compilers</category><category>gcc</category><category>Linux</category><category>Optimization</category><category>Performances</category><category>Personal</category><guid>http://www.baptiste-wicht.com/posts/2011/10/diploma-thesis-inlining-assistance-for-large-scale-object-oriented-applications.html</guid><pubDate>Mon, 03 Oct 2011 08:44:17 GMT</pubDate></item><item><title>How to install a specific version of GCC on Ubuntu 11.04 (natty)</title><link>http://www.baptiste-wicht.com/posts/2011/06/install-specific-version-gcc-ubuntu.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Sometimes you need to install a specific version of gcc for some reasons, for example when you need to have the same compiler version as the one used by your team. &lt;/p&gt;
&lt;p&gt;In that, the package manager doesn't help because not every version of gcc is packaged in every version of Ubuntu. So you must install it by hand and it can take a little time and there is some things that has to be done in order to work. &lt;/p&gt;
&lt;p&gt;I'm talking here of Ubuntu 11.04 (natty), because this is the version I installed Ubuntu on. This procedure will certainly work but you could have a problem with some dependencies that are installed in natty and not in your version or in the contrary have a dependency already installed. &lt;/p&gt;
&lt;p&gt;So this article will detail every step to install a specific version of gcc &lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Personally, I've made the whole installation from the folder ~/dev/ . You can use this folder or use another one, but I recommend to you use an empty folder for that. When I will talk about the installation, I will refer to this folder.  &lt;/p&gt;
&lt;p&gt;Note 1 : Because I wanted this new gcc to be my main compiler, I've directly installed everything in /usr/local/. If you want to install it in a specific folder, you can use the --prefix=FOLDER option fo the ./configure command. If you make so, you don't have to use the sudo before the make install unless you choose another directory where you don't have the right to write in. &lt;/p&gt;
&lt;p&gt;Note 2 : If you have a multicore processor, you should use the -jX option with make where X is your number of core (you can make it +1). &lt;/p&gt;
&lt;p&gt;Building gcc requires several libraries that are not installed by default. Let's start with GNU Multiple Precision Library (GMP). You can download the latest version (5.0.2 now) here : http://gmplib.org/ . Decompress the library in your installation folder and then use the followings commands : &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;cd gmp_dir
&lt;p&gt;./configure&lt;/p&gt;
&lt;p&gt;make&lt;/p&gt;
&lt;p&gt;make check&lt;/p&gt;
&lt;p&gt;sudo make install&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;You should have a message indicating that the libraries have been installed in your folder. &lt;/p&gt;
&lt;p&gt;After that, you can install the GNU MPFR library (version 3.0.1 now), available here : http://www.mpfr.org/mpfr-current/#download . Unzip the file in your installation folder and type the following commands : &lt;/p&gt;
&lt;pre&gt;cd mpfr_dir

./configure

make

make check

sudo make install&lt;/pre&gt;

&lt;p&gt;You should see the same confirmation message than for the last installation. Then, you can install the last library, MPC (version 0.9 now), that you can download here : http://www.multiprecision.org/index.php?prog=mpc&amp;amp;page=download . Once again, unzip the file and your installation folder and launch the same commands : &lt;/p&gt;
&lt;pre&gt;cd mpfr_dir

./configure

make

make check

sudo make install&lt;/pre&gt;

&lt;p&gt;Same confirmation message. &lt;/p&gt;
&lt;p&gt;To prepare the installation of gcc, you have to type the given two commands : &lt;/p&gt;
&lt;pre&gt;export C_INCLUDE_PATH=/usr/include/x86_64-linux-gnu

export CPLUS_INCLUDE_PATH=/usr/include/x86_64-linux-gnu &lt;/pre&gt;

&lt;p&gt;Here we are, you are ready to install gcc. Download the version you want to install here : http://gcc.gnu.org/releases.html and extract it on your installation folder. &lt;/p&gt;
&lt;p&gt;Note : for those who have installed the first three libraries in different folder you have to indicate to ./configure where they are using the given command line options : --with-gmp=FOLDER, --with-mpfr=FOLDER and --with-mpg=FOLDER&lt;/p&gt;
&lt;p&gt;Note : I installed gcc for C and C++, if you want to select other languages just tune the --enable-languages option and if you want every language, just remove this option. &lt;/p&gt;
&lt;p&gt;Then create a directory on the same level as gcc sources dir : &lt;/p&gt;
&lt;pre&gt;cd installation_folder

mkdir build

cd build&lt;/pre&gt;

&lt;p&gt;and now from this folder, we can install everything : &lt;/p&gt;
&lt;pre&gt;../gcc_dir/configure --enable-languages=c,c++

make

sudo make install&lt;/pre&gt;

&lt;p&gt;Now it's time to take a coffee (or even two), because the full compilation can take a lot of time. &lt;/p&gt;
&lt;p&gt;When the compilation is finished, you can try it with this command &lt;/p&gt;
&lt;pre&gt;gcc --version&lt;/pre&gt;

&lt;p&gt;that should give you the version you just installed. If it is not the case, verify that you did every step and if it's the case, take a look at the &lt;a href="http://gcc.gnu.org/install/"&gt;official installation guide&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>C++</category><category>gcc</category><category>Ubuntu</category><category>Ubuntu</category><guid>http://www.baptiste-wicht.com/posts/2011/06/install-specific-version-gcc-ubuntu.html</guid><pubDate>Fri, 17 Jun 2011 08:18:29 GMT</pubDate></item></channel></rss>