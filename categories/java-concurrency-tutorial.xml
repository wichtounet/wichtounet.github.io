<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>@Blog("Baptiste Wicht") (Java Concurrency Tutorial)</title><link>http://wichtounet.github.io/</link><description></description><atom:link href="http://wichtounet.github.io/categories/java-concurrency-tutorial.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 16 Mar 2014 20:41:00 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Java Concurrency - Part 7 : Executors and thread pools</title><link>http://wichtounet.github.io/posts/2010/09/java-concurrency-part-7-executors-and-thread-pools.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Let's start with a new post in the Java concurrency series.&lt;/p&gt;
&lt;p&gt;This time we'll learn how to start cleanly new threads and to manage thread pools. In Java, if you have a Runnable like this :&lt;/p&gt;
&lt;p&gt;[java]Runnable runnable = new Runnable(){
   public void run(){
      System.out.println("Run");
   }
}[/java]&lt;/p&gt;
&lt;p&gt;You can easily run it in a new thread :&lt;/p&gt;
&lt;p&gt;[java]new Thread(runnable).start();[/java]&lt;/p&gt;
&lt;p&gt;This is very simple and clean, but what if you've several long running tasks that you want to load in parralel and then wait for the completion of all the tasks, it's a little bit harder to code and if you want to get the return value of all the tasks it becomes really difficult to keep a good code. But like for almost any problems, Java has a solution for you, the Executors. This simple class allows you to create thread pools and thread factories.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;A thread pool is represented by an instance of the class ExecutorService. With an ExecutorService, you can submit task that will be completed in the future. Here are the type of thread pools you can create with the Executors class :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;Single Thread Executor&lt;/strong&gt; : A thread pool with only one thread. So all the submitted task will be executed sequentially. Method : &lt;em&gt;Executors.newSingleThreadExecutor()&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Cached Thread Pool&lt;/strong&gt; : A thread pool that create as many threads it needs to execute the task in parralel. The old available threads will be reused for the new tasks. If a thread is not used during 60 seconds, it will be terminated and removed from the pool. Method : &lt;em&gt;Executors.newCachedThreadPool()&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Fixed Thread Pool&lt;/strong&gt; : A thread pool with a fixed number of threads. If a thread is not available for the task, the task is put in queue waiting for an other task to ends. Method : &lt;em&gt;Executors.newFixedThreadPool()&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Scheduled Thread Pool&lt;/strong&gt; : A thread pool made to schedule future task. Method : &lt;em&gt;Executors.newScheduledThreadPool()&lt;/em&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Single Thread Scheduled Pool&lt;/strong&gt; : A thread pool with only one thread to schedule future task. Method : &lt;em&gt;Executors.newSingleThreadScheduledExecutor()&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once you have a thread pool, you can submit task to it using the different submit methods. You can submit a Runnable or a Callableto the thread pool. The method return a Future representing the future state of the task. If you submitted a Runnable, the Future object return null once the task finished.&lt;/p&gt;
&lt;p&gt;By example, if you have this Callable :&lt;/p&gt;
&lt;p&gt;[java]private final class StringTask implements Callable&amp;lt;String&amp;gt; {
   public String call(){
      //Long operations&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"Run"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
}[/java]&lt;/p&gt;
&lt;p&gt;If you want to execute that task 10 times using 4 threads, you can use that code :&lt;/p&gt;
&lt;p&gt;[java]ExecutorService pool = Executors.newFixedThreadPool(4);&lt;/p&gt;
&lt;p&gt;for(int i = 0; i &amp;lt; 10; i++){
   pool.submit(new StringTask());
}[/java]&lt;/p&gt;
&lt;p&gt;But you must shutdown the thread pool in order to terminate all the threads of the pool :&lt;/p&gt;
&lt;p&gt;[java]pool.shutdown();[/java]&lt;/p&gt;
&lt;p&gt;If you don't do that, the JVM risk to not shutdown because there is still threads not terminated. You can also force the shutdown of the pool using shutdownNow, with that the currently running tasks will be interrupted and the tasks not started will not be started at all.&lt;/p&gt;
&lt;p&gt;But with that example, you cannot get the result of the task. So let's get the Future objects of the tasks :&lt;/p&gt;
&lt;p&gt;[java]ExecutorService pool = Executors.newFixedThreadPool(4);&lt;/p&gt;
&lt;p&gt;List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futures = new ArrayList&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt;(10);&lt;/p&gt;
&lt;p&gt;for(int i = 0; i &amp;lt; 10; i++){
   futures.add(pool.submit(new StringTask()));
}&lt;/p&gt;
&lt;p&gt;for(Future&amp;lt;String&amp;gt; future : futures){
   String result = future.get();&lt;/p&gt;
&lt;p&gt;//Compute the result
}&lt;/p&gt;
&lt;p&gt;pool.shutdown();[/java]&lt;/p&gt;
&lt;p&gt;But this code is a bit complicated. And there is a disadvantage. If the first task takes a long time to compute and all the other tasks ends before the first, the current thread cannot compute the result before the first task ends. Once again, Java has the solution for you, CompletionService.&lt;/p&gt;
&lt;p&gt;A CompletionService is a service that make easier to wait for result of submitted task to an executor. The implementation is ExecutorCompletionService who's based on an ExecutorService to work. So let's try :&lt;/p&gt;
&lt;p&gt;[java]ExecutorService threadPool = Executors.newFixedThreadPool(4);&lt;/p&gt;
&lt;p&gt;CompletionService&amp;lt;String&amp;gt; pool = new ExecutorCompletionService&amp;lt;String&amp;gt;(threadPool);&lt;/p&gt;
&lt;p&gt;for(int i = 0; i &amp;lt; 10; i++){
   pool.submit(new StringTask());
}&lt;/p&gt;
&lt;p&gt;for(int i = 0; i &amp;lt; 10; i++){
   String result = pool.take().get();&lt;/p&gt;
&lt;p&gt;//Compute the result
}&lt;/p&gt;
&lt;p&gt;threadPool.shutdown();[/java]&lt;/p&gt;
&lt;p&gt;With that, you have the result in the order they are completed and you don't have to keep a collection of Future.&lt;/p&gt;
&lt;p&gt;Here we are, you have the tools in hand to launch tasks in parralel using performing thread pools. Using Executors, ExecutorService and CompletionService you can create complex algorithm using several taks. With that tools, it's really easy to change the number of threads performing in parralel or adding more tasks without changing a lot of code.&lt;/p&gt;
&lt;p&gt;I hope that this post will help you to write better concurrent code.&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>Java</category><category>Java Concurrency Tutorial</category><guid>http://wichtounet.github.io/posts/2010/09/java-concurrency-part-7-executors-and-thread-pools.html</guid><pubDate>Wed, 15 Sep 2010 07:17:27 GMT</pubDate></item><item><title>Java Concurrency - Part 6 : Atomic Variables</title><link>http://wichtounet.github.io/posts/2010/09/java-concurrency-atomic-variables.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;When a data (typically a variable) can be accessed by several threads, you must synchronize the access to the data to ensure visibility and correctness. &lt;/p&gt;
&lt;p&gt;By example, if you have a simple counter (yes, once again) : &lt;/p&gt;
&lt;p&gt;[java]public class Counter {
    private int value;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getPreviousValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;This class works really well in single-threaded environment, but don't work at all when several threads access the same Counter instance. If you don't know why, read &lt;a target="_blank" href="http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/"&gt;this post about synchronization&lt;/a&gt;. You can solve the problem using synchronized at method level : &lt;/p&gt;
&lt;p&gt;[java]public class SynchronizedCounter {
    private int value;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getPreviousValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;This class now works well. But locking is not a lightweight mechanism and have several disadvantages. When several threads try to acquire the same lock, one or more threads will be suspended and they will be resumed later. When the critical section is little, the overhead is really heavy especially when the lock is often acquired and there is a lot of contention. Another disadvantage is that the other threads waiting of the lock cannot do something else during waiting and if the thread who has the lock is delayed (due to a page fault or the end of the time quanta by example), the others threads cannot take their turn. &lt;/p&gt;
&lt;p&gt;So how to do to avoid this disadvantages ? We must use non-blocking algorithms. This algorithms don't use blocking mechanisms and by that fact are more scalable and performing. These algorithms use low-level machine instructions which are atomic to ensure the atomicity of higher-level operations. While locking is a pessimistic approach, we can also use optimistic technique to develop algorithms. This time, we'll detect collisions between threads in which case, the operation fails and we do something else (often retrying the same operation).&lt;/p&gt;
&lt;p&gt;The actual processors provide several instructions that simplify greatly the implementation of these non-blocking algorithms, the most-used operation today is the compare-and-swap operation (CAS). This operation takes three parameters, the memory address, the expected current value and the new value. It atomically update the value at the given memory address if the current value is the expected, otherwise it do nothing. In both cases, the operation return the value at the address after the operation execution. So when several threads try to execute the CAS operation, one thread wins and the others do nothing. So the caller can choose to retry or to do something else. We often use this operation to implement another operation, the compare-and-set. This method makes exactly the same things as CAS but return a boolean indicating if the operation succeeded or not. &lt;/p&gt;
&lt;p&gt;Before Java 5.0, this operation was not available directly to developer, but in Java 5.0 several atomic variables (for int, long, boolean and reference values) were added. The int and long versions also supports numeric operations. The JVM compiles these classes with the better operations provided by the hardware machine, CAS or a Java implementation of the operation using a lock. Here are the classes : &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;AtomicInteger&lt;/li&gt;

&lt;li&gt;AtomicLong&lt;/li&gt;

&lt;li&gt;AtomicBoolean&lt;/li&gt;

&lt;li&gt;AtomicReference&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;All these classes supports compare-and-set (via the compareAndSet() method) and other operations (get(), set() and getAndSet()). The setters operations are implemented using compareAndSet. These classes supports multi-threaded access and have a better scalability than synchronizing all the operations. &lt;/p&gt;
&lt;p&gt;Here is how we can rewrite our counter using an AtomicInteger : &lt;/p&gt;
&lt;p&gt;[java]public class AtomicCounter {
    private final AtomicInteger value = new AtomicInteger(0);&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;incrementAndGet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getPreviousValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decrementAndGet&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;The incrementAndGet() and decrementAndGet() methods are two of the numeric operations provided by the AtomicLong and AtomicInteger classes. You also have getAndDecrement(), getAndIncrement(), getAndAdd(int i) and addAndGet(). &lt;/p&gt;
&lt;p&gt;This version is faster than the synchronized one and is also thread safe. &lt;/p&gt;
&lt;p&gt;If you only have the compareAndSet(), here is how we can implement increment() method using it : &lt;/p&gt;
&lt;p&gt;[java]public void increment(AtomicInteger integer){
    while(true){
        int current = integer.get();
        int next = current + 1;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareAndSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;This seems to be complicated, but this is the cost of non-blocking algorithms. When we detect collision, we retry until the operation succeeded. This is the common schema for non-blocking algorithms. &lt;/p&gt;
&lt;p&gt;Here is a thread-safe Stack implemented using AtomicReference : &lt;/p&gt;
&lt;p&gt;[java]public class Stack {
    private final AtomicReference&amp;lt;Element&amp;gt; head = new AtomicReference&amp;lt;Element&amp;gt;(null);&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="n"&gt;newElement&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="n"&gt;oldHead&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;newElement&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;oldHead&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;//Trying to set the new element as the head&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareAndSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldHead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newElement&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="n"&gt;oldHead&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="c1"&gt;//The stack is empty&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldHead&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="n"&gt;newHead&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;oldHead&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;//Trying to set the new element as the head&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareAndSet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldHead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newHead&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;oldHead&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;Element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;It's really more complicated than using synchronized on the two methods but also more performing if there is contention (and often even if there is no contention). &lt;/p&gt;
&lt;p&gt;So this ends this post. To conclude, atomic variables classes are a really good way to implement non-blocking algorithms and moreover are also a very good alternative to volatile variables, because they can provide atomicity and visibility. &lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>Java</category><category>Java Concurrency Tutorial</category><guid>http://wichtounet.github.io/posts/2010/09/java-concurrency-atomic-variables.html</guid><pubDate>Wed, 08 Sep 2010 07:14:18 GMT</pubDate></item><item><title>Java Concurrency - Part 5 : Monitors (Locks and Conditions)</title><link>http://wichtounet.github.io/posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;After seeing &lt;a title="Java Concurrency – Part 4 : Semaphores" href="http://www.baptiste-wicht.com/2010/08/java-concurrency-part-4-semaphores/" target="_blank"&gt;how to synchronize code using semaphores&lt;/a&gt;, we'll see how to do that using &lt;strong&gt;monitors&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Monitors are an other mechanism of concurrent programming. It's a higher level mechanism than semaphores and also more powerful. A monitor is an instance of a class that can be used safely by several threads. All the methods of a monitor are executed with mutual exclusion. So at most one thread can execute a method of the monitor at the same time. This mutual exclusion policy makes easier to work with monitor and to develop the method content of the monitor.&lt;/p&gt;
&lt;p&gt;Monitors have an other feature, the possibility to make a thread waiting for a condition. During the wait time, the thread temporarily gives up its exclusive access and must reacquire it after the condition has been met. You can also signal one or more threads that a condition has been met.&lt;/p&gt;
&lt;p&gt;There is several advantages on using monitors instead of a lower-level mechanisms :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;All the synchronization code is centralized in one location and the users of this code don’t need to know how it’s implemented.&lt;/li&gt;
    &lt;li&gt;The code doesn't depend on the number of processes, it works for as many processes as you want&lt;/li&gt;
    &lt;li&gt;You don’t need to release something like a mutex, so you cannot forget to do it&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When we must describe a monitor, we simple use the &lt;strong&gt;monitor&lt;/strong&gt; keyword and describe the methods as common methods :&lt;/p&gt;
&lt;p&gt;[java]monitor SimpleMonitor {
    public method void testA(){
        //Some code
    }&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;testB&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;To describe a condition variable, we use the &lt;strong&gt;cond&lt;/strong&gt; keyword. A condition variable is a kind of queue of process who are waiting on the same condition. You have several operations available on a condition, the most important is to signal a process waiting to be awaken and to wait on a condition. There are some similarities between signal/wait operations and P and V of semaphores, but this is a little different. The signal operation does nothing if the queue is empty and the wait operation put always the thread in the waiting queue. The process queue is served in a first come, first served mode.   When a thread wakes up after waiting on a condition, it must reacquire the lock before continuing in the code.&lt;/p&gt;
&lt;p&gt;Before going further, we must have more information about the signal operations. When writing monitors, you normally have the choice between several philosophies for the signaling operation :&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Signal &amp;amp; Continue (SC) : The process who signal keep the mutual exclusion and the signaled will be awaken but need to acquire the mutual exclusion before going.&lt;/li&gt;
    &lt;li&gt;Signal &amp;amp; Wait (SW) : The signaler is blocked and must wait for mutual exclusion to continue and the signaled thread is directly awaken and can start continue its operations.&lt;/li&gt;
    &lt;li&gt;Signal &amp;amp; Urgent Wait (SU) : Like SW but the signaler thread has the guarantee than it would go just after the signaled thread&lt;/li&gt;
    &lt;li&gt;Signal &amp;amp; Exit (SX) : The signaler exits from the method directly after the signal and the signaled thread can start directly. This philosophy is not often used.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The available policies depends on the programming language, in Java, there is only one policy available, the SC one.&lt;/p&gt;
&lt;p&gt;In Java there is no keyword to directly create a monitor. To implement a monitor, you must create a new class and use &lt;strong&gt;Lock&lt;/strong&gt; and &lt;strong&gt;Condition&lt;/strong&gt; classes. Lock is the interface is &lt;strong&gt;ReentrantLock&lt;/strong&gt; is the main used implementation, this is the one that we'll learn to use in the current post. To create a ReentrantLock, you have two constructors, a default constructor and a constructor with a boolean argument indicating if the lock is fair or not. A fair lock indicates that the threads will acquire the locks in the order they ask for. Fairness is a little heavier than default locking strategies, so use it only if you need it. To acquire the lock, you just have to use the method &lt;em&gt;lock&lt;/em&gt; and &lt;em&gt;unlock&lt;/em&gt; to release it.&lt;/p&gt;
&lt;p&gt;The explicit locks have the same memory semantics than the synchronized blocks. So the visibility of the changes is guarantee when you use lock()/unlock() blocks.&lt;/p&gt;
&lt;p&gt;So to implement, the monitor example we've seen before, we just need to create a class and use the lock to make the mutual exclusion :&lt;/p&gt;
&lt;p&gt;[java]public class SimpleMonitor {
    private final Lock lock = new ReentrantLock();&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testA&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//Some code&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;testB&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;The person who've already read the other parts of this post set will say that it will be easier to use the synchronized keyword on the two methods. But with synchronized, we will not have the condition variables. If you don't need condition variables but only locking, it will be easier to use the synchronized blocks instead of Locks.&lt;/p&gt;
&lt;p&gt;You can create conditions using the &lt;em&gt;newCondition&lt;/em&gt; method on the lock. A condition is a variable of type &lt;strong&gt;Condition&lt;/strong&gt;. You can make the current thread wait on the condition using the &lt;em&gt;await&lt;/em&gt; method (and its variant with timeout) and you can signal threads using &lt;em&gt;signal&lt;/em&gt; and &lt;em&gt;signalAll&lt;/em&gt; methods. The signalAll methods wakes up all the threads waiting on the condition variable.&lt;/p&gt;
&lt;p&gt;Let's try with a simple common example : A bounded buffer. It's a cyclic buffer with a certain capacity with a start and an end.&lt;/p&gt;
&lt;p&gt;[java]import java.util.concurrent.locks.Condition;&lt;/p&gt;
&lt;p&gt;import java.util.concurrent.locks.Lock;&lt;/p&gt;
&lt;p&gt;import java.util.concurrent.locks.ReentrantLock;&lt;/p&gt;
&lt;p&gt;public class BoundedBuffer {
    private final String[] buffer;
    private final int capacity;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ReentrantLock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Condition&lt;/span&gt; &lt;span class="n"&gt;notFull&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newCondition&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Condition&lt;/span&gt; &lt;span class="n"&gt;notEmpty&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newCondition&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;BoundedBuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;super&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;buffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;deposit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;notFull&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;await&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rear&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;rear&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rear&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;notEmpty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;notEmpty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;await&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;notFull&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;So some explications :&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;The two methods are protected with the lock to ensure mutual exclusion&lt;/li&gt;
    &lt;li&gt;Then we use two conditions variables. One to wait for the buffer to be not empty and an other one to wait for the buffer to be not full.&lt;/li&gt;
    &lt;li&gt;You can see that I have wrapped the await operation on a while loop. This is to avoid signal stealers problem that can occurs when using Signal &amp;amp; Continue&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And that BoundedBuffer can be easily used with several threads with no problems.&lt;/p&gt;
&lt;p&gt;As you can see, you can use monitors to solve a lot of concurrent programming problems and this mechanism is really powerful and performing.&lt;/p&gt;
&lt;p&gt;I hope you found that article interesting and that this set of posts about Java concurrency brings you some stuff about Java.&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>Java</category><category>Java Concurrency Tutorial</category><guid>http://wichtounet.github.io/posts/2010/09/java-concurrency-part-5-monitors-locks-and-conditions.html</guid><pubDate>Mon, 06 Sep 2010 07:13:27 GMT</pubDate></item><item><title>Java Concurrency - Part 4 : Semaphores</title><link>http://wichtounet.github.io/posts/2010/08/java-concurrency-part-4-semaphores.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;We continue in Java Concurrency with the semaphores. Semaphores is also a way to synchronize threads.&lt;/p&gt;
&lt;p&gt;Semaphores are a really simple concept, invented by the famous Dutch computer scientist Edsger Dijkstra. Basically a semaphore is a counter (integer) that allows a thread to get into a critical region if the value of the counter is greater than 0. If it's the case, the counter is decremented by one otherwise, the thread is waiting until it can go. And when the thread go away from the critical region, the counter is incremented by one to allow one more thread to pass the critical region. A semaphore is created with a certain value for its counter. So, you can execute two actions on a semaphore P and V.&lt;/p&gt;
&lt;p&gt;By example, if you have a critical that cannot be executed concurrently, you can use a semaphore :&lt;/p&gt;
&lt;p&gt;[java]sem mutex = new sem(1)&lt;/p&gt;
&lt;p&gt;P(mutex)&lt;/p&gt;
&lt;p&gt;//Critical region&lt;/p&gt;
&lt;p&gt;V(mutex)[/java]&lt;/p&gt;
&lt;p&gt;So you must always call by yourself the P operation before the critical region and V after it. We call a mutex (mutual exclusion) a semaphore with a value of one. So only one thread can enter the region guarded by the semaphore. This is the most used semaphore. The other use of semaphore is to guard a set of resources like database connections or a data pool.&lt;/p&gt;
&lt;p&gt;In Java, a semaphore is created using the java.util.concurrent.Semaphore class. You can create easily :&lt;/p&gt;
&lt;p&gt;[java]Semaphore mutex = new Semaphore(1);&lt;/p&gt;
&lt;p&gt;Semaphore available = new Semaphore(100);[/java]&lt;/p&gt;
&lt;p&gt;The P and V operations are represented using the acquire and release methods. The method acquire can be interrupted if the thread is interrupted. There is an uninterruptible version with the method acquireUninterruptibly(). There is also a third version with the tryAcquire method. This method acquire a permit only if there is one permit available, otherwise, this method return false directly. All the waiting methods have also an overloaded version with a timeout. You can also acquire several permits at once using the permits argument to the different versions of acquire methods.&lt;/p&gt;
&lt;p&gt;A little example with a mutex using the same example as the previous post on Java concurrency :&lt;/p&gt;
&lt;p&gt;[java]public class Example {
    private int value = 0;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Semaphore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;acquire&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;For more informations about Semaphore in Java, the best is to consult &lt;a href="http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Semaphore.html"&gt;the Javadoc of the Semaphore class&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To conclude, semaphores are a powerful ways to solve concurrency problems, but this is not adapted to all problems. If you need only mutual exclusion, &lt;a title="Java Concurrency – Part 3 : Synchronization with intrinsic locks" href="http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/" target="_blank"&gt;synchronized blocks&lt;/a&gt; are a better solutions. The problems with semaphores is that you can forget to call the release method and that can cause deadlock sometimes difficult to find.&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>Java</category><category>Java Concurrency Tutorial</category><guid>http://wichtounet.github.io/posts/2010/08/java-concurrency-part-4-semaphores.html</guid><pubDate>Mon, 30 Aug 2010 07:11:55 GMT</pubDate></item><item><title>Java Concurrency – Part 3 : Synchronization with intrinsic locks</title><link>http://wichtounet.github.io/posts/2010/08/java-concurrrency-synchronization-locks.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;After learning how to &lt;a title="Java Concurrency - Part 1 : Threads" href="http://www.baptiste-wicht.com/2010/05/java-concurrency-part-1-threads/" target="_blank"&gt;create threads&lt;/a&gt; and &lt;a title="Java Concurrency - Part 2 : Manipulate threads" href="http://www.baptiste-wicht.com/2010/05/java-concurrency-part-2-manipulate-threads/" target="_blank"&gt;manipulate them&lt;/a&gt;, it's time to go to most important things : synchronization.&lt;/p&gt;
&lt;p&gt;Synchronization is a way to make some code thread safe. A code that can be accessed by multiple threads must be made thread safe. Thread Safe describe some code that can be called from multiple threads without corrupting the state of the object or simply doing the thing the code must do in right order.&lt;/p&gt;
&lt;p&gt;For example, we can take this little class :&lt;/p&gt;
&lt;p&gt;[java]public class Example {
    private int value = 0;    &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;It's really simple and works well with one thread, but absolutely not with multiple threads. An increment like this is not a simple action, but three actions :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;Read the current value of "value"&lt;/li&gt;
    &lt;li&gt;Add one to the current value&lt;/li&gt;
    &lt;li&gt;Write that new value to "value"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Normally, if you have two threads invoking the getNextValue(), you can think that the first will get 1 and the next will get 2, but it is possible that the two threads get the value 1. Imagine this situation :&lt;/p&gt;
&lt;p&gt;Thread 1 : read the value, get 0, add 1, so value = 1&lt;/p&gt;
&lt;p&gt;Thread 2 : read the value, get 0, add 1, so value = 1&lt;/p&gt;
&lt;p&gt;Thread 1 : write 1 to the field value and return 1&lt;/p&gt;
&lt;p&gt;Thread 2 : write 1 to the field value and return 1&lt;/p&gt;
&lt;p&gt;These situations come from what we call interleaving. Interleaving describe the possible situations of several threads executing some statements. Only for three operations and two threads, there is a lot of possible interleavings.&lt;/p&gt;
&lt;p&gt;So we must made the operations atomic to works with multiple threads. In Java, the first way to make that is to use a lock. All Java objects contains an intrinsic locks, we'll use that lock to make methods or statement atomic. When a thread has a lock, no other thread can acquire it and must wait for the first thread to release the lock. To acquire the lock, you have to use the synchronized keyword to automatically acquire and release a lock for a code. You can add the synchronized keyword to a method to acquire the lock before invoking the method and release it after the method execution. You can refactor the getNextValue() method using the synchronized keyword :&lt;/p&gt;
&lt;p&gt;[java]public class Example {
    private int value = 0;    &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;With that, you have the guarantee that only thread can execute the method at the same time. The used lock is the intrinsic lock of the instance. If the method is static, the used lock is the Class object of Example. If you have two methods with the synchronized keyword, only one method of the two will be executed at the same time because the same lock is used for the two methods. You can also write it using a synchronized block :&lt;/p&gt;
&lt;p&gt;[java]public class Example {
    private int value = 0;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;This is exactly the same as using the synchronized keyword on the method signature. Using synchronized blocks, you can choose the lock to block on. By example, if you don't want to use the intrinsic lock of the current object but an other object, you can use an other object just as a lock :&lt;/p&gt;
&lt;p&gt;[java]public class Example {
    private int value = 0;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getNextValue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;The result is the same but has one difference, the lock is internal to the object so no other code can use the lock. With complex classes, it not rare to use several locks to provide thread safety on the class.&lt;/p&gt;
&lt;p&gt;There is an other issue with multiple threads : the visibility of the variables. This seems when a change made by a thread is visible by an other thread. For performance improvements, the Java compiler and virtual machines can made some improvements using registers and cache. By default, you have no guarantee that a change made by a thread is visible to an other thread. To make a change visible to an other thread, you must use synchronized blocks to ensure visibility of the change. You must use synchronized blocks for the read and for the write of the shared values. You must make that for every read/write of a value shared between multiple threads.&lt;/p&gt;
&lt;p&gt;You can also use the volatile keyword on the field to ensure the visibility of read/write between multiple threads. The volatile keyword ensure only visibility, not atomicity. The synchronized blocks ensure visibility and atomicity. So you can use the volatile keyword on fields that doesn't need atomicity (if you make only read and write to the field without depending on the current value of the field by example).&lt;/p&gt;
&lt;p&gt;You can also note that this simple example can be solved using AtomicInteger, but that will be covered later in an other part of the posts.&lt;/p&gt;
&lt;p&gt;Pay attention that trying to solve thread safety on a problem can add new issues of deadlock. By example, if thread A owns the lock 1 and are waiting for the lock 2 and if lock 2 is acquired by thread B who waits on lock 1, there is a deadlock. Your program is dead. So you have to pay great attention to the locks.&lt;/p&gt;
&lt;p&gt;There is several rules that we must keep in mind when using locks :&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Every mutable fields shared between multiple threads must be guarded with a lock or made volatile, if you only need visibility&lt;/li&gt;
    &lt;li&gt;Synchronize only the operations that must synchronized, this improve the performances. But don't synchronize too few operations. Try to keep the lock only for short operations.&lt;/li&gt;
    &lt;li&gt;Always know which locks are acquired and when there are acquired and by which thread&lt;/li&gt;
    &lt;li&gt;An immutable object is always thread safe&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here we are, I hope that this post helps you to understand thread safety and how to achieve it using intrinsic locks. In the next posts, we'll see another synchronization methods.&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>Java</category><category>Java Concurrency Tutorial</category><guid>http://wichtounet.github.io/posts/2010/08/java-concurrrency-synchronization-locks.html</guid><pubDate>Fri, 27 Aug 2010 07:15:59 GMT</pubDate></item><item><title>Java Concurrency : Part 2 - Manipulate Threads</title><link>http://wichtounet.github.io/posts/2010/05/java-concurrency-part-2-manipulate-threads.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a href="http://www.baptiste-wicht.com/2010/05/java-concurrency-part-1-threads/"&gt;After seeing how to create Threads&lt;/a&gt;, we'll see in this article what we can do to &lt;strong&gt;manipulate Threads&lt;/strong&gt;.
&lt;p&gt;When we've Threads, we can make several operations on the Threads :&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Make the current Thread &lt;strong&gt;sleeping&lt;/strong&gt; during x milliseconds&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Wait&lt;/strong&gt; for an other thread to complete&lt;/li&gt;
    &lt;li&gt;Manage the &lt;strong&gt;priorities&lt;/strong&gt; of Threads and pause a thread to give an other thread the opportunity to run&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Interrupt&lt;/strong&gt; a thread&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We'll now see how to do all these things.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;First and easier, we can make a thread sleeping for a certain number of milliseconds. To do that, the Thread class has a method sleep(long millis). But this method is static, so you can only make the current Thread sleeping. You cannot choose the thread you want to make sleeping, your only choice is the current Thread so :&lt;/p&gt;
&lt;p&gt;[java]Thread.sleep(1000);[/java]&lt;/p&gt;
&lt;p&gt;makes the current Thread sleep during 1000 milliseconds (1 second). But, you have to catch an exception, InterruptedException. This exception occurs if the sleeping thread is interrupted. So you have to do that :&lt;/p&gt;
&lt;p&gt;[java]try {
    Thread.sleep(1000);
} catch (InterruptedException e){
    e.printStackTrace();
}[/java]&lt;/p&gt;
&lt;p&gt;But this not the good way to manage the InterruptedException. We'll see in one moment, how to deal with this exception. &lt;/p&gt;
&lt;p&gt;If you want more precision, you can use the overloaded version of sleep that takes the number of milliseconds plus a certain number of nanoseconds to sleep. The precision of this sleep depends on the system timers and clocks.&lt;/p&gt;
&lt;p&gt;For example, if you want to sleep 1000 milliseconds and 1000 nanoseconds (1 microsecond), you can do like that :&lt;/p&gt;
&lt;p&gt;[java]try {
    Thread.sleep(1000, 1000);
} catch (InterruptedException e){
    e.printStackTrace();
}[/java]&lt;/p&gt;
&lt;p&gt;Here is a little example to test that :&lt;/p&gt;
&lt;p&gt;[java]public class SleepThread {
    public static void main(String[] args) {
        System.out.println("Current time millis : " + System.currentTimeMillis());&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current time millis : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Nano time : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nanoTime&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Nano time : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nanoTime&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;In my computer, this produce this result :&lt;/p&gt;
&lt;pre&gt;Current time millis : 1273959308480

Current time millis : 1273959309480

Nano time : 5878165216075

Nano time : 5878166730976&lt;/pre&gt;

&lt;p&gt;You can see that the sleep of milliseconds is very precise, but with nanoseconds the result can vary a lot. And of course, the result depends of your computer, your operating system and your configuration.&lt;/p&gt;
&lt;p&gt;An other thing, you can do with Threads, is waiting for an other thread to die. For example, you can create five thread to compute sub result and wait for these 5 threads to finish to compute the final results based on the results of the five threads. To do that, you can use the join() method of the Thread class. This method is not static, so you can use it on any thread to wait for it to die. Like sleep() this method throws InterruptedException in the when the thread is interrupted during waiting for an other thread. So to wait on thread2, you just have to do that :&lt;/p&gt;
&lt;p&gt;[java]try {
    thread2.join();
} catch (InterruptedException e){
    e.printStackTrace();
}[/java]&lt;/p&gt;
&lt;p&gt;That will make the current Thread waiting for thread2 to die. You can also add a timeout in millis, or millis + nanos, with the overloaded versions of join(), join(long millis) and join(long millis, int nanos). Here is little example that shows all that stuff :&lt;/p&gt;
&lt;p&gt;[java]public class JoinThread {
    public static void main(String[] args) {
        Thread thread2 = new Thread(new WaitRunnable());
        Thread thread3 = new Thread(new WaitRunnable());&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current time millis : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;thread2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;thread2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current time millis : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;thread3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;thread3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current time millis : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;WaitRunnable&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;Override&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;That produce this result on my computer :&lt;/p&gt;
&lt;pre&gt;Current time millis : 1274015478535

Current time millis : 1274015483538

Current time millis : 1274015484538&lt;/pre&gt;

&lt;p&gt;You can see that the first join() wait 5 seconds for the other thread and when we set a timeout, we wait only 1 seconds and return from join method.&lt;/p&gt;
&lt;p&gt;When working with Threads, it's also possible to change the priority of a Thread. In the Java Virtual Machine, the Thread scheduler, use a priority-based scheduling. So if a Thread enter in Runnable state with a higher priority than the running Thread, the new Thread will run and the current running thread will return to Runnable state and waits for its turn. But this behavior is not guaranteed and is completely depending on the virtual machine you are working on. So, do not rely on thread priorities, just use them to improve efficiency of your program.&lt;/p&gt;
&lt;p&gt;Normally, the priority range of Threads is an integer from 0 to 10, but some virtual machine have lower or higher ranges. To know the range of priority, you can use constants of the Thread class :&lt;/p&gt;
&lt;p&gt;[java]public class ThreadPriorityRange {
    public static void main(String[] args) {
        System.out.println("Minimal priority : " + Thread.MIN_PRIORITY);
        System.out.println("Maximal priority : " + Thread.MAX_PRIORITY);
        System.out.println("Norm priority : " + Thread.NORM_PRIORITY);
         }
}[/java]&lt;/p&gt;
&lt;p&gt;On my computer, I've the most current values :&lt;/p&gt;
&lt;pre&gt;Minimal priority : 1

Maximal priority : 10

Norm priority&lt;/pre&gt;

&lt;p&gt;To set the priority of a Thread, you can use the setPriority(int priority) method of the Thread class. If you enter a value greater than the maximal priority, the maximal value will be used. If you don't specify a priority, the used priority, will be the priority of the current Thread.&lt;/p&gt;
&lt;p&gt;An other way to works with priority is the yield() method. This method is static, so this works on the current Thread. The purpose of this method is to make the Thread going to Runnable again and to give the opportunity to other threads to get their turn. But in practice, the behavior of this method is not guaranteed. It can be implemented as a no-op on certain systems. It's not easy to test that in practice, because the results can truly depends on your computer, virtual machine and operating system. It's a good things to not use the priorities of Threads in practice.&lt;/p&gt;
&lt;p&gt;The last thing you can do with a Thread, is to interrupt it. In Java, you have no way to force a Thread to stop, if the Thread is not well-done, it can continue its execution infinitely. But you can interrupt a Thread with the interrupt() method. This method interrupt the thread, if the thread is sleeping or joining an other Thread, an InterruptedException is thrown. You have to know that if the thread was sleeping or joining, the interrupted status of the Thread will be cleared. Namely, the method isInterrupted() will return false. A little example to demonstrate that :&lt;/p&gt;
&lt;p&gt;[java]public class InterruptThread {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new WaitRunnable());&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;    &lt;span class="n"&gt;thread1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;thread1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;interrupt&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;WaitRunnable&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;Override&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current time millis : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

        &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The thread has been interrupted"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The thread is interrupted : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;isInterrupted&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Current time millis : "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;That produce that kind of result :&lt;/p&gt;
&lt;pre&gt;Current time millis : 1274017633151

The thread has been interrupted

The thread is interrupted : false

Current time millis : 1274017634151&lt;/pre&gt;

&lt;p&gt;You can see that after one second, the second thread is interrupted and that the interrupted status has been set to false. If you are not sleeping, but making a lot of heavy actions, you can test for interrupt like that to make your thread correctly interrupts :&lt;/p&gt;
&lt;p&gt;[java]public class InterruptableRunnable implements Runnable {
    @Override
    public void run() {
        while(!Thread.currentThread().isInterrupted()){
            //Heavy operation
        }
    }
}[/java]&lt;/p&gt;
&lt;p&gt;Now that you know how to interrupt a thread, you can imagine, that simply catch the InterruptedException is not enough to make your thread "interrupt safe". Imagine that your thread something like that : &lt;/p&gt;
&lt;p&gt;[java]public class UglyRunnable implements Runnable {
    @Override
    public void run() {
        while(!Thread.currentThread().isInterrupted()){
            //Heavy operation
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //Other operation
        }
    }
}[/java]&lt;/p&gt;
&lt;p&gt;And now, an other thread want to interrupt your thread while your thread is sleeping. The sleep will be interrupted, but the interrupted status will be cleared so the loop will continue. A solution to make a better thread is to interrupt again the thread after an InterruptedException : &lt;/p&gt;
&lt;p&gt;[java]public class BetterRunnable implements Runnable {
    @Override
    public void run() {
        while(!Thread.currentThread().isInterrupted()){
            //Heavy operation
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            //Other operation
        }
    }
}[/java]&lt;/p&gt;
&lt;p&gt;With that code, the interrupted status will be restored and the loop will be stopped after interrupt. Depending on your code, you can also add a continue statement after the interrupt() to not make operations after interrupt. In some cases, you'll also needs to make several if statements to test the interrupted status to do or not to do some operations. &lt;/p&gt;
&lt;p&gt;So, we've now covered the main operations you can do on threads. I hope you found this article interesting.&lt;/p&gt;
&lt;p&gt;You can download the sources of this article here : &lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/05/Part2.tar.gz"&gt;Java Concurrency Sources - Part 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the next article about Java Concurrency, we'll see how to synchronize code to make it Thread-safe.&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>Java</category><category>Java Concurrency Tutorial</category><guid>http://wichtounet.github.io/posts/2010/05/java-concurrency-part-2-manipulate-threads.html</guid><pubDate>Mon, 17 May 2010 06:33:07 GMT</pubDate></item><item><title>Java Concurrency - Part 1 : Threads</title><link>http://wichtounet.github.io/posts/2010/05/java-concurrency-part-1-threads.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;This post is the first of set of posts about &lt;strong&gt;Java Concurrency&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The concurrency is the fact to made several things at the same time using several threads.&lt;/p&gt;
&lt;p&gt;A thread, also called &lt;strong&gt;Lightweight Process&lt;/strong&gt;, is treatment unity. Threads executes code in &lt;strong&gt;parallel&lt;/strong&gt; of each other threads currently running. When you've only one processor, there is a thread running at the same time of the others, you only have the impression of &lt;strong&gt;concurrency&lt;/strong&gt; (I don't say it's not useful, I say it's different), but when you've &lt;strong&gt;multiple processors&lt;/strong&gt;, you'll see the power of multithreading. In this case, you can have your threads distributed on the processors of the computer.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;In Java, a thread is an instance of the class java.lang.Thread. A Thread can be managed in one of these two ways :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;Directly mapped to a native thread of the operating system. This is used when the operating system provide a preemptive threading system.&lt;/li&gt;
    &lt;li&gt;Managed by the virtual machine in a preemptive way.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A preemptive system, is a system in which the threads are managed by a scheduler and can be interrupted at any time to give processor to an other thread. When you program, you doesn't have to pay attention of which type of threads you use, the result will normally be the same. But you've to know that there can differences between operating systems.&lt;/p&gt;
&lt;p&gt;There is three very important concepts when doing concurrent programming :&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Atomicity : An operation is said atomic when it cannot be interrupted. There is almost no atomic operations in Java, the only we've is the assignation a = 5, but a = b++ is not atomic. In some cases, you'll have to make atomic some actions with synchronization, we'll see later how to do that.&lt;/li&gt;
    &lt;li&gt;Visibility : This occurs when a thread must watch the actions of an other threads by example the termination of the thread. This also implies some kind of synchronization.&lt;/li&gt;
    &lt;li&gt;Order of execution : When you have normal program, all you lines of code run in the same order every time you launch the application. This is not the case when you make concurrent programming. You first instruction can followed by an instruction of the thread B or by the first instruction. And that can change every time you launch the application. &lt;strong&gt;The order of execution is not guaranteed !&lt;/strong&gt; I will certainly repeat that sometimes, but that's important to know.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We'll see these concepts more deeply in the others parts of the set.&lt;/p&gt;
&lt;p&gt;Lets start introducing the Thread class in Java. You can create threads in two ways :&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Extends &lt;strong&gt;Thread&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;Implements &lt;strong&gt;Runnable&lt;/strong&gt; and pass an instance of your news class to the Thread constructor&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first solution isn't a good solution because what you're creating is not a new specialized thread, but several instructions to run in a new Thread, namely a Runnable. Implementing Runnable is also better because Runnable is an interface and so, you can also extends a class and implementing Runnable, that's useful in some cases.&lt;/p&gt;
&lt;p&gt;In my examples, I'll always use the second way. So let's declare our first Runnable :&lt;/p&gt;
&lt;p&gt;[java]public class MyFirstRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("In a thread");
    }
}[/java]&lt;/p&gt;
&lt;p&gt;And use it to create a new Thread and start it :&lt;/p&gt;
&lt;p&gt;[java]Thread thread = new Thread(new MyFirstRunnable());&lt;/p&gt;
&lt;p&gt;thread.start();[/java]&lt;/p&gt;
&lt;p&gt;The Thread will stopped when the end of the run() will be reached. You cannot force a thread to stop (there is stop() method, but deprecated), we'll see later how to properly stop a thread.&lt;/p&gt;
&lt;p&gt;And now, what happens if we add a simple line of code to our program :&lt;/p&gt;
&lt;p&gt;[java]Thread thread = new Thread(new MyFirstRunnable());&lt;/p&gt;
&lt;p&gt;thread.start();&lt;/p&gt;
&lt;p&gt;System.out.println("In the main Thread");[/java]&lt;/p&gt;
&lt;p&gt;Can you predict the result of this code ? Nobody can't, it's not predictable, you can have :&lt;/p&gt;
&lt;pre&gt;In a thread

In the main Thread&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;In the main Thread

In a thread&lt;/pre&gt;

&lt;p&gt;And we cannot do better than that.&lt;/p&gt;
&lt;p&gt;You can use the Runnable several times :&lt;/p&gt;
&lt;p&gt;[java]Runnable runnable = new MyFirstRunnable();&lt;/p&gt;
&lt;p&gt;for(int i = 0; i &amp;amp;lt; 25; i++){
    new Thread(runnable).start();
}[/java]&lt;/p&gt;
&lt;p&gt;Now, 25 threads are launched.&lt;/p&gt;
&lt;p&gt;You can also give names to Thread using the setName() method. You can get the name of the current thread using Thread.currentThread().getName(). Let's do a little example :&lt;/p&gt;
&lt;p&gt;[java]public class MySecondRunnable implements Runnable{
    @Override
    public void run() {
        System.out.printf("I'm running in thread %s \n", Thread.currentThread().getName());
    }
}[/java]&lt;/p&gt;
&lt;p&gt;[java]Runnable runnable = new MySecondRunnable();&lt;/p&gt;
&lt;p&gt;for(int i = 0; i &amp;amp;lt; 25; i++){
    Thread thread = new Thread(runnable);
    thread.setName("Thread " + i);
    thread.start();
}[/java]&lt;/p&gt;
&lt;p&gt;This is the best example to see that the other is unpredictable. Here are two executions on my machine :&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;pre&gt;I'm running in thread Thread 0

I'm running in thread Thread 1

I'm running in thread Thread 2

I'm running in thread Thread 3

I'm running in thread Thread 4

I'm running in thread Thread 5

I'm running in thread Thread 7

I'm running in thread Thread 14

I'm running in thread Thread 13

I'm running in thread Thread 12

I'm running in thread Thread 11

I'm running in thread Thread 10

I'm running in thread Thread 9

I'm running in thread Thread 8

I'm running in thread Thread 6

I'm running in thread Thread 15

I'm running in thread Thread 16

I'm running in thread Thread 17

I'm running in thread Thread 18

I'm running in thread Thread 19

I'm running in thread Thread 20

I'm running in thread Thread 21

I'm running in thread Thread 22

I'm running in thread Thread 23

I'm running in thread Thread 24&lt;/pre&gt;

&lt;p&gt;2.&lt;/p&gt;
&lt;pre&gt;I'm running in thread Thread 0

I'm running in thread Thread 1

I'm running in thread Thread 2

I'm running in thread Thread 3

I'm running in thread Thread 4

I'm running in thread Thread 5

I'm running in thread Thread 6

I'm running in thread Thread 7

I'm running in thread Thread 8

I'm running in thread Thread 9

I'm running in thread Thread 10

I'm running in thread Thread 11

I'm running in thread Thread 12

I'm running in thread Thread 13

I'm running in thread Thread 14

I'm running in thread Thread 15

I'm running in thread Thread 16

I'm running in thread Thread 17

I'm running in thread Thread 18

I'm running in thread Thread 19

I'm running in thread Thread 20

I'm running in thread Thread 21

I'm running in thread Thread 22

I'm running in thread Thread 23

I'm running in thread Thread 24&lt;/pre&gt;

&lt;p&gt;Like you can see, the order the threads instructions are executed is not guaranteed at all.&lt;/p&gt;
&lt;p&gt;So here we are with the first part of this suite of articles about Java Concurrency. In the next post, we'll see the operations you can make directly on threads (stopping, joining, sleeping, ...).&lt;/p&gt;
&lt;p&gt;I hope you found that post interesting.&lt;/p&gt;
&lt;p&gt;The sources of this post are available here : &lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/05/Part1.tar.gz"&gt;Java Concurrency Sources Part 1&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>Java</category><category>Java Concurrency Tutorial</category><guid>http://wichtounet.github.io/posts/2010/05/java-concurrency-part-1-threads.html</guid><pubDate>Fri, 07 May 2010 06:12:33 GMT</pubDate></item></channel></rss>