<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>@Blog("Baptiste Wicht") (Releases)</title><link>http://www.baptiste-wicht.com/</link><description></description><atom:link href="http://www.baptiste-wicht.com/categories/releases.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 16 Mar 2014 19:02:05 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>eddic 1.2.3 - Better data-flow analysis</title><link>http://www.baptiste-wicht.com/posts/2013/03/eddic-1-2-3-better-data-flow-analysis.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I finally finished the version 1.2.3 of eddic. I have been quite busy finishing my master thesis in february and then taking some vacations in United States, so this version came later than I wanted. &lt;/p&gt;
&lt;p&gt;The main change is about the speed of the data-flow optimizations. I refactored a lot the data-flow to make it much faster. Some test cases are up to 10 times faster :)&lt;/p&gt;
&lt;p&gt;There are still some work to do for speed of optimizations, but it is much better now. Dead Code Elimination and Constant Propagation still have to be made faster, but now the main bottleneck. In the next version of eddic, the parsing performance will be improved. &lt;/p&gt;
&lt;p&gt;Inlining performance has also been greatly improved. The functions are considered in topological order of the call graph. This makes it much faster and moreover the resulting code is more efficient too. &lt;/p&gt;
&lt;p&gt;There are also some improvements of the language. char and bool types now takes only one byte each. Copy constructors for structures containing field of structure type are now automatically generated. The grammar has been enhanced to support postfix operations in for loops. &lt;/p&gt;
&lt;p&gt;Other improvements have been made to the optimization engine. A new optimization has been implemented: Loop Unswitching. This optimization transforms a code like that: &lt;/p&gt;
&lt;p&gt;[cpp]for(int i = 0; i &amp;lt; X; ++i){&lt;/p&gt;
&lt;p&gt;if(a){
   //Something
} else {
   //Something else
}&lt;/p&gt;
&lt;p&gt;}[/cpp]&lt;/p&gt;
&lt;p&gt;In some code like that: &lt;/p&gt;
&lt;p&gt;[cpp]if(a){
   for(int i = 0; i &amp;lt; X; ++i){
      //Something
   }
} else {
   for(int i = 0; i &amp;lt; X; ++i){
      //Something else
   }
}[/cpp]&lt;/p&gt;
&lt;p&gt;when a doesn't depend on the loop body. The body of the loops is much faster in the second version. &lt;/p&gt;
&lt;p&gt;The induction variable analysis is now able to handle loops with induction variable divided in each iteration. With that new feature, the call: &lt;/p&gt;
&lt;p&gt;[cpp]print(123);[/cpp]&lt;/p&gt;
&lt;p&gt;is reduced to&lt;/p&gt;
&lt;p&gt;[cpp]print('1');&lt;/p&gt;
&lt;p&gt;print('2');&lt;/p&gt;
&lt;p&gt;print('3');[/cpp]&lt;/p&gt;
&lt;p&gt;Another small optimization is that variables contributing only to themselves are now correctly identified as dead. &lt;/p&gt;
&lt;p&gt;On the compiler side, the timing system has been greatly improved to contains almost all part of the compilation process. The timings for the complete compilation is available &lt;a href="https://github.com/wichtounet/eddic/wiki/Performance" title="Performance"&gt;on the wiki&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future Work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.4. &lt;/p&gt;
&lt;p&gt;Performances will stil be focused for this version. The first change will be to improve the performances of the parsing. Then, I'm gonna try to improve register allocation performances by improving handling of bound registers which I believe is a bottleneck. &lt;/p&gt;
&lt;p&gt;There are also several refactorings that I think of doing to the code. I will probably also implement new minor language features, but I still don't know what. &lt;/p&gt;
&lt;p&gt;Moreover, I have to serve in the army the next three weeks, so there won't be any progress these weeks. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.3&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Optimization</category><category>projects</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2013/03/eddic-1-2-3-better-data-flow-analysis.html</guid><pubDate>Sat, 09 Mar 2013 11:50:27 GMT</pubDate></item><item><title>eddic 1.2.2 - Performances, improved optimizations and additions to standard library</title><link>http://www.baptiste-wicht.com/posts/2013/01/eddic-1-2-2-performances-optimization-library.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;These last weeks, I had more work than expected with my Master thesis so it took me longer to finish this new version of eddic. Moreover, I included more stuff than I though in this version. Anyway, I'm happy to announce the version 1.2.2 of eddic.&lt;/p&gt;
&lt;p&gt;It is a minor version regarding the language itself. On the other, there are a lot of changes in the compiler itself.&lt;/p&gt;
&lt;p&gt;For the language:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;Structures are now correclty copy constructed when passed by value&lt;/li&gt;
    &lt;li&gt;When the same header is included several times accross the program, it is not parsed again&lt;/li&gt;
    &lt;li&gt;The vector structure has now functions to insert and remove elements in arbitrary positions&lt;/li&gt;
    &lt;li&gt;The functions to print bools, floats and integers are now written in EDDI directly. Only the functions to print chars and raw string are now written in assembly&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I worked on improving the performances by improving the constant propagation pass that runs less times now and by tuning a bit the data-flow framework, avoiding virtual calls.&lt;/p&gt;
&lt;p&gt;Another improvement is that all the mtac::Statement types have been merged in mtac::Quadruple, this removes one level of indirection and simplifies several passes. Moreover, there are now directly stored inside a vector and not allocated via shared_ptr. This removes another level of indirection.&lt;/p&gt;
&lt;p&gt;Put together, these two optimizations improved the performances of the compiler by about 15%. On the other hand, now that printF and printI are written in EDDI, it takes much longer to compile. I will work on that for the next version too. One way to improve the performances will be to tune the ordering of passes and also to tune the passes themselves so that they do more work at once. I will also try to merge constant propagation and offset constant propagation together. They perform very similar work.&lt;/p&gt;
&lt;p&gt;There are also several improvements in the optimization engine:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span style="line-height: 13px;"&gt;The loop analysis has been fixed to handle loops bigger than one basic block. There was a problem in my implement of &lt;strong&gt;Lengauer and Tarjan&lt;/strong&gt; making that dominators were not computed. &lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;The optimization engine now create a call graph of the program. This call graph is used to remove unused functions that are called but not reachable from the main function.&lt;/li&gt;
    &lt;li&gt;A new analysis pass has been added: pure_analysis. This pass test if a function is pure (no write to pointers or global variables) and thus avoid creating a basic block for it&lt;/li&gt;
    &lt;li&gt;The L&lt;strong&gt;oop Invariant Code Motion algorithm&lt;/strong&gt; has been improved to handle more invariants&lt;/li&gt;
    &lt;li&gt;The &lt;strong&gt;Common Subexpression Elimination&lt;/strong&gt; algorithm has been improved to handle more expression&lt;/li&gt;
    &lt;li&gt;The &lt;strong&gt;Induction Variables analysis&lt;/strong&gt; has been reviewed and several bugs have been corrected. It is now a bit complicated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A big bug has been fixed in the handling of the MEMSET LTAC instruction. This will be completely reviewed in the next version (See Future Work).&lt;/p&gt;
&lt;p&gt;Some analysis starts to become quite complicated. I'm thinking of using SSA in MTAC in order to simplify some of the passes and to easily compute ud-chains. Another thing that I'm thinking is to add a powerful and complete alias analysis that would really improve the efficiency of some passes (offset constant propagation for instance) by making them less conservative.&lt;/p&gt;
&lt;p&gt;I also have removed some memory leaks (will try to remove all of them in the next version). I added a new optimization level: O3. This level enables loop unrolling and complete loop peeling.&lt;/p&gt;
&lt;h4&gt;Future Work&lt;/h4&gt;

&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.3. The inliner will be improved to work directly in the call graph in postorder. That should produce better code. I will also try to improve the inlining heuristics. A first basic version of loop unswitching will be added as well. I will add a small local constant propagation pass for globals. I will also continue to work on the performances of the passes to avoid repeating them too much. MEMSET will be completely reviewed. That should produce smaller and faster code. Until now, the sizes of the types bool and chars were the same as int. They will be optimized to take only 1 byte.&lt;/p&gt;
&lt;p&gt;I will also continue the improvements of the data structures by merging all ltac::Statement into ltac::Instruction and storing them directly.&lt;/p&gt;
&lt;p&gt;And there will probably be some bug fixing as well.&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.2&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>C++11</category><category>EDDI</category><category>EDDI</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2013/01/eddic-1-2-2-performances-optimization-library.html</guid><pubDate>Sat, 26 Jan 2013 16:35:42 GMT</pubDate></item><item><title>eddic 1.2.1 - string, concatenation and vector</title><link>http://www.baptiste-wicht.com/posts/2012/12/eddic-1-2-1-string-concatenation-and-vector.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Before preparing myself for New Year's Eve, I decided to finish eddic 1.2.1, and it's done !&lt;/p&gt;
&lt;p&gt;This version is a small one, but add several improvements to the language and to the standard library. Many bugs have been fixed especially in the support of dynamic arrays and structures. &lt;/p&gt;
&lt;p&gt;The first important change is that string has been renamed to str and that a new struct is available: string. Indeed, str is now a simple raw string where string has more capabilities like concatenation. This new version also supports concatenation of string and int, which was not possible before. In the future, I'll try to add more features to the string class. &lt;/p&gt;
&lt;p&gt;Another improvement of the standard library is the inclusion of a vector structure. The vector is a dynamic arrays, which means that it can be automatically resized when necessary. For now, the operations available on vector are very few, but more will be added later. Especially, it is not possible now to add elements in the middle of the array, but it will be done, perhaps in the next eddic version or the next after this one. Adding the vector has also meant to add new features to the language. &lt;/p&gt;
&lt;p&gt;Dynamic arrays of structures is now supported. And, the delete operator can be applied on any left value now, not only variables. It means that "delete a[9];" is now a valid code. &lt;/p&gt;
&lt;p&gt;Finally, in the side of the language, printB has been rewritten in EDDI instead of raw assembly. In the next versions, I will continue to rewrite as much as possible of the assembly stuff into EDDI. There are several advantages. The first one is that I don't have to maintain two versions (one for 32 bits and one for 64 bits). Another advantage is that it can profit from the eddic optimizations. And it is more readable and maintainable in EDDI. &lt;/p&gt;
&lt;p&gt;A new optimization is now available. If a function is always called with the same value for one of its parameters, the value is propagated inside the function. In the future, it will be improved to suppport propagation for instance in more than X% of the case, creating several versions of the function. The optimizations have also been a bit improved in terms of performance, making some samples much faster to compile than before. Essentially, the removal of dead basic blocks is now made in a way that it doesn't need to be run several times to remove all the dead basic blocks. &lt;/p&gt;
&lt;p&gt;The warnings have been improved. Now, no warnings are emitted if some parts of a include are not used. And, if no elements of an included header is used, it will be warned that the include is not necessary. &lt;/p&gt;
&lt;p&gt;The error reporting has also been improved a bit. It can now display several errors. For now, it is limited to one error by function. Doing better error reporting, would mean lots of changes in the AST passes which I don't want to do right now. &lt;/p&gt;
&lt;p&gt;The hangman application has been fixed. It was a bug in the inliner that was causing this problem. There are now new test cases that verify that the optimizations are done. For instance, there is a test case verifying that the correct loops are removed when necessary. This is done by keeping tracks of counters like removed functions during the optimization. &lt;/p&gt;
&lt;p&gt;The source code has also been improved. I now use less shared_ptr and rather rely in storing the elements in standard container and using references directly. It result in much better code. This also improves a bit the performances by having a better data locality. For now, I have handled the given classes: eddic::Function, mtac::Function and mtac::Program, but the next version will handle more critical structures like the basic blocks and the MTAC statements which could improve the performances of the optimization by making iteration faster. &lt;/p&gt;
&lt;p&gt;Don't hesitate to comment or to contact me if you have any suggestion (or other) about this release or for the future versions of eddic. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;And happy new year !&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future Work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.2. In this version, I willl continue the work that I've done by using less shared_ptr and relying on references. I will also continue to improve the interfaces of the different class used. This version will also fix the memory leaks that I spotted in the application. There will also be new improvements on the language side, but minor one and I don't know now which ones I will pick. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.1&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>EDDI</category><category>EDDI</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2012/12/eddic-1-2-1-string-concatenation-and-vector.html</guid><pubDate>Mon, 31 Dec 2012 19:46:56 GMT</pubDate></item><item><title>eddic 1.2.0 - Single inheritance, copy construction</title><link>http://www.baptiste-wicht.com/posts/2012/12/eddic-1-2-0-single-inheritance-copy-constructor.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I'm happy to release the &lt;strong&gt;version 1.2.0 of the EDDI Compiler (eddic)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This new version introduces several major changes to the language. &lt;/p&gt;
&lt;p&gt;First of all, structures can now inherits from another structure. When it is done, the structure can use the members of the parent class. Below is an example of single inheritance in EDDI: &lt;/p&gt;
&lt;p&gt;[cpp]struct A {
    float a;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;init_a&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;55.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test_a&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;struct B extends A {
    char a;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;init_b&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'B'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;init_a&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test_b&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;test_a&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/cpp]&lt;/p&gt;
&lt;p&gt;For now, the support remains basic, but it will be improved over time. I will probably add support for virtual functions in the future. &lt;/p&gt;
&lt;p&gt;Another major improvement to the language is that variable of a custom type can now be assignment, resulting in a call to the copy constructor. If no copy constructor is defined in a structure, it is automatically generated by the compiler. Another improvement to structures is that structures can now contains arrays. Moreover, the members of a structure (fields, constructors, functions, ...) can now be present in any order. &lt;/p&gt;
&lt;p&gt;A major change has been made to pointers. The conversions from variables to pointers is no more implicit, it is necessary to use the new &amp;amp; operator to take the address of a variable. I found that this implicit conversions was not really making any sense.&lt;/p&gt;
&lt;p&gt;A function can now return a structure by value. And, member functions can be called from any valid left value. For instance: &lt;/p&gt;
&lt;p&gt;[cpp]array[5].function(5).function(9);[/cpp]&lt;/p&gt;
&lt;p&gt;is now valid code.  &lt;/p&gt;
&lt;p&gt;Finally, the switch construct can be used with strings too. This uses the str_equals functions to test which case is valid. &lt;/p&gt;
&lt;p&gt;There are no big changes in the optimization engine. A new optimization pass has been added performing loop unrolling for loop with known iteration count. The pointer propagation has been fixed to handle pointers on structures resulting in much better code for several samples. The last improvement here is that conditions can be propagated into branches when necessary. &lt;/p&gt;
&lt;p&gt;The loop analysis has been improved to directly calculate the number of iterations of each loop and store this result. The list of induction variables is only calculated once now. &lt;/p&gt;
&lt;p&gt;The code generation has been slightly improved by saving fewer registers when calling another function. &lt;/p&gt;
&lt;p&gt;Finally, there are also some internal changes. The template instantiation depth limit can now configured. Before, infinite template recursion would just fail. The time spent in each optimization can now be computed with the new --timing option. There have been great improvements on the side of the Abstract Syntax Tree. A good part of the expression grammar has been rewritten. With these changes, the grammar is much more powerful than before. &lt;/p&gt;
&lt;p&gt;Don't hesitate to comment or to contact me if you have any suggestion (or other) about this release or for the future versions of eddic. &lt;/p&gt;
&lt;p&gt;I'd also like to thank &lt;a href="https://github.com/TyRoXx" title="TyRoXx"&gt;TyRoXx&lt;/a&gt; who has made some improvements in the assembly generation module. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future Work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.1. This version will specifically focus on two points. First the usage of strings will be improved with a string class adding features to literal string. The second point will be the performances of the compiler. At this point, the optimization engine is clearly too slow. I will try to make it faster. The list of issues is available &lt;a href="https://github.com/wichtounet/eddic/issues?milestone=2&amp;amp;state=open" title="eddic version 1.2.1"&gt;on Github&lt;/a&gt;.  &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.0&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2012/12/eddic-1-2-0-single-inheritance-copy-constructor.html</guid><pubDate>Mon, 17 Dec 2012 09:20:10 GMT</pubDate></item><item><title>Packt Publishing celebrates its 1000th IT Book !</title><link>http://www.baptiste-wicht.com/posts/2012/09/packt-publishing-thousandth-book-celebration.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Packt Publishing is about to publish its 1000th title, on the 30th of September, 2012.&lt;/p&gt;
&lt;p&gt;Packt published their first book in April 2004. They now have a lot of books on about every subject from web development to IT architecture, games to e-commerce. Their books are known for their high quality.&lt;/p&gt;
&lt;p&gt;For this occasion, they are offering a surprise gift to all their members. If you want to be part of it, you just have to sign up for a free Packt Publishing account. If you're already registered, you don't have anything to do! You need to be registered before the 30th of September in order to get involved.&lt;/p&gt;
&lt;p&gt;Packt is also known for their support to Open Source. They support Open Source projects through a project royalty donation. They already have contributed over £300,000. For this special occasion, they will allocate 30,000 to share between projects and authors in their own way that will be disclosed on the website soon.&lt;/p&gt;
&lt;p&gt;For more information about Packt Publishing, their books or how to sign-up for a free account for this offer, you can view the official website: &lt;a title="http://www.packtpub.com" href="http://www.packtpub.com" target="_blank"&gt;http://www.packtpub.com/&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>Programming</category><category>Promotion</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2012/09/packt-publishing-thousandth-book-celebration.html</guid><pubDate>Wed, 19 Sep 2012 20:44:44 GMT</pubDate></item><item><title>EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors</title><link>http://www.baptiste-wicht.com/posts/2012/07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;As I'm in holiday, the work is going pretty fast. The &lt;strong&gt;version 1.1.1&lt;/strong&gt; of the &lt;strong&gt;EDDI Compiler&lt;/strong&gt; (eddic) is available.&lt;/p&gt;
&lt;p&gt;This version introduces two major changes. The first is the support of dynamic memory allocation. You can allocate a struct or a standard type in help using the new operator. The memory can be released using the delete operator. Another related improved is the addition of constructors and destructors to the language. The following sample shows what can be done with the new features:&lt;/p&gt;
&lt;p&gt;[cpp]struct A {
    int a;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Constructed"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Destructed"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void main(){
    A* b = new A(55);
    delete b;
}[/cpp]&lt;/p&gt;
&lt;p&gt;The constructor is called once the memory is allocated. The delete operator calls the destructor and then free the memory. &lt;/p&gt;
&lt;p&gt;When a structure is allocated on the stack, the constructor is called at the declaration point and the destructor is called when the variable gets out of scope. &lt;/p&gt;
&lt;p&gt;The memory manager is quite simple for now. Memory is allocated in blocks. Each block has a header indicating the size of the block and its availability. The size of the header is 8 bytes in 32 bits and 16 bytes in 64 bits. The free operation can be done in constant time by just setting the availability flag to false. The disadvantage of this technique is that all the blocks needs to be tested to find a free block. This can be slow in some situations. I will try to make a better version in the future. &lt;/p&gt;
&lt;p&gt;For that, the memory model has been improved. All the offsets are now increasing and the stack addresses are set at the end of the block. &lt;/p&gt;
&lt;p&gt;Another interesting improvement of the language is the support of switch. For now, only switch on int is supported. Here is an example of a switch in EDDI:&lt;/p&gt;
&lt;p&gt;[cpp]switch(a){
    case 3:
        print("3");
    case 4:
        print("4");
    case 5:
        print("5");
    case 6:
        print("6");
    default:
        print("default");
}[/cpp]&lt;/p&gt;
&lt;p&gt;The performances of the optimizer have been improved, by doing live-variable analysis less often. Pointers can now be passed in registers. Some of the variables used as temporary copies are removed &lt;/p&gt;
&lt;p&gt;The peephole optimizer has been improved to use conditional move when possible. Moreover, the peephole optimizer is now able to perform some local copy propagation. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI Compiler will be the version 1.1.2. This version will add features to read the command-line. Moreover, it will also add support for char type and string comparisons. With that, I think that the language will start to be usable for toy applications. &lt;/p&gt;
&lt;p&gt;There  will be some improvements to the code that have been left aside for a too long time. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: https://github.com/wichtounet/eddic&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v1.1.1 available in the GitHub tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2012/07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html</guid><pubDate>Mon, 30 Jul 2012 12:18:01 GMT</pubDate></item><item><title>EDDI Compiler 1.0.3 - Inlining and register allocation</title><link>http://www.baptiste-wicht.com/posts/2012/07/eddi-compiler-1-0-3-inlining-register-allocation.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;The &lt;strong&gt;version 1.0.3&lt;/strong&gt; of the &lt;strong&gt;EDDI Compiler&lt;/strong&gt; (eddic) is available.&lt;/p&gt;
&lt;p&gt;The only improvement to the language is that the size of a global array can now be defined using a constant global variable.&lt;/p&gt;
&lt;p&gt;The main improvement of this version is the addition of &lt;strong&gt;inlining&lt;/strong&gt; in the optimization engine. This optimization replace a call to a function by the body of the function. For now, the inlining optimizer is quite basic. For now, it doesn't inline only a specific call site but all the call sites of a given function. Moreover, the heuristics used for inlining are quite simple (only the size of the function is taken into account). Only functions that takes int and float parameters can be inlined. This optimization will be improved in the future.&lt;/p&gt;
&lt;p&gt;The second main change is the arrival of a &lt;strong&gt;basic register allocation&lt;/strong&gt;. In each function, one or more variables can be assigned to registers. Only the most used variables are allocated into registers. Another optimization is that variables that are not used after all optimization techniques have been applied are removed from the function storage. The unused functions are also removed from the program after the optimization passes.&lt;/p&gt;
&lt;p&gt;Moreover, the performances of optimization engine have been improved by about 20%.&lt;/p&gt;
&lt;p&gt;The MTAC representation has been improved. The ARRAY operators have been removed because they can be replaced with the DOT operators. The preamble and prologue generations for LTAC has also been refactored. When it is possible, the stack frames are not generated.&lt;/p&gt;
&lt;p&gt;Finally, the configuration of the compiler has been improved with several new optimization option and the options being separated into several option groups.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI Compiler will be the &lt;strong&gt;version 1.1.0&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The main change will be member functions inside of structures. For now, there will be no kind of virtual functions and inheritance but that will certainly come in its time.&lt;/p&gt;
&lt;p&gt;And as ever, I will be more than pleased to hear any idea you could have about this project :)&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the compiler sources on the Github repository: &lt;a title="eddic on GitHub" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v1.0.3 available in the GitHub tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Optimization</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2012/07/eddi-compiler-1-0-3-inlining-register-allocation.html</guid><pubDate>Sat, 14 Jul 2012 08:46:15 GMT</pubDate></item><item><title>taskwarrior-php 0.1 : A simple PHP Frontend for Taskwarrior</title><link>http://www.baptiste-wicht.com/posts/2012/07/taskwarrior-php-frontend-0-1.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I released the version 0.1 of &lt;strong&gt;taskwarrior-php&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This project is a simple PHP Frontend for Taskwarrior. For now, the frontend is quite basic. All the tasks are displayed and sorted by projects. The completion of each project is also computed.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/?attachment_id=2035" rel="attachment wp-att-2035"&gt;&lt;img class="size-medium wp-image-2035" title="taskwarrior-php Screenshot" src="http://www.baptiste-wicht.com/wp-content/uploads/2012/07/taskwarrior-php-1-300x271.png" alt="taskwarrior-php Screenshot" width="300" height="271"&gt;&lt;/a&gt; taskwarrior-php Screenshot&lt;/p&gt;
&lt;p&gt;You can also insert a new task. For now, only the project and the description of the task can be modified.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Download&lt;/h3&gt;
&lt;p&gt;The application is available on the Git repository : &lt;a href="https://github.com/wichtounet/taskwarrior-php"&gt;https://github.com/wichtounet/taskwarrior-php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The installation is simple, you just have to put all the files in a folder of a PHP server. Then, you have to edit the config.php to set the location of your Taskwarrior files.&lt;/p&gt;
&lt;p&gt;It is necessary that the Taskwarrior files are on the PHP server as well. For that, you can use the FTP pull and push commands of Taskwarrior.&lt;/p&gt;
&lt;p&gt;Don't hesitate to contact me if you have some ideas for this project or if you find some bugs.&lt;/p&gt;&lt;/div&gt;</description><category>Linux</category><category>Releases</category><category>Tools</category><category>Web</category><category>Web</category><guid>http://www.baptiste-wicht.com/posts/2012/07/taskwarrior-php-frontend-0-1.html</guid><pubDate>Mon, 09 Jul 2012 09:21:14 GMT</pubDate></item><item><title>The site is now running WordPress 3.4</title><link>http://www.baptiste-wicht.com/posts/2012/06/the-site-now-running-wordpress-3-4.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I just updated the site to run WordPress 3.4&lt;/p&gt;
&lt;p&gt;Normally, you should see any differences as most of the new features of this version are in the admin side, but if you see something that doesn't work, don't hesitate to contact me. &lt;/p&gt;&lt;/div&gt;</description><category>Others</category><category>Releases</category><category>The site</category><category>WordPress</category><guid>http://www.baptiste-wicht.com/posts/2012/06/the-site-now-running-wordpress-3-4.html</guid><pubDate>Sun, 24 Jun 2012 02:36:37 GMT</pubDate></item><item><title>Install Cinnamon in Linux Mint - A forked Gnome Shell</title><link>http://www.baptiste-wicht.com/posts/2012/01/install-cinnamon-linux-mint.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;In the last Linux Mint version (12), the developers have introduced a set of extensions to the Gnome Shell, Mint Gnome Shell Extensions (MGSE).&lt;/p&gt;
&lt;p&gt;But, plugins can't do everything the developers want. So they forked Gnome Shell and started building their own shell : Cinnamon.&lt;/p&gt;
&lt;p&gt;At the time of writing, the appearance of this new shell is similar to MGSE in Linux Mint 12, but with some differences : only one status bar, the left bottom menu was changed, notification bar in the bottom bar, ...&lt;/p&gt;
&lt;p&gt;You can try it on your Linux Mint right now :&lt;/p&gt;
&lt;p&gt;[bash]sudo apt-get update&lt;/p&gt;
&lt;p&gt;sudo apt-get install cinnamon-session[/bash]&lt;/p&gt;
&lt;p&gt;Then, you have to logout and select Cinnamon in the Logon screen as the desktop environment. &lt;/p&gt;
&lt;p&gt;Personally, I still prefer MGSE, because I like having two bars, but that will perhaps change with some more tests on Cinnamon. And you, what do you think about Cinnamon ? Or about MGSE ? &lt;/p&gt;
&lt;p&gt;If you want more informations about this new shell, you can read &lt;a href="http://cinnamon.linuxmint.com/" title="Cinnamon Official Site" target="_blank"&gt;the official site&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>Linux</category><category>Mint</category><category>Mint</category><category>Releases</category><guid>http://www.baptiste-wicht.com/posts/2012/01/install-cinnamon-linux-mint.html</guid><pubDate>Thu, 05 Jan 2012 08:11:19 GMT</pubDate></item></channel></rss>