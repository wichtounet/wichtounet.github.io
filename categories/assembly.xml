<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>@Blog("Baptiste Wicht") (Assembly)</title><link>http://www.baptiste-wicht.com/</link><description></description><atom:link rel="self" type="application/rss+xml" href="http://www.baptiste-wicht.com/categories/assembly.xml"></atom:link><language>en</language><lastBuildDate>Sun, 16 Mar 2014 18:49:42 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Thor OS: Boot Process</title><link>http://www.baptiste-wicht.com/posts/2013/12/thor-os-boot-process.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Some time ago, I started a hobby project: &lt;a title="New hobby project: Thor-OS, 64bit Operating System in C++" href="http://www.baptiste-wicht.com/2013/12/new-hobby-project-thor-os-64bit-operating-system-c/"&gt;writing a new operating system&lt;/a&gt;. I'm not trying to create a concurrent to Linux, I'm just trying to learn some more stuff about operating systems. I'm gonna try to write some posts about this kernel on this blog.&lt;/p&gt;
&lt;p&gt;In this post, I'll describe the boot process I've written for this operating system.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Bootloader Step&lt;/h3&gt;
&lt;p&gt;The first step is of course the bootloader. The bootloader is in the MBR and is loaded by the system at 0x7C00.&lt;/p&gt;
&lt;p&gt;I'm doing the bootloading in two stages. The first stage (one sector) print some messages and then load the second stage (one sector) from floppy at 0x900. The goal of doing it in two stages is just to be able to overwrite the bootloader memory by the stage. The second stage loads the kernel into memory from floppy. The kernel is loaded at 0x1000 and then run directly.&lt;/p&gt;
&lt;p&gt;The bootloader stages are written in assembly.&lt;/p&gt;
&lt;h3&gt;Real mode&lt;/h3&gt;

&lt;p&gt;When the processor, it boots in real mode (16 bits) and you have to setup plenty of things before you can go into long mode (64 bits). So the first steps of the kernel are running in 16 bits. The kernel is mostly written in C++ with some inline assembly.&lt;/p&gt;
&lt;p&gt;Here are all the things that are done in this mode:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;The memory is inspected using BIOS E820 function. It is necessary to do that at this point since BIOS function calls are not available after going to protected mode. This function gives a map of the available memory. The map is used later by the dynamic memory allocator.&lt;/li&gt;
    &lt;li&gt;The interrupts are disabled and a fake Interrupt Descriptor Table is configured to make sure no interrupt are thrown in protected mode&lt;/li&gt;
    &lt;li&gt;The Global Descriptor Table is setup. This table describes the different portion of the memory and what each process can do with each portion of the memory. I have three descriptors: a 32bit code segment, a data segment and a 64bit code segment.&lt;/li&gt;
    &lt;li&gt;Protected mode is activated by setting PE bit of CR0 control register.&lt;/li&gt;
    &lt;li&gt;Disable paging&lt;/li&gt;
    &lt;li&gt;Jump to the next step. It is necessary to use a far jump so that the code segment is changed.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Protected Mode&lt;/h3&gt;

&lt;p&gt;At this point, the processor is running in protected mode (32 bits). BIOS interrupts are not available anymore.&lt;/p&gt;
&lt;p&gt;Again, several steps are necessary:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;To be able to use all memory, Physical Address Extensions are activated.&lt;/li&gt;
    &lt;li&gt;Long Mode is enabled by setting the EFER.LME bit.&lt;/li&gt;
    &lt;li&gt;Paging is setup, the first MiB of memory is mapped to the exact same virtual addresses.&lt;/li&gt;
    &lt;li&gt;The address of the Page-Map Level 4 Table is set in the CR0 register.&lt;/li&gt;
    &lt;li&gt;Finally paging is activated.&lt;/li&gt;
    &lt;li&gt;Jump to the real mode kernel, again by using a far jump to change code segment.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Real Mode&lt;/h3&gt;

&lt;p&gt;The kernel finally runs in 64 bits.&lt;/p&gt;
&lt;p&gt;There are still some initialization steps that needs to be done:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;SSE extensions are enabled.&lt;/li&gt;
    &lt;li&gt;The final Interrupt Descriptor Table is setup.&lt;/li&gt;
    &lt;li&gt;ISRs are created for each possible processor exception&lt;/li&gt;
    &lt;li&gt;The IRQs are installed in the IDT&lt;/li&gt;
    &lt;li&gt;Interrupts are enabled&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, is kernel is fully loaded and starts initialization stuff like loading drivers, preparing memory, setting up timers...&lt;/p&gt;
&lt;p&gt;If you want more information about this process, you can read the different source files involved (stage1.asm, stage2.asm, boot_16.cpp, boot_32.cpp and kernel.cpp) and if you have any question, you can comment on this post.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>Operating Systems</category><category>osdev</category><category>thor</category><guid>http://www.baptiste-wicht.com/posts/2013/12/thor-os-boot-process.html</guid><pubDate>Mon, 23 Dec 2013 09:18:01 GMT</pubDate></item><item><title>New hobby project: Thor-OS, 64bit Operating System in C++</title><link>http://www.baptiste-wicht.com/posts/2013/12/new-hobby-project-thor-os-64bit-operating-system-c.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;It's been a long time since I haven't posted on this blog about a project. A bit more than two months ago, I started a new project: thor-os&lt;/p&gt;
&lt;p&gt;This project is a simple 64bit operating system, written in C++. After having written a compiler, I decided it could be fun to try with an operating system. And it is fun indeed :) It is a really exciting project and there are plenty of things to do in every directions.&lt;/p&gt;
&lt;p&gt;I've also written the bootloader myself, but it is a very simple one. It just reads the kernel from the floppy. loads it in memory and then jumps to it and nothing else.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Features&lt;/h4&gt;
&lt;p&gt;Right now, the project is fairly modest. Here are the features of the kernel:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Serial Text Console&lt;/li&gt;
    &lt;li&gt;Keyboard driver&lt;/li&gt;
    &lt;li&gt;Timer driver (PIT)&lt;/li&gt;
    &lt;li&gt;Dynamic Memory Allocation&lt;/li&gt;
    &lt;li&gt;ATA driver&lt;/li&gt;
    &lt;li&gt;FAT32 driver (Work In progress)&lt;/li&gt;
    &lt;li&gt;Draft of an ACPI support (only for shutdown)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All the commands are accessible with a simple shell integrated directly in the kernel.&lt;/p&gt;
&lt;h4&gt;Testing&lt;/h4&gt;

&lt;p&gt;All the testing is made in Bochs and Qemu. I don't have any other computer available to test in real right now but that is something I really want to do. But for now, my bootloader only supports floppy, so it will need to be improved to load the kernel from a disk, since it is not likely that I will have a floppy disk to test :D&lt;/p&gt;
&lt;p&gt;Here is a screenshot of the OS in action:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/wp-content/uploads/2013/12/Screenshot-from-2013-12-17-085810-e1387267703665.png"&gt;&lt;img class="size-medium wp-image-2628" alt="Thor OS Screenshot" src="http://www.baptiste-wicht.com/wp-content/uploads/2013/12/Screenshot-from-2013-12-17-085810-e1387267703665-300x204.png" width="300" height="204"&gt;&lt;/a&gt; Thor OS Screenshot&lt;/p&gt;
&lt;h4&gt;Future&lt;/h4&gt;

&lt;p&gt;The next thing that I will improve is the FAT32 driver to have a complete implementation including creating and writing to files.&lt;/p&gt;
&lt;p&gt;After that, I still don't know whether I will try to implement a simple Framebuffer or start implement user space.&lt;/p&gt;
&lt;p&gt;As for all my projects, you can find the complete source code on Github: https://github.com/wichtounet/thor-os&lt;/p&gt;
&lt;p&gt;Don't hesitate to comment if you have any question or suggestion for this project ;) I will try to write some posts about it on the future, again if you have idea of subject for these posts, don't hesitate. The first will probably be about the boot process.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>Operating Systems</category><category>osdev</category><category>thor</category><guid>http://www.baptiste-wicht.com/posts/2013/12/new-hobby-project-thor-os-64bit-operating-system-c.html</guid><pubDate>Tue, 17 Dec 2013 03:20:16 GMT</pubDate></item><item><title>Memory Manager in 64bits Intel Assembly on Linux</title><link>http://www.baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;For &lt;a title="EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors" href="http://www.baptiste-wicht.com/2012/07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors/"&gt;the last version of the EDDI Compiler&lt;/a&gt;, it has been necessary to extend the dynamic memory allocator, to support free memory. In this post, we will see how to write a simple Memory Manager in Intel Assembly for Linux.&lt;/p&gt;
&lt;p&gt;In the past, we've seen &lt;a title="Dynamic memory allocation in Intel Assembly on Linux" href="http://www.baptiste-wicht.com/2011/11/dynamic-memory-allocation-intel-assembly-linux/"&gt;how to write a basic memory allocator&lt;/a&gt;, this time, we will write a more complete version.&lt;/p&gt;
&lt;p&gt;The implementation is made in 64bits Intel Assembly.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Memory Manager specification&lt;/h4&gt;
&lt;p&gt;The memory will be allocated by blocks. Each block will contain a header with two information:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;A boolean flag indicating if the block is free or not&lt;/li&gt;
    &lt;li&gt;The size of the block (including the header)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each time some memory is asked, the blocks are tested one by one until an available one is found. If no available block is found, a new block is allocated after the last one and this block is returned.&lt;/p&gt;
&lt;p&gt;The memory manager consists of three functions:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;memory_init: Init the memory manager&lt;/li&gt;
    &lt;li&gt;memory_alloc: Allocate the given number of bytes of memory&lt;/li&gt;
    &lt;li&gt;memory_free: Release the given block&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The parameter is passed in the &lt;strong&gt;r14&lt;/strong&gt; register. The return value is returned in the &lt;strong&gt;rax&lt;/strong&gt; register.&lt;/p&gt;
&lt;h4&gt;Global State&lt;/h4&gt;

&lt;p&gt;This implementation needs two global variables. One for the start address of memory and the other one for the last:&lt;/p&gt;
&lt;p&gt;[assembly]section .data&lt;/p&gt;
&lt;p&gt;mem_last dq 0&lt;/p&gt;
&lt;p&gt;mem_start dq 0[/assembly]&lt;/p&gt;
&lt;h4&gt;Init memory Manager&lt;/h4&gt;

&lt;p&gt;The init function is very simple to implement:&lt;/p&gt;
&lt;p&gt;[assembly]init:&lt;/p&gt;
&lt;p&gt;push rbp&lt;/p&gt;
&lt;p&gt;mov rbp, rsp&lt;/p&gt;
&lt;p&gt;mov rax, 12&lt;/p&gt;
&lt;p&gt;xor rdi, rdi&lt;/p&gt;
&lt;p&gt;syscall&lt;/p&gt;
&lt;p&gt;mov [mem_start], rax&lt;/p&gt;
&lt;p&gt;mov [mem_last], rax&lt;/p&gt;
&lt;p&gt;leave&lt;/p&gt;
&lt;p&gt;ret[/assembly]&lt;/p&gt;
&lt;p&gt;We just have to call sys_brk in order to get the location of &lt;em&gt;program break&lt;/em&gt;. Then, the start and the last addresses are the same.&lt;/p&gt;
&lt;h4&gt;Free memory&lt;/h4&gt;

&lt;p&gt;The free function is the simplest one:&lt;/p&gt;
&lt;p&gt;[assembly]free:&lt;/p&gt;
&lt;p&gt;push rbp&lt;/p&gt;
&lt;p&gt;mov rbp, rsp&lt;/p&gt;
&lt;p&gt;mov qword [r14 - 16], 1&lt;/p&gt;
&lt;p&gt;leave&lt;/p&gt;
&lt;p&gt;ret[/assembly]&lt;/p&gt;
&lt;p&gt;The address to free is passed in the &lt;strong&gt;r14&lt;/strong&gt; register. We have to go back 16 bytes (size of the control block) to go to the start of the block. The availability flag is set to 1 (the block is free).&lt;/p&gt;
&lt;h4&gt;The alloc function&lt;/h4&gt;

&lt;p&gt;The alloc function is the most complex:&lt;/p&gt;
&lt;p&gt;[assembly]alloc:&lt;/p&gt;
&lt;p&gt;push rbp&lt;/p&gt;
&lt;p&gt;mov rbp, rsp&lt;/p&gt;
&lt;p&gt;push rdi&lt;/p&gt;
&lt;p&gt;push r10&lt;/p&gt;
&lt;p&gt;push r11&lt;/p&gt;
&lt;p&gt;push r12&lt;/p&gt;
&lt;p&gt;push r13&lt;/p&gt;
&lt;p&gt;push r14&lt;/p&gt;
&lt;p&gt;add r14, 16&lt;/p&gt;
&lt;p&gt;mov r12, [mem_start]&lt;/p&gt;
&lt;p&gt;mov r13, [mem_last]&lt;/p&gt;
&lt;p&gt;.start:&lt;/p&gt;
&lt;p&gt;cmp r12, r13&lt;/p&gt;
&lt;p&gt;je .alloc&lt;/p&gt;
&lt;p&gt;mov r10, [r12]&lt;/p&gt;
&lt;p&gt;mov r11, [r12 + 8]&lt;/p&gt;
&lt;p&gt;cmp r10, 1&lt;/p&gt;
&lt;p&gt;jne .move&lt;/p&gt;
&lt;p&gt;cmp r11, r14&lt;/p&gt;
&lt;p&gt;jl .move&lt;/p&gt;
&lt;p&gt;mov qword [r12], 0&lt;/p&gt;
&lt;p&gt;lea rax, [r12 + 16]&lt;/p&gt;
&lt;p&gt;pop r14&lt;/p&gt;
&lt;p&gt;pop r13&lt;/p&gt;
&lt;p&gt;pop r12&lt;/p&gt;
&lt;p&gt;pop r11&lt;/p&gt;
&lt;p&gt;pop r10&lt;/p&gt;
&lt;p&gt;pop rdi&lt;/p&gt;
&lt;p&gt;leave&lt;/p&gt;
&lt;p&gt;ret&lt;/p&gt;
&lt;p&gt;.move:&lt;/p&gt;
&lt;p&gt;add r12, r11&lt;/p&gt;
&lt;p&gt;jmp .start&lt;/p&gt;
&lt;p&gt;.alloc:&lt;/p&gt;
&lt;p&gt;lea rdi, [r12 + r14]&lt;/p&gt;
&lt;p&gt;mov rax, 12&lt;/p&gt;
&lt;p&gt;syscall&lt;/p&gt;
&lt;p&gt;mov [mem_last], rdi&lt;/p&gt;
&lt;p&gt;mov qword [r12], 0&lt;/p&gt;
&lt;p&gt;mov qword [r12 + 8], r14&lt;/p&gt;
&lt;p&gt;lea rax, [r12 + 16]&lt;/p&gt;
&lt;p&gt;pop r14&lt;/p&gt;
&lt;p&gt;pop r13&lt;/p&gt;
&lt;p&gt;pop r12&lt;/p&gt;
&lt;p&gt;pop r11&lt;/p&gt;
&lt;p&gt;pop r10&lt;/p&gt;
&lt;p&gt;pop rdi&lt;/p&gt;
&lt;p&gt;leave&lt;/p&gt;
&lt;p&gt;ret[/assembly]&lt;/p&gt;
&lt;p&gt;As the function is a bit complex, I will detail it in part:&lt;/p&gt;
&lt;p&gt;[assembly]add r14, 16&lt;/p&gt;
&lt;p&gt;mov r12, [mem_start]&lt;/p&gt;
&lt;p&gt;mov r13, [mem_last]&lt;/p&gt;
&lt;p&gt;.start:&lt;/p&gt;
&lt;p&gt;cmp r12, r13&lt;/p&gt;
&lt;p&gt;je .alloc&lt;/p&gt;
&lt;p&gt;mov r10, [r12]&lt;/p&gt;
&lt;p&gt;mov r11, [r12 + 8]&lt;/p&gt;
&lt;p&gt;cmp r10, 1&lt;/p&gt;
&lt;p&gt;jne .move&lt;/p&gt;
&lt;p&gt;cmp r11, r14&lt;/p&gt;
&lt;p&gt;jl .move&lt;/p&gt;
&lt;p&gt;mov qword [r12], 0&lt;/p&gt;
&lt;p&gt;lea rax, [r12 + 16][/assembly]&lt;/p&gt;
&lt;p&gt;The necessary number of bytes is passed in the &lt;strong&gt;r14&lt;/strong&gt; register. We add 16 bytes (size of the control group) to the size as we also need some place for the header. Then, we load the start and last addresses. If both addresses are equal, we need to allocate more memory (detailed later). Then, we check the size and the availability of the current block. If the size is enough to fit the needs and the block is available, we set it to unavailable. We return the address past the control block (16 bytes).&lt;/p&gt;
&lt;p&gt;[assembly].move:&lt;/p&gt;
&lt;p&gt;add r12, r11&lt;/p&gt;
&lt;p&gt;jmp .start[/assembly]&lt;/p&gt;
&lt;p&gt;To move to the next block, we just have to add the size of the current block to the current block address.&lt;/p&gt;
&lt;p&gt;[assembly].alloc:&lt;/p&gt;
&lt;p&gt;lea rdi, [r12 + r14]&lt;/p&gt;
&lt;p&gt;mov rax, 12&lt;/p&gt;
&lt;p&gt;syscall&lt;/p&gt;
&lt;p&gt;mov [V_mem_last], rdi&lt;/p&gt;
&lt;p&gt;mov qword [r12], 0&lt;/p&gt;
&lt;p&gt;mov qword [r12 + 8], r14&lt;/p&gt;
&lt;p&gt;lea rax, [r12 + 16][/assembly]&lt;/p&gt;
&lt;p&gt;To allocate memory, we compute the new &lt;em&gt;program break&lt;/em&gt; and call &lt;em&gt;sys_brk&lt;/em&gt; again to set the new &lt;em&gt;program break&lt;/em&gt;. The block is then set to not available and the size is set. We return the address past the control block (16 bytes).&lt;/p&gt;
&lt;p&gt;The rest of the program is just here to save and restore the registers and compute the stack frames.&lt;/p&gt;
&lt;h4&gt;Wrap-Up&lt;/h4&gt;

&lt;p&gt;In this article, we saw how to implement a very simple memory manager in 64bits Intel Assembly on Linux. This memory manager is very simple, but has several drawbacks:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;The overhead for small blocks is important. For example, allocating an 8 bytes integer needs a 24 bytes block, thrice the size of the int.&lt;/li&gt;
    &lt;li&gt;In the worst-case scenario, all of the process memory need to be walked across to find a new free block&lt;/li&gt;
    &lt;li&gt;The functions are not thread-safe&lt;/li&gt;
    &lt;li&gt;This algorithm can lead to a lot of memory fragmentation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the future I will try to make a more powerful version of this memory manager.&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;All the functions are available online on the Github Repository:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_alloc.s"&gt;alloc&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_free.s"&gt;free&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_init.s"&gt;init&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They are also available in 32bits Intel Assembly:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_alloc.s"&gt;alloc&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_free.s"&gt;free&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_init.s"&gt;init&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Assembly</category><category>Intel</category><category>Linux</category><guid>http://www.baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html</guid><pubDate>Thu, 02 Aug 2012 08:05:30 GMT</pubDate></item><item><title>Compiler Architecture refinements for eddic</title><link>http://www.baptiste-wicht.com/posts/2012/05/compiler-architecture-refinements-eddic.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;The next version of eddic will see an &lt;strong&gt;improved compiler architecture&lt;/strong&gt;. There are two new main changes in this version:
&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;A better separation between the front end and the back end&lt;/li&gt;
    &lt;li&gt;A new intermediate representation to improve and ease code generation&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Front end and Back End&lt;/h4&gt;

&lt;p&gt;First, the front and back ends have been clearly separated. The general compiler architecture is currently something like that:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/general-architecture/" rel="attachment wp-att-1973"&gt;&lt;img class="aligncenter size-full wp-image-1973" title="EDDI Compiler General Architecture" src="http://www.baptiste-wicht.com/wp-content/uploads/2012/05/general-architecture.svg" alt="EDDI Compiler General Architecture"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The first part didn't change, but the Compiler was part was clearly separated between front and back ends:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/compiler-architecture/" rel="attachment wp-att-1976"&gt;&lt;img class="aligncenter size-full wp-image-1976" title="EDDI Compiler Architecture" src="http://www.baptiste-wicht.com/wp-content/uploads/2012/05/compiler-architecture.svg" alt="EDDI Compiler Architecture"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The backend has no information about the source language. It only sees the intermediate representation provided by the front-end, named: Medium-Level Three Address Code (MTAC).&lt;/p&gt;
&lt;p&gt;There are several advantages to this model. The main one is that it is easy to add support for a new programming language to the compiler. Only the front end needs to be changed. The same can be achieved if a new output is necessary, for example output ARM assembly instead of Intel assembly.&lt;/p&gt;
&lt;h4&gt;New intermediate representation&lt;/h4&gt;

&lt;p&gt;In the previous versions of the compiler, the code generators were fairly complex. Indeed, they had to transform the MTAC intermediate representation directly into assembly. This process involves several things:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;instruction selection&lt;/li&gt;
    &lt;li&gt;register allocation&lt;/li&gt;
    &lt;li&gt;low-level optimization (replace a  mov rax, 0 with xor rax, rax for example)&lt;/li&gt;
    &lt;li&gt;handle basic blocks management&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this version, I decided to change it to a better architecture. This architecture uses a new intermediate representation: Low-Level Three Address Code (LTAC). As its name states, it is a low-level representation, close to assembly. In this  representation there are addresses, registers and abstracted instructions. This representation is platform independent (the differences between 32 and 64 bits are moved to the code generators). There are no more basic blocks here, only functions containing statements.&lt;/p&gt;
&lt;p&gt;The next figure presents the structure of the backend:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/backend-architecture/" rel="attachment wp-att-1977"&gt;&lt;img class="aligncenter size-full wp-image-1977" title="EDDI Compiler Backend architecture" src="http://www.baptiste-wicht.com/wp-content/uploads/2012/05/backend-architecture.svg" alt="EDDI Compiler Backend architecture"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The compiler is responsible for transforming the MTAC Representation in LTAC Representation. It does not do any low-level optimization. The instruction selection is easier as it is platform independent. The peephole optimizer is responsible for the low-levels optimizations. In the 1.0 release, there would be only few things done at this level. In the future, I will try to invest some time to complete it to generate better assembly code. The optimizations are far simpler than the one done in the MTAC optimization engine. Indeed, a peephole optimizer is generally working only in a small window of instructions, like three or four instructions at a time. And finally, the code generators performs the instruction selection process and address resolving. It also has to translate symbolic registers into physical ones.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;I hope that these refinements in the compiler architecture will allow the compiler to produce better code.&lt;/p&gt;
&lt;p&gt;The 1.0 version of the compiler will include another new features:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Basic support for custom structures&lt;/li&gt;
    &lt;li&gt;Global optimizations&lt;/li&gt;
    &lt;li&gt;Some bug fixes found with the new set of unit tests&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As always, feel free to comment on the new architecture, the compiler itself, the project or whatever.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Intel</category><category>Linux</category><guid>http://www.baptiste-wicht.com/posts/2012/05/compiler-architecture-refinements-eddic.html</guid><pubDate>Mon, 07 May 2012 09:34:30 GMT</pubDate></item><item><title>EDDIC 0.9.1 - Enhanced floating point support</title><link>http://www.baptiste-wicht.com/posts/2012/03/eddic-0-9-1-enhanced-floating-point-support.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I just released the version &lt;strong&gt;0.9.1&lt;/strong&gt; of the &lt;strong&gt;EDDI&lt;/strong&gt; Compiler (eddic).&lt;/p&gt;
&lt;p&gt;This release is a minor one, there are no huge changes to the language nor in the compiler itself. But that version was necessary before the 1.0 version. &lt;/p&gt;
&lt;p&gt;The floating point support of the language have been enhanced with casts. You can now cast float values to int and vice-versa. The syntax is the same as in C:&lt;/p&gt;
&lt;p&gt;[cpp]void main(){
   float a = 1.5;
   float b = a + (float) 100;
   println((int)b);
}[/cpp]&lt;/p&gt;
&lt;p&gt;Another improvement is the support for integer suffixes for float: &lt;/p&gt;
&lt;p&gt;[cpp]void main(){
   float a = 100f;
}[/cpp]&lt;/p&gt;
&lt;p&gt;Finally, the optimizer has been adapted to support float as well. The optimization techniques are the same as the one for integers. &lt;/p&gt;
&lt;p&gt;Last but not least, the compiler can now pass some parameters in registers. In 32 bits platform, the first integer parameter is passed in a register and on 64 bits platform, the first two parameters are passed in registers. In both architectures, the first float parameter is passed in a SSE register. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future work&lt;/h4&gt;
&lt;p&gt;The next version will be the &lt;strong&gt;1.0 version&lt;/strong&gt;. There will be several major changes with this new version. &lt;/p&gt;
&lt;p&gt;First, the optimization engine will be almost entirely rewritten. Global optimization will be added to the engine. &lt;/p&gt;
&lt;p&gt;There will also be some improvements in the intermediate representation. I will probably a second level of intermediate representation: a low-level Three Address Code representation. This new intermediate representation will be generated by an &lt;em&gt;IntelCompiler&lt;/em&gt; to handle stuff common to both 32 and 64bits code generator. This will also includes a pass for global register allocation. &lt;/p&gt;
&lt;p&gt;As these changes will not be simple to implement, this version can takes some time before being released. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the compiler sources on the Github repository: &lt;a title="eddic on GitHub" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.9.1 available in the GitHub tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Intel</category><guid>http://www.baptiste-wicht.com/posts/2012/03/eddic-0-9-1-enhanced-floating-point-support.html</guid><pubDate>Fri, 23 Mar 2012 09:16:53 GMT</pubDate></item><item><title>Introduction to 64 Bit Intel Assembly Language Programming for Linux - Book Review</title><link>http://www.baptiste-wicht.com/posts/2012/03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;The first book I read about Intel Assembly was lacking information about 64 bits programming. So I ordered and read &lt;strong&gt;Introduction to 64 Bit Intel Assembly Language Programming for Linux&lt;/strong&gt;, by Ray Seyfarth. &lt;/p&gt;
&lt;p&gt;This book covers a lot of subjects in assembly. It is adapted to people starting assembly, but it also contains advanced assembly programming techniques. I think that this book is adapted to a lot of people wanting to improve their skills in Intel Assembly. This book covers only &lt;strong&gt;64 bit Intel Assembly&lt;/strong&gt; in details. It does not cover old memory models, only the memory mode used now. &lt;/p&gt;
&lt;p&gt;This book uses yasm to assemble the programs. It uses gdb to debug the assembly programs. &lt;/p&gt;
&lt;p&gt;The first chapters are very general. They are covering numbers (octal, decimal and hexadecimal notions), computer memory and memory mapping mode. &lt;/p&gt;
&lt;p&gt;The first technical chapter covers Registers in details. It defines all the registers available in Intel Assembly. You will see how to move constants to registers. You will also learn how to move values between memory and registers. Then, the next chapter covers all the mathematical operations (negate, addition, subtraction, division and multiplication). It also covers the use of conditional move instructions. The next one is about bit manipulations (not, and, or and shift). It also covers bit testing and filling. &lt;/p&gt;
&lt;p&gt;After that, the chapter eight covers a very important subject: branching and looping. All the jumps are covered in details. You will see how to convert each control structure (if, for, while, do-while) of programming language to assembly. After that, the string instructions are also explained. Once you know how to create control structures, it's time to create your own functions. In that chapter, you will learn the stack and the function call conventions. The stack frames and the recursion are also covered. &lt;/p&gt;
&lt;p&gt;The arrays are covered in the next chapter. You will see how to allocate arrays on the stack or on the heap using malloc. The command line parameters are also covered (that was a very interesting part). &lt;/p&gt;
&lt;p&gt;Then, floating point math is covered. For that, the &lt;strong&gt;Streaming SIMD Extensions&lt;/strong&gt; (SSE) are used. All the math operations are covered. As is the way to transfer data between XMM registers and memory. The conversion and comparison instructions are also explained here. Some complete samples like dot product of 3D vectors help us understand the SSE instructions. &lt;/p&gt;
&lt;p&gt;The system calls are covered in details in chapter twelve. The C system library wrapper functions for system calls are also covered. After that, a whole chapter addresses structures. The allocation of structs is also addressed. Then, the way to use I/O streams from assembly is taught. &lt;/p&gt;
&lt;p&gt;A whole chapter is devoted to the implementation of data structures in Intel Assembly. The covered data structures are the linked lists, doubly linked lists, the hash tables and the binary trees. Each common operation on these data structures is implemented. &lt;/p&gt;
&lt;p&gt;After that, the last chapters are about optimization and performances. The chapter 16 covers &lt;strong&gt;High Performance Assembly Programming&lt;/strong&gt; in details. In that chapter, you will learn a set of optimization that can be applied to improve the performances of a given code. For example, you will see how to make efficient use of cache or how to make better performing loops. These optimization can also be applied to other programming languages. The following chapters are all covering a single problem and a way to optimize it the most using Intel Assembly. For each of these problems, the C version is compared to the assembly version. Three problems are presented: counting bits in an array of integers, the Sobel filter and computing the correlation of two variables given some sample values. &lt;/p&gt;
&lt;p&gt;To conclude, I found this book very book. It covers a lot of subjects in a very good manner. I liked a lot the performance techniques covered in the book. The deep coverage of SSE instructions was also very interesting. &lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Assembly</category><category>Books</category><category>Intel</category><guid>http://www.baptiste-wicht.com/posts/2012/03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html</guid><pubDate>Mon, 19 Mar 2012 09:41:54 GMT</pubDate></item><item><title>EDDIC 0.9 - Floating point support</title><link>http://www.baptiste-wicht.com/posts/2012/03/eddic-0-9-floating-point-support.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I just finished working on the &lt;strong&gt;0.9 version&lt;/strong&gt; of the &lt;strong&gt;EDDIC&lt;/strong&gt; Compiler.&lt;/p&gt;
&lt;p&gt;The language does now support &lt;strong&gt;floating point variables&lt;/strong&gt;. Here is an example of what can be done in EDDI now:&lt;/p&gt;
&lt;p&gt;[cpp]void main(){
   float a = 1.5;
   float b = 3.0;
   float c = a + b;
   println(c);
   c = b + 2.75;
   println(c);&lt;/p&gt;
&lt;p&gt;println(test(2.0888, 1.00222));&lt;/p&gt;
&lt;p&gt;float array[7];
   array[0] = 21.999;&lt;/p&gt;
&lt;p&gt;}[/cpp]&lt;/p&gt;
&lt;p&gt;For now, there is no interoperability between integers and floating, so you can't add an integer to a floating point or cast a floating point to an integer. Those features will be added in the 0.9.1 version. The floating point support has been implemented using the Streaming SIMD Extension (SSE) of Intel processors. This won't work on processor that doesn't include support for SSE.&lt;/p&gt;
&lt;p&gt;Another big improvement is that the position of the tokens in the source file are now collected through the parser. When an error or a warning arises during the compilation, the precise position of the error or the warning is printed to the console.&lt;/p&gt;
&lt;p&gt;New options are available for eddic:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;--ast : Print the Abstract Syntax Tree representation of the source&lt;/li&gt;
    &lt;li&gt;--tac : Print the Three Address Code representation of the source&lt;/li&gt;
    &lt;li&gt;--ast-only : Only print the Abstract Syntax Tree representation of the source (do not continue compilation after printing)&lt;/li&gt;
    &lt;li&gt;--tac-only : Only print the Three Address Code representation of the source (do not continue compilation after printing)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And, finally, some improvements have been made to the sources of the project.&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the compiler sources on the Github repository: &lt;a title="eddic on Github" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.9 available in the github tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Intel</category><guid>http://www.baptiste-wicht.com/posts/2012/03/eddic-0-9-floating-point-support.html</guid><pubDate>Wed, 07 Mar 2012 11:47:38 GMT</pubDate></item><item><title>Assembly Language Step By Step, Programming with Linux - Book Review</title><link>http://www.baptiste-wicht.com/posts/2012/02/assembly-language-step-by-step-book-review.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;To improve my skills in Intel Assembly, I ordered and read &lt;strong&gt;Assembly Language Step by Step&lt;/strong&gt;, Programming with Linux, by Jeff Duntemann. Just for the record, I read it on my Amazon Kindle. &lt;/p&gt;
&lt;p&gt;This book is really made for &lt;strong&gt;very&lt;/strong&gt; beginners. The author is fan of metaphor to explain some concepts, comparing assembly to a game he explains in several pages... I didn't liked the writing style of this book. In my opinion, the author uses way too much metaphor and some things takes too many pages to be explained. Another problem of this book is the examples, there are covering tens of pages each. It is a good thing to have complete examples in a book, but having examples of more than 100 lines of code (not counting the comments) in a book is not really convenient (again, only in my opinion). &lt;/p&gt;
&lt;p&gt;Another lack of this book is that it covers only 32 bit programming. For a book written in 2009, it is quite limited. And finally, I found it bad to not cover floating point. I think that this is an important subject. &lt;/p&gt;
&lt;p&gt;Even if I'm not a fan of this book, most of the content is still interesting and you can learn the basis of assembler with it if you're patient with the writing style, the metaphors and the long examples. &lt;/p&gt;
&lt;p&gt;If you are a real beginner in assembly and in programming in general, this book can still be valuable for you. &lt;/p&gt;
&lt;p&gt;The first chapters are covering computer programming, processors, arithmetic in different bases and memory locations. Then, the following chapters are covering the tools (assembler, linker and visual tools for editing and debugging). After that, we are jumping in the heart of the subject by learning arithmetic computations, system calls and stack control. The bits instructions are covered in details in a whole chapter. Then, you will be introduced to the writing of functions and how to use string instructions to simplify your programs. The last (and very big) chapter is about using the functions of the C library to performs work like I/O operations, time calculations, print formatted text and generate random numbers. For this last I would have preferred to learn how to do all that operations using only assembly, but it is important to know how to call C functions. &lt;/p&gt;
&lt;p&gt;To conclude, I will advice this book only to people who learn assembly as their first programming language. For the others, there is a high risk of be deceived. &lt;/p&gt;
&lt;p&gt;Note that, if you want to follow the examples of this book, you'll certainly need the Insight Debugger. You can install this debugger by following the procedure described &lt;a href="http://www.baptiste-wicht.com/2012/01/install-insight-debugger-linux-mint-ubuntu/" title="Install the Insight Debugger on Linux Mint (works for Ubuntu too)"&gt;here&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Assembly</category><category>Intel</category><category>Linux</category><guid>http://www.baptiste-wicht.com/posts/2012/02/assembly-language-step-by-step-book-review.html</guid><pubDate>Fri, 17 Feb 2012 09:21:57 GMT</pubDate></item><item><title>EDDIC 0.8 : 64bit generation</title><link>http://www.baptiste-wicht.com/posts/2012/02/eddic-0-8-64bit-generation.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I just released the version 0.8.&lt;/p&gt;
&lt;p&gt;The main change of this version is the addition of a &lt;strong&gt;64bit generation&lt;/strong&gt;. If you compiles eddic in 64bit, the default output of the compiler will be 64 bit, otherwise it will be 32 bit. You can also select the output by setting command line switch (-32 and -64).&lt;/p&gt;
&lt;p&gt;The biggest change at the side of the language is the support of command line arguments. If the main function is declared as main(string[] args), the args passed from the command line will be accessible.&lt;/p&gt;
&lt;p&gt;I've also added two operators to the language : size() and length(). These operators allows the programmer to get the size of an array, respectively the length of a string. If the information is present at compile-time, the operator is replaced by the constant otherwise it is equivalent to a single memory access.&lt;/p&gt;
&lt;p&gt;I've also made some improvements to the generated x86 code. For example, I'm using string instructions to simplify the generated code and lea and shl to perform fast multiplications. I also changed the syntax used in the generated assembly replacing AT&amp;amp;T syntax by the Intel syntax.&lt;/p&gt;
&lt;p&gt;I've added a new optimization technique, copy propagation. This technique keeps track of the assignment of variables to a variables to simplify the generated three-address-code.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Download&lt;/h4&gt;
&lt;p&gt;You can find the compiler sources on the Github repository : &lt;a title="eddic on Github" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.8 available in the github tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>EDDI</category><category>EDDI</category><category>Intel</category><guid>http://www.baptiste-wicht.com/posts/2012/02/eddic-0-8-64bit-generation.html</guid><pubDate>Thu, 16 Feb 2012 13:44:32 GMT</pubDate></item><item><title>Install the Insight Debugger on Linux Mint (works for Ubuntu too)</title><link>http://www.baptiste-wicht.com/posts/2012/01/install-insight-debugger-linux-mint-ubuntu.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Insight is a very good debugger based on gdb. I prefer it over ddd or kdbg as I find it clearer and easier to use. Moreover, this debugger is also the one used in the book &lt;strong&gt;Assembly language Step by Step, for Linux&lt;/strong&gt;. However, Insight has been removed from Debian packages already more than a year ago. &lt;/p&gt;
&lt;p&gt;But, thanks to SevenMachines, a PPA repository is available to install it on Linux Mint (works also on Ubuntu and Ubuntu-based Linux distributions). &lt;/p&gt;
&lt;p&gt;To add the repository to your apt sources, add the following lines to the /etc/apt/sources.list file:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;deb http://ppa.launchpad.net/sevenmachines/dev/ubuntu natty main 
&lt;p&gt;deb-src http://ppa.launchpad.net/sevenmachines/dev/ubuntu natty main &lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;and update your apt sources: &lt;/p&gt;
&lt;p&gt;[bash]sudo apt-get update[/bash]&lt;/p&gt;
&lt;p&gt;Then you can install insight: &lt;/p&gt;
&lt;p&gt;[bash]sudo apt-get install insight[/bash]&lt;/p&gt;
&lt;p&gt;And now you are ready to use Insight as your debugger. &lt;/p&gt;
&lt;p&gt;If you don't trust this PPA repository, you can also try it to install it from the sources (http://sources.redhat.com/insight/), but doesn't seem to very simple to install it. I wasn't able to build it on my Linux Mint 12. &lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Assembly</category><category>C++</category><category>gcc</category><category>Linux</category><category>Mint</category><category>Tools</category><category>Ubuntu</category><guid>http://www.baptiste-wicht.com/posts/2012/01/install-insight-debugger-linux-mint-ubuntu.html</guid><pubDate>Thu, 26 Jan 2012 09:28:41 GMT</pubDate></item></channel></rss>