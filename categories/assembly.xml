<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Blog blog("Baptiste Wicht"); (Posts about Assembly)</title><link>http://baptiste-wicht.com/</link><description></description><atom:link rel="self" type="application/rss+xml" href="http://baptiste-wicht.com/categories/assembly.xml"></atom:link><language>en</language><lastBuildDate>Sun, 04 Jun 2017 20:17:49 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Thor OS: Boot Process</title><link>http://baptiste-wicht.com/posts/2013/12/thor-os-boot-process.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Some time ago, I started a hobby project: &lt;a title="New hobby project: Thor-OS, 64bit Operating System in C++" href="http://www.baptiste-wicht.com/2013/12/new-hobby-project-thor-os-64bit-operating-system-c/"&gt;writing a new operating system&lt;/a&gt;. I'm not trying to create a concurrent to Linux, I'm just trying to learn some more stuff about operating systems. I'm gonna try to write some posts about this kernel on this blog.&lt;/p&gt;
&lt;p&gt;In this post, I'll describe the boot process I've written for this operating system.&lt;/p&gt;
&lt;h3&gt;Bootloader Step&lt;/h3&gt;

&lt;p&gt;The first step is of course the bootloader. The bootloader is in the MBR and is loaded by the system at 0x7C00.&lt;/p&gt;
&lt;p&gt;I'm doing the bootloading in two stages. The first stage (one sector) print some messages and then load the second stage (one sector) from floppy at 0x900. The goal of doing it in two stages is just to be able to overwrite the bootloader memory by the stage. The second stage loads the kernel into memory from floppy. The kernel is loaded at 0x1000 and then run directly.&lt;/p&gt;
&lt;p&gt;The bootloader stages are written in assembly.&lt;/p&gt;
&lt;h3&gt;Real mode&lt;/h3&gt;

&lt;p&gt;When the processor, it boots in real mode (16 bits) and you have to setup plenty of things before you can go into long mode (64 bits). So the first steps of the kernel are running in 16 bits. The kernel is mostly written in C++ with some inline assembly.&lt;/p&gt;
&lt;p&gt;Here are all the things that are done in this mode:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;The memory is inspected using BIOS E820 function. It is necessary to do that at this point since BIOS function calls are not available after going to protected mode. This function gives a map of the available memory. The map is used later by the dynamic memory allocator.&lt;/li&gt;
    &lt;li&gt;The interrupts are disabled and a fake Interrupt Descriptor Table is configured to make sure no interrupt are thrown in protected mode&lt;/li&gt;
    &lt;li&gt;The Global Descriptor Table is setup. This table describes the different portion of the memory and what each process can do with each portion of the memory. I have three descriptors: a 32bit code segment, a data segment and a 64bit code segment.&lt;/li&gt;
    &lt;li&gt;Protected mode is activated by setting PE bit of CR0 control register.&lt;/li&gt;
    &lt;li&gt;Disable paging&lt;/li&gt;
    &lt;li&gt;Jump to the next step. It is necessary to use a far jump so that the code segment is changed.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Protected Mode&lt;/h3&gt;

&lt;p&gt;At this point, the processor is running in protected mode (32 bits). BIOS interrupts are not available anymore.&lt;/p&gt;
&lt;p&gt;Again, several steps are necessary:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;To be able to use all memory, Physical Address Extensions are activated.&lt;/li&gt;
    &lt;li&gt;Long Mode is enabled by setting the EFER.LME bit.&lt;/li&gt;
    &lt;li&gt;Paging is setup, the first MiB of memory is mapped to the exact same virtual addresses.&lt;/li&gt;
    &lt;li&gt;The address of the Page-Map Level 4 Table is set in the CR0 register.&lt;/li&gt;
    &lt;li&gt;Finally paging is activated.&lt;/li&gt;
    &lt;li&gt;Jump to the real mode kernel, again by using a far jump to change code segment.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Real Mode&lt;/h3&gt;

&lt;p&gt;The kernel finally runs in 64 bits.&lt;/p&gt;
&lt;p&gt;There are still some initialization steps that needs to be done:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;SSE extensions are enabled.&lt;/li&gt;
    &lt;li&gt;The final Interrupt Descriptor Table is setup.&lt;/li&gt;
    &lt;li&gt;ISRs are created for each possible processor exception&lt;/li&gt;
    &lt;li&gt;The IRQs are installed in the IDT&lt;/li&gt;
    &lt;li&gt;Interrupts are enabled&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, is kernel is fully loaded and starts initialization stuff like loading drivers, preparing memory, setting up timers...&lt;/p&gt;
&lt;p&gt;If you want more information about this process, you can read the different source files involved (stage1.asm, stage2.asm, boot_16.cpp, boot_32.cpp and kernel.cpp) and if you have any question, you can comment on this post.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>Operating Systems</category><category>osdev</category><category>thor</category><guid>http://baptiste-wicht.com/posts/2013/12/thor-os-boot-process.html</guid><pubDate>Mon, 23 Dec 2013 08:18:01 GMT</pubDate></item><item><title>New hobby project: Thor-OS, 64bit Operating System in C++</title><link>http://baptiste-wicht.com/posts/2013/12/new-hobby-project-thor-os-64bit-operating-system-c.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;It's been a long time since I have posted on this blog about a project. A bit more than two months ago, I started a new project: thor-os&lt;/p&gt;
&lt;p&gt;This project is a simple 64bit operating system, written in C++. After having written a compiler, I decided it could be fun to try with an operating system. And it is fun indeed :) It is a really exciting project and there are plenty of things to do in every directions.&lt;/p&gt;
&lt;p&gt;I've also written the bootloader myself, but it is a very simple one. It just reads the kernel from the floppy. loads it in memory and then jumps to it and nothing else.&lt;/p&gt;
&lt;h4&gt;Features&lt;/h4&gt;

&lt;p&gt;Right now, the project is fairly modest. Here are the features of the kernel:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Serial Text Console&lt;/li&gt;
    &lt;li&gt;Keyboard driver&lt;/li&gt;
    &lt;li&gt;Timer driver (PIT)&lt;/li&gt;
    &lt;li&gt;Dynamic Memory Allocation&lt;/li&gt;
    &lt;li&gt;ATA driver&lt;/li&gt;
    &lt;li&gt;FAT32 driver (Work In progress)&lt;/li&gt;
    &lt;li&gt;Draft of an ACPI support (only for shutdown)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All the commands are accessible with a simple shell integrated directly in the kernel.&lt;/p&gt;
&lt;h4&gt;Testing&lt;/h4&gt;

&lt;p&gt;All the testing is made in Bochs and Qemu. I don't have any other computer available to test in real right now but that is something I really want to do. But for now, my bootloader only supports floppy, so it will need to be improved to load the kernel from a disk, since it is not likely that I will have a floppy disk to test :D&lt;/p&gt;
&lt;p&gt;Here is a screenshot of the OS in action:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://baptiste-wicht.com/wp-content/uploads/2013/12/Screenshot-from-2013-12-17-085810-e1387267703665.png"&gt;&lt;img class="size-medium wp-image-2628" alt="Thor OS Screenshot" src="http://baptiste-wicht.com/wp-content/uploads/2013/12/Screenshot-from-2013-12-17-085810-e1387267703665-300x204.png" width="300" height="204"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Future&lt;/h4&gt;

&lt;p&gt;The next thing that I will improve is the FAT32 driver to have a complete implementation including creating and writing to files.&lt;/p&gt;
&lt;p&gt;After that, I still don't know whether I will try to implement a simple Framebuffer or start implement user space.&lt;/p&gt;
&lt;p&gt;As for all my projects, you can find the complete source code on Github: https://github.com/wichtounet/thor-os&lt;/p&gt;
&lt;p&gt;Don't hesitate to comment if you have any question or suggestion for this project ;) I will try to write some posts about it on the future, again if you have idea of subject for these posts, don't hesitate. The first will probably be about the boot process.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>Operating Systems</category><category>osdev</category><category>thor</category><guid>http://baptiste-wicht.com/posts/2013/12/new-hobby-project-thor-os-64bit-operating-system-c.html</guid><pubDate>Tue, 17 Dec 2013 02:20:16 GMT</pubDate></item><item><title>Memory Manager in 64bits Intel Assembly on Linux</title><link>http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;For &lt;a title="EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors" href="http://www.baptiste-wicht.com/2012/07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors/"&gt;the last version of the EDDI Compiler&lt;/a&gt;, it has been necessary to extend the dynamic memory allocator, to support free memory. In this post, we will see how to write a simple Memory Manager in Intel Assembly for Linux.&lt;/p&gt;
&lt;p&gt;In the past, we've seen &lt;a title="Dynamic memory allocation in Intel Assembly on Linux" href="http://www.baptiste-wicht.com/2011/11/dynamic-memory-allocation-intel-assembly-linux/"&gt;how to write a basic memory allocator&lt;/a&gt;, this time, we will write a more complete version.&lt;/p&gt;
&lt;p&gt;The implementation is made in 64bits Intel Assembly.&lt;/p&gt;
&lt;h4&gt;Memory Manager specification&lt;/h4&gt;

&lt;p&gt;The memory will be allocated by blocks. Each block will contain a header with two information:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;A boolean flag indicating if the block is free or not&lt;/li&gt;
    &lt;li&gt;The size of the block (including the header)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each time some memory is asked, the blocks are tested one by one until an available one is found. If no available block is found, a new block is allocated after the last one and this block is returned.&lt;/p&gt;
&lt;p&gt;The memory manager consists of three functions:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;memory_init: Init the memory manager&lt;/li&gt;
    &lt;li&gt;memory_alloc: Allocate the given number of bytes of memory&lt;/li&gt;
    &lt;li&gt;memory_free: Release the given block&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The parameter is passed in the &lt;strong&gt;r14&lt;/strong&gt; register. The return value is returned in the &lt;strong&gt;rax&lt;/strong&gt; register.&lt;/p&gt;
&lt;h4&gt;Global State&lt;/h4&gt;

&lt;p&gt;This implementation needs two global variables. One for the start address of memory and the other one for the last:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;section&lt;/span&gt; &lt;span class="nv"&gt;.data&lt;/span&gt;
&lt;span class="nf"&gt;mem_last&lt;/span&gt; &lt;span class="nv"&gt;dq&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;mem_start&lt;/span&gt; &lt;span class="nv"&gt;dq&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;


&lt;h4&gt;Init memory Manager&lt;/h4&gt;

&lt;p&gt;The init function is very simple to implement:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;init:&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nb"&gt;rbp&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nb"&gt;rbp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;rsp&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nf"&gt;xor&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;
&lt;span class="nf"&gt;syscall&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mem_start&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mem_last&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;
&lt;span class="nf"&gt;leave&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We just have to call sys_brk in order to get the location of &lt;em&gt;program break&lt;/em&gt;. Then, the start and the last addresses are the same.&lt;/p&gt;
&lt;h4&gt;Free memory&lt;/h4&gt;

&lt;p&gt;The free function is the simplest one:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;free:&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nb"&gt;rbp&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nb"&gt;rbp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;rsp&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r14&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;leave&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The address to free is passed in the &lt;strong&gt;r14&lt;/strong&gt; register. We have to go back 16 bytes (size of the control block) to go to the start of the block. The availability flag is set to 1 (the block is free).&lt;/p&gt;
&lt;h4&gt;The alloc function&lt;/h4&gt;

&lt;p&gt;The alloc function is the most complex:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;alloc:&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nb"&gt;rbp&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nb"&gt;rbp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;rsp&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;r10&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;
&lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mem_start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mem_last&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;.start:&lt;/span&gt;
&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;
&lt;span class="nf"&gt;je&lt;/span&gt; &lt;span class="nv"&gt;.alloc&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="nv"&gt;r10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;jne&lt;/span&gt; &lt;span class="nv"&gt;.move&lt;/span&gt;
&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
&lt;span class="nf"&gt;jl&lt;/span&gt; &lt;span class="nv"&gt;.move&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;lea&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r10&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;
&lt;span class="nf"&gt;leave&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;

&lt;span class="nl"&gt;.move:&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;
&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="nv"&gt;.start&lt;/span&gt;

&lt;span class="nl"&gt;.alloc:&lt;/span&gt;
&lt;span class="nf"&gt;lea&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nf"&gt;syscall&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mem_last&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
&lt;span class="nf"&gt;lea&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;r10&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;
&lt;span class="nf"&gt;leave&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As the function is a bit complex, I will detail it in part:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mem_start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mem_last&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;.start:&lt;/span&gt;
&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;
&lt;span class="nf"&gt;je&lt;/span&gt; &lt;span class="nv"&gt;.alloc&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="nv"&gt;r10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;jne&lt;/span&gt; &lt;span class="nv"&gt;.move&lt;/span&gt;
&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
&lt;span class="nf"&gt;jl&lt;/span&gt; &lt;span class="nv"&gt;.move&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;lea&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The necessary number of bytes is passed in the &lt;strong&gt;r14&lt;/strong&gt; register. We add 16 bytes (size of the control group) to the size as we also need some place for the header. Then, we load the start and last addresses. If both addresses are equal, we need to allocate more memory (detailed later). Then, we check the size and the availability of the current block. If the size is enough to fit the needs and the block is available, we set it to unavailable. We return the address past the control block (16 bytes).&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.move:&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;
&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="nv"&gt;.start&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;To move to the next block, we just have to add the size of the current block to the current block address.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.alloc:&lt;/span&gt;
&lt;span class="nf"&gt;lea&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="nf"&gt;syscall&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;V_mem_last&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;rdi&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
&lt;span class="nf"&gt;lea&lt;/span&gt; &lt;span class="nb"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;To allocate memory, we compute the new &lt;em&gt;program break&lt;/em&gt; and call &lt;em&gt;sys_brk&lt;/em&gt; again to set the new &lt;em&gt;program break&lt;/em&gt;. The block is then set to not available and the size is set. We return the address past the control block (16 bytes).&lt;/p&gt;
&lt;p&gt;The rest of the program is just here to save and restore the registers and compute the stack frames.&lt;/p&gt;
&lt;h4&gt;Wrap-Up&lt;/h4&gt;

&lt;p&gt;In this article, we saw how to implement a very simple memory manager in 64bits Intel Assembly on Linux. This memory manager is very simple, but has several drawbacks:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;The overhead for small blocks is important. For example, allocating an 8 bytes integer needs a 24 bytes block, thrice the size of the int.&lt;/li&gt;
    &lt;li&gt;In the worst-case scenario, all of the process memory need to be walked across to find a new free block&lt;/li&gt;
    &lt;li&gt;The functions are not thread-safe&lt;/li&gt;
    &lt;li&gt;This algorithm can lead to a lot of memory fragmentation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the future I will try to make a more powerful version of this memory manager.&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;All the functions are available online on the Github Repository:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_alloc.s"&gt;alloc&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_free.s"&gt;free&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_init.s"&gt;init&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They are also available in 32bits Intel Assembly:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_alloc.s"&gt;alloc&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_free.s"&gt;free&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_init.s"&gt;init&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>Assembly</category><category>Intel</category><category>Linux</category><guid>http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html</guid><pubDate>Thu, 02 Aug 2012 06:05:30 GMT</pubDate></item><item><title>Compiler Architecture refinements for eddic</title><link>http://baptiste-wicht.com/posts/2012/05/compiler-architecture-refinements-eddic.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;The next version of eddic will see an &lt;strong&gt;improved compiler architecture&lt;/strong&gt;. There are two new main changes in this version:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;A better separation between the front end and the back end&lt;/li&gt;
    &lt;li&gt;A new intermediate representation to improve and ease code generation&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Front end and Back End&lt;/h4&gt;

&lt;p&gt;First, the front and back ends have been clearly separated. The general compiler architecture is currently something like that:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/general-architecture/" rel="attachment wp-att-1973"&gt;&lt;img class="aligncenter size-full wp-image-1973" title="EDDI Compiler General Architecture" src="http://baptiste-wicht.com/wp-content/uploads/2012/05/general-architecture.svg" alt="EDDI Compiler General Architecture"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The first part didn't change, but the Compiler was part was clearly separated between front and back ends:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/compiler-architecture/" rel="attachment wp-att-1976"&gt;&lt;img class="aligncenter size-full wp-image-1976" title="EDDI Compiler Architecture" src="http://baptiste-wicht.com/wp-content/uploads/2012/05/compiler-architecture.svg" alt="EDDI Compiler Architecture"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The backend has no information about the source language. It only sees the intermediate representation provided by the front-end, named: Medium-Level Three Address Code (MTAC).&lt;/p&gt;
&lt;p&gt;There are several advantages to this model. The main one is that it is easy to add support for a new programming language to the compiler. Only the front end needs to be changed. The same can be achieved if a new output is necessary, for example output ARM assembly instead of Intel assembly.&lt;/p&gt;
&lt;h4&gt;New intermediate representation&lt;/h4&gt;

&lt;p&gt;In the previous versions of the compiler, the code generators were fairly complex. Indeed, they had to transform the MTAC intermediate representation directly into assembly. This process involves several things:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;instruction selection&lt;/li&gt;
    &lt;li&gt;register allocation&lt;/li&gt;
    &lt;li&gt;low-level optimization (replace a  mov rax, 0 with xor rax, rax for example)&lt;/li&gt;
    &lt;li&gt;handle basic blocks management&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this version, I decided to change it to a better architecture. This architecture uses a new intermediate representation: Low-Level Three Address Code (LTAC). As its name states, it is a low-level representation, close to assembly. In this  representation there are addresses, registers and abstracted instructions. This representation is platform independent (the differences between 32 and 64 bits are moved to the code generators). There are no more basic blocks here, only functions containing statements.&lt;/p&gt;
&lt;p&gt;The next figure presents the structure of the backend:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/05/compiler-architecture-refinements-eddic/backend-architecture/" rel="attachment wp-att-1977"&gt;&lt;img class="aligncenter size-full wp-image-1977" title="EDDI Compiler Backend architecture" src="http://baptiste-wicht.com/wp-content/uploads/2012/05/backend-architecture.svg" alt="EDDI Compiler Backend architecture"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The compiler is responsible for transforming the MTAC Representation in LTAC Representation. It does not do any low-level optimization. The instruction selection is easier as it is platform independent. The peephole optimizer is responsible for the low-levels optimizations. In the 1.0 release, there would be only few things done at this level. In the future, I will try to invest some time to complete it to generate better assembly code. The optimizations are far simpler than the one done in the MTAC optimization engine. Indeed, a peephole optimizer is generally working only in a small window of instructions, like three or four instructions at a time. And finally, the code generators performs the instruction selection process and address resolving. It also has to translate symbolic registers into physical ones.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;I hope that these refinements in the compiler architecture will allow the compiler to produce better code.&lt;/p&gt;
&lt;p&gt;The 1.0 version of the compiler will include another new features:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Basic support for custom structures&lt;/li&gt;
    &lt;li&gt;Global optimizations&lt;/li&gt;
    &lt;li&gt;Some bug fixes found with the new set of unit tests&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As always, feel free to comment on the new architecture, the compiler itself, the project or whatever&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Compilers</category><category>EDDI</category><category>Intel</category><category>Linux</category><guid>http://baptiste-wicht.com/posts/2012/05/compiler-architecture-refinements-eddic.html</guid><pubDate>Mon, 07 May 2012 07:34:30 GMT</pubDate></item><item><title>EDDIC 0.9.1 - Enhanced floating point support</title><link>http://baptiste-wicht.com/posts/2012/03/eddic-0-9-1-enhanced-floating-point-support.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;I just released the version &lt;strong&gt;0.9.1&lt;/strong&gt; of the &lt;strong&gt;EDDI&lt;/strong&gt; Compiler (eddic).&lt;/p&gt;
&lt;p&gt;This release is a minor one, there are no huge changes to the language nor in the compiler itself. But that version was necessary before the 1.0 version. &lt;/p&gt;
&lt;p&gt;The floating point support of the language have been enhanced with casts. You can now cast float values to int and vice-versa. The syntax is the same as in C:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Another improvement is the support for integer suffixes for float: &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;100f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Finally, the optimizer has been adapted to support float as well. The optimization techniques are the same as the one for integers. &lt;/p&gt;
&lt;p&gt;Last but not least, the compiler can now pass some parameters in registers. In 32 bits platform, the first integer parameter is passed in a register and on 64 bits platform, the first two parameters are passed in registers. In both architectures, the first float parameter is passed in a SSE register. &lt;/p&gt;
&lt;h4&gt;Future work&lt;/h4&gt;

&lt;p&gt;The next version will be the &lt;strong&gt;1.0 version&lt;/strong&gt;. There will be several major changes with this new version. &lt;/p&gt;
&lt;p&gt;First, the optimization engine will be almost entirely rewritten. Global optimization will be added to the engine. &lt;/p&gt;
&lt;p&gt;There will also be some improvements in the intermediate representation. I will probably a second level of intermediate representation: a low-level Three Address Code representation. This new intermediate representation will be generated by an &lt;em&gt;IntelCompiler&lt;/em&gt; to handle stuff common to both 32 and 64bits code generator. This will also includes a pass for global register allocation. &lt;/p&gt;
&lt;p&gt;As these changes will not be simple to implement, this version can takes some time before being released. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the compiler sources on the Github repository: &lt;a title="eddic on GitHub" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.9.1 available in the GitHub tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>Compilers</category><category>EDDI</category><category>Intel</category><guid>http://baptiste-wicht.com/posts/2012/03/eddic-0-9-1-enhanced-floating-point-support.html</guid><pubDate>Fri, 23 Mar 2012 08:16:53 GMT</pubDate></item><item><title>Introduction to 64 Bit Intel Assembly Language Programming for Linux - Book Review</title><link>http://baptiste-wicht.com/posts/2012/03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;The first book I read about Intel Assembly was lacking information about 64 bits programming. So I ordered and read &lt;strong&gt;Introduction to 64 Bit Intel Assembly Language Programming for Linux&lt;/strong&gt;, by Ray Seyfarth. &lt;/p&gt;
&lt;p&gt;This book covers a lot of subjects in assembly. It is adapted to people starting assembly, but it also contains advanced assembly programming techniques. I think that this book is adapted to a lot of people wanting to improve their skills in Intel Assembly. This book covers only &lt;strong&gt;64 bit Intel Assembly&lt;/strong&gt; in details. It does not cover old memory models, only the memory mode used now. &lt;/p&gt;
&lt;p&gt;This book uses yasm to assemble the programs. It uses gdb to debug the assembly programs. &lt;/p&gt;
&lt;p&gt;The first chapters are very general. They are covering numbers (octal, decimal and hexadecimal notions), computer memory and memory mapping mode. &lt;/p&gt;
&lt;p&gt;The first technical chapter covers Registers in details. It defines all the registers available in Intel Assembly. You will see how to move constants to registers. You will also learn how to move values between memory and registers. Then, the next chapter covers all the mathematical operations (negate, addition, subtraction, division and multiplication). It also covers the use of conditional move instructions. The next one is about bit manipulations (not, and, or and shift). It also covers bit testing and filling. &lt;/p&gt;
&lt;p&gt;After that, the chapter eight covers a very important subject: branching and looping. All the jumps are covered in details. You will see how to convert each control structure (if, for, while, do-while) of programming language to assembly. After that, the string instructions are also explained. Once you know how to create control structures, it's time to create your own functions. In that chapter, you will learn the stack and the function call conventions. The stack frames and the recursion are also covered. &lt;/p&gt;
&lt;p&gt;The arrays are covered in the next chapter. You will see how to allocate arrays on the stack or on the heap using malloc. The command line parameters are also covered (that was a very interesting part). &lt;/p&gt;
&lt;p&gt;Then, floating point math is covered. For that, the &lt;strong&gt;Streaming SIMD Extensions&lt;/strong&gt; (SSE) are used. All the math operations are covered. As is the way to transfer data between XMM registers and memory. The conversion and comparison instructions are also explained here. Some complete samples like dot product of 3D vectors help us understand the SSE instructions. &lt;/p&gt;
&lt;p&gt;The system calls are covered in details in chapter twelve. The C system library wrapper functions for system calls are also covered. After that, a whole chapter addresses structures. The allocation of structs is also addressed. Then, the way to use I/O streams from assembly is taught. &lt;/p&gt;
&lt;p&gt;A whole chapter is devoted to the implementation of data structures in Intel Assembly. The covered data structures are the linked lists, doubly linked lists, the hash tables and the binary trees. Each common operation on these data structures is implemented. &lt;/p&gt;
&lt;p&gt;After that, the last chapters are about optimization and performances. The chapter 16 covers &lt;strong&gt;High Performance Assembly Programming&lt;/strong&gt; in details. In that chapter, you will learn a set of optimization that can be applied to improve the performances of a given code. For example, you will see how to make efficient use of cache or how to make better performing loops. These optimization can also be applied to other programming languages. The following chapters are all covering a single problem and a way to optimize it the most using Intel Assembly. For each of these problems, the C version is compared to the assembly version. Three problems are presented: counting bits in an array of integers, the Sobel filter and computing the correlation of two variables given some sample values. &lt;/p&gt;
&lt;p&gt;To conclude, I found this book very book. It covers a lot of subjects in a very good manner. I liked a lot the performance techniques covered in the book. The deep coverage of SSE instructions was also very interesting.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Books</category><category>Intel</category><guid>http://baptiste-wicht.com/posts/2012/03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html</guid><pubDate>Mon, 19 Mar 2012 08:41:54 GMT</pubDate></item><item><title>EDDIC 0.9 - Floating point support</title><link>http://baptiste-wicht.com/posts/2012/03/eddic-0-9-floating-point-support.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;I just finished working on the &lt;strong&gt;0.9 version&lt;/strong&gt; of the &lt;strong&gt;EDDIC&lt;/strong&gt; Compiler.&lt;/p&gt;
&lt;p&gt;The language does now support &lt;strong&gt;floating point variables&lt;/strong&gt;. Here is an example of what can be done in EDDI now:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;2.75&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

   &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0888&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.00222&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

   &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
   &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;21.999&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;For now, there is no interoperability between integers and floating, so you can't add an integer to a floating point or cast a floating point to an integer. Those features will be added in the 0.9.1 version. The floating point support has been implemented using the Streaming SIMD Extension (SSE) of Intel processors. This won't work on processor that doesn't include support for SSE.&lt;/p&gt;
&lt;p&gt;Another big improvement is that the position of the tokens in the source file are now collected through the parser. When an error or a warning arises during the compilation, the precise position of the error or the warning is printed to the console.&lt;/p&gt;
&lt;p&gt;New options are available for eddic:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;--ast : Print the Abstract Syntax Tree representation of the source&lt;/li&gt;
    &lt;li&gt;--tac : Print the Three Address Code representation of the source&lt;/li&gt;
    &lt;li&gt;--ast-only : Only print the Abstract Syntax Tree representation of the source (do not continue compilation after printing)&lt;/li&gt;
    &lt;li&gt;--tac-only : Only print the Three Address Code representation of the source (do not continue compilation after printing)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And, finally, some improvements have been made to the sources of the project.&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the compiler sources on the Github repository: &lt;a title="eddic on Github" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.9 available in the github tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Compilers</category><category>EDDI</category><category>Intel</category><guid>http://baptiste-wicht.com/posts/2012/03/eddic-0-9-floating-point-support.html</guid><pubDate>Wed, 07 Mar 2012 10:47:38 GMT</pubDate></item><item><title>Assembly Language Step By Step, Programming with Linux - Book Review</title><link>http://baptiste-wicht.com/posts/2012/02/assembly-language-step-by-step-book-review.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;To improve my skills in Intel Assembly, I ordered and read &lt;strong&gt;Assembly Language Step by Step&lt;/strong&gt;, Programming with Linux, by Jeff Duntemann. Just for the record, I read it on my Amazon Kindle. &lt;/p&gt;
&lt;p&gt;This book is really made for &lt;strong&gt;very&lt;/strong&gt; beginners. The author uses a lot of metaphor to explain some concepts, comparing assembly to a game he explains in several pages... I didn't liked the writing style of this book. In my opinion, the author uses way too much metaphor and some things takes too many pages to be explained. Another problem of this book is the examples, there are covering tens of pages each. It is a good thing to have complete examples in a book, but having examples of more than 100 lines of code (not counting the comments) in a book is not really convenient (again, only in my opinion). &lt;/p&gt;
&lt;p&gt;Another lack of this book is that it covers only 32 bit programming. For a book written in 2009, it is quite limited. And finally, I found it bad to not cover floating point. I think that this is an important subject. &lt;/p&gt;
&lt;p&gt;Even if I'm not a fan of this book, most of the content is still interesting and you can learn the basis of assembler with it if you're patient with the writing style, the metaphors and the long examples. &lt;/p&gt;
&lt;p&gt;If you are a real beginner in assembly and in programming in general, this book can still be valuable for you. &lt;/p&gt;
&lt;p&gt;The first chapters are covering computer programming, processors, arithmetic in different bases and memory locations. Then, the following chapters are covering the tools (assembler, linker and visual tools for editing and debugging). After that, we are jumping in the heart of the subject by learning arithmetic computations, system calls and stack control. The bits instructions are covered in details in a whole chapter. Then, you will be introduced to the writing of functions and how to use string instructions to simplify your programs. The last (and very big) chapter is about using the functions of the C library to performs work like I/O operations, time calculations, print formatted text and generate random numbers. For this last I would have preferred to learn how to do all that operations using only assembly, but it is important to know how to call C functions. &lt;/p&gt;
&lt;p&gt;To conclude, I will advice this book only to people who learn assembly as their first programming language. For the others, there is a high risk of be deceived. &lt;/p&gt;
&lt;p&gt;Note that, if you want to follow the examples of this book, you'll certainly need the Insight Debugger. You can install this debugger by following the procedure described &lt;a href="http://www.baptiste-wicht.com/2012/01/install-insight-debugger-linux-mint-ubuntu/" title="Install the Insight Debugger on Linux Mint (works for Ubuntu too)"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Intel</category><category>Linux</category><guid>http://baptiste-wicht.com/posts/2012/02/assembly-language-step-by-step-book-review.html</guid><pubDate>Fri, 17 Feb 2012 08:21:57 GMT</pubDate></item><item><title>EDDIC 0.8 : 64bit generation</title><link>http://baptiste-wicht.com/posts/2012/02/eddic-0-8-64bit-generation.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;I just released the version 0.8.&lt;/p&gt;
&lt;p&gt;The main change of this version is the addition of a &lt;strong&gt;64bit generation&lt;/strong&gt;. If you compiles eddic in 64bit, the default output of the compiler will be 64 bit, otherwise it will be 32 bit. You can also select the output by setting command line switch (-32 and -64).&lt;/p&gt;
&lt;p&gt;The biggest change at the side of the language is the support of command line arguments. If the main function is declared as main(string[] args), the args passed from the command line will be accessible.&lt;/p&gt;
&lt;p&gt;I've also added two operators to the language : size() and length(). These operators allows the programmer to get the size of an array, respectively the length of a string. If the information is present at compile-time, the operator is replaced by the constant otherwise it is equivalent to a single memory access.&lt;/p&gt;
&lt;p&gt;I've also made some improvements to the generated x86 code. For example, I'm using string instructions to simplify the generated code and lea and shl to perform fast multiplications. I also changed the syntax used in the generated assembly replacing AT&amp;amp;T syntax by the Intel syntax.&lt;/p&gt;
&lt;p&gt;I've added a new optimization technique, copy propagation. This technique keeps track of the assignment of variables to a variables to simplify the generated three-address-code.&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the compiler sources on the Github repository : &lt;a title="eddic on Github" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.8 available in the github tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>EDDI</category><category>Intel</category><guid>http://baptiste-wicht.com/posts/2012/02/eddic-0-8-64bit-generation.html</guid><pubDate>Thu, 16 Feb 2012 12:44:32 GMT</pubDate></item><item><title>Install the Insight Debugger on Linux Mint (works for Ubuntu too)</title><link>http://baptiste-wicht.com/posts/2012/01/install-insight-debugger-linux-mint-ubuntu.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Insight is a very good debugger based on gdb. I prefer it over ddd or kdbg as I find it clearer and easier to use. Moreover, this debugger is also the one used in the book &lt;strong&gt;Assembly language Step by Step, for Linux&lt;/strong&gt;. However, Insight has been removed from Debian packages already more than a year ago. &lt;/p&gt;
&lt;p&gt;But, thanks to SevenMachines, a PPA repository is available to install it on Linux Mint (works also on Ubuntu and Ubuntu-based Linux distributions). &lt;/p&gt;
&lt;p&gt;To add the repository to your apt sources, add the following lines to the /etc/apt/sources.list file:&lt;/p&gt;
&lt;pre&gt;deb http://ppa.launchpad.net/sevenmachines/dev/ubuntu natty main 
deb-src http://ppa.launchpad.net/sevenmachines/dev/ubuntu natty main &lt;/pre&gt;

&lt;p&gt;and update your apt sources: &lt;/p&gt;
&lt;pre&gt;sudo apt-get update&lt;/pre&gt;

&lt;p&gt;Then you can install insight: &lt;/p&gt;
&lt;pre&gt;sudo apt-get install insight&lt;/pre&gt;

&lt;p&gt;And now you are ready to use Insight as your debugger. &lt;/p&gt;
&lt;p&gt;If you don't trust this PPA repository, you can also try it to install it from the sources (http://sources.redhat.com/insight/), but doesn't seem to very simple to install it. I wasn't able to build it on my Linux Mint 12.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>gcc</category><category>Linux</category><category>Mint</category><category>Tools</category><guid>http://baptiste-wicht.com/posts/2012/01/install-insight-debugger-linux-mint-ubuntu.html</guid><pubDate>Thu, 26 Jan 2012 08:28:41 GMT</pubDate></item><item><title>Dynamic memory allocation in Intel Assembly on Linux</title><link>http://baptiste-wicht.com/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;For the version 0.6.0 of the EDDI Compiler, I have written a simple dynamic memory allocation function in assembly. I did that to avoid using malloc in my assembly code. As this is not an easy subject, this article will explain the main parts of writing this function.&lt;/p&gt;
&lt;p&gt;As the EDDI Compiler creates program for Linux platform, this article will focus on writing a little memory allocator for Linux in Intel Assembly.&lt;/p&gt;
&lt;p&gt;In this article I will follow the &lt;em&gt;AT&amp;amp;T notation&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Specifications&lt;/h4&gt;

&lt;p&gt;The function works like malloc but is simpler. The specifications are the following ones:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;We call the function with one argument: the dynamic memory size we need&lt;/li&gt;
    &lt;li&gt;The function returns the start address of the allocated memory in the &lt;strong&gt;%eax&lt;/strong&gt; register&lt;/li&gt;
    &lt;li&gt;There is no need to deallocate the allocated memory&lt;/li&gt;
    &lt;li&gt;The size that we ask will generally small and always less than 16384 octets&lt;/li&gt;
    &lt;li&gt;Having some gaps in the memory is not a problem for now&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So as you can see there are several limitations to this memory allocator. These limitations are the one I had for EDDI, so I'll follow them in this article.&lt;/p&gt;
&lt;h4&gt;Dynamic memory allocation&lt;/h4&gt;

&lt;p&gt;In Linux, there are two ways for performing dynamic memory allocation:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;brk&lt;/strong&gt;: Increment the size of the data segment after the end of the program. This memory is directly after the program and is always contiguous. It's the easiest way for allocating memory. This technique is not perfect for large blocks of data.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;mmap&lt;/strong&gt;: Creates a new memory mapping in the virtual address space. The kernel gives you memory in virtually every place of the memory.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In our case, as we need only small blocks, we will use &lt;strong&gt;brk&lt;/strong&gt; to dynamically allocate memory.&lt;/p&gt;
&lt;p&gt;We can call these procedures using system calls. In assembly, you can use system calls with interruptions (0x80).&lt;/p&gt;
&lt;h4&gt;Implementation&lt;/h4&gt;

&lt;p&gt;We need two variables for this function. One to keep track of the remaining size and another one to keep track of the current address of the allocated memory.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.data&lt;/span&gt;
&lt;span class="na"&gt;.size&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="nl"&gt;VIeddi_remaining:&lt;/span&gt;
&lt;span class="na"&gt;.long&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="na"&gt;.size&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="nl"&gt;VIeddi_current:&lt;/span&gt;
&lt;span class="na"&gt;.long&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Both variables are initialized to 0.&lt;/p&gt;
&lt;p&gt;And here is the function I've developed :&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;eddi_alloc:&lt;/span&gt;
&lt;span class="nf"&gt;pushl&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%ebp&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;cmpl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;
&lt;span class="nf"&gt;jle&lt;/span&gt; &lt;span class="no"&gt;alloc_normal&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;xorl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt;  &lt;span class="no"&gt;$0x80&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="no"&gt;$16384&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt;  &lt;span class="no"&gt;$0x80&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$16384&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;

&lt;span class="nl"&gt;alloc_normal:&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;subl&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;
&lt;span class="nf"&gt;leave&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;I will describe now each part of the alloc function.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%ebp&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;cmpl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;
&lt;span class="nf"&gt;jle&lt;/span&gt; &lt;span class="no"&gt;alloc_normal&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In this part we test if there is enough remaining size for the dynamic memory allocation request. It's equivalent to &lt;em&gt;if(remaining &amp;gt;= size)&lt;/em&gt;. If there is enough size, we jump to the normal allocation part :&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;alloc_normal:&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;subl&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;First, we move the current address of memory into the &lt;strong&gt;%eax&lt;/strong&gt; register for the return value. Then we add the size of the new allocated block to the current address. Finally we remove the size of the new allocated block from the remaining size. After that, we can leave the function.&lt;/p&gt;
&lt;p&gt;The most interesting part is what we do when we have to allocate more memory :&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;xorl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt;  &lt;span class="no"&gt;$0x80&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="no"&gt;$16384&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt;  &lt;span class="no"&gt;$0x80&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$16384&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_remaining&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;VIeddi_current&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We start by doing an interruption to execute a system call. The &lt;strong&gt;45&lt;/strong&gt; in the &lt;strong&gt;%eax&lt;/strong&gt; register indicates a &lt;strong&gt;sys_brk&lt;/strong&gt; call. The 0 in the &lt;strong&gt;%ebx&lt;/strong&gt; register, indicates that we want the current position of brk space. We save this current position into the &lt;strong&gt;%esi&lt;/strong&gt; register. Then we add 16384 bits (4K octets) to this address. We call again the &lt;strong&gt;sys_brk&lt;/strong&gt; routine to set the address of the brk space to the calculated address. This is the way to dynamically allocates 4K of memory. Finally, we add 4K to the remaining size in octets and we put the current address (before the add) as the current address.&lt;/p&gt;
&lt;h4&gt;Possible improvements&lt;/h4&gt;

&lt;p&gt;We should make some optimization if this function has to be invoked frequently. The first interruption (call to sys_brk) has only to be done once. The very first time we need to get the start address. Then, we can use the current address as the base address when we do the new allocation.&lt;/p&gt;
&lt;p&gt;Another improvement is to avoid having gaps between the used blocks. For that, we can avoid setting the current address directly to the newly allocated address but just add 4K to the remaining size. The blocks will overlap 2 allocated blocks.&lt;/p&gt;
&lt;p&gt;We could also check that the value returned by the &lt;strong&gt;sys_brk&lt;/strong&gt; is valid. On error, the procedure can return -1.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;In this post, we developed a basic dynamic memory allocation function in Intel assembly on the Linux platform. I hope that this information can helps some of you.&lt;/p&gt;
&lt;p&gt;Don't hesitate if you have a question or a comment on my implementation.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>EDDI</category><category>Intel</category><category>Linux</category><guid>http://baptiste-wicht.com/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html</guid><pubDate>Tue, 29 Nov 2011 08:16:26 GMT</pubDate></item><item><title>How to print strings and integers in Intel Assembly on Linux ?</title><link>http://baptiste-wicht.com/posts/2011/11/print-strings-integers-intel-assembly.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;In this post, we'll learn how to print strings and integers to the console on Linux using Intel Assembly. In this post, I'll use the AT&amp;amp;T notation, because it's the notation used in EDDI. &lt;/p&gt;
&lt;p&gt;In EDDI, I have to print strings and numbers to the console, as this is not an easy exercise, I wanted to share my experience here. &lt;/p&gt;
&lt;p&gt;On Linux, the only way to print something on the console is to use a system call. For that, we have to use the 0x08 interrupt code. &lt;/p&gt;
&lt;h4&gt;Declare strings&lt;/h4&gt;

&lt;p&gt;First, we'll see how to declare strings in an Intel Assembly file. You can use the &lt;strong&gt;.string&lt;/strong&gt; instruction to achieve that : &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;StringToPrint:&lt;/span&gt;
&lt;span class="na"&gt;.string&lt;/span&gt; &lt;span class="s"&gt;"Hello"&lt;/span&gt;
&lt;/pre&gt;


&lt;h4&gt;Print strings&lt;/h4&gt;

&lt;p&gt;Then, to print, we will call the &lt;em&gt;sys_write&lt;/em&gt; system call : &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$StringToPrint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%edx&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt; &lt;span class="no"&gt;$0x80&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The value in &lt;strong&gt;%eax&lt;/strong&gt; (4) indicates the system call we need (&lt;em&gt;sys_write&lt;/em&gt;). The 1 in &lt;strong&gt;%ebx&lt;/strong&gt; indicates that we want to write in the console. Finally the two last parameters indicates the string to print and the size of the string. In Intel assembly, the &lt;strong&gt;int&lt;/strong&gt; instruction launch an interrupt and the 0x80 in the interrupt table is set to the system call in the Linux Kernel. &lt;/p&gt;
&lt;p&gt;As you can see, this code does use 4 registers and does not save any of them. Ideally, you will save the registers before and restore them. It depends on when you use this routine. &lt;/p&gt;
&lt;h4&gt;Print integers&lt;/h4&gt;

&lt;p&gt;Writing an integer is a bit more complicated. If you have the integer in the string, there is no problem, but if you have only a long on your assembly, you'll have to convert the int into a string to print it. We will convert the integer char after char and use the stack as storage for our string. Then every char will be printed to the console using the same system as before. &lt;/p&gt;
&lt;p&gt;So let's say we have our number in the &lt;strong&gt;%eax&lt;/strong&gt; register : &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$9234&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So let's take a look at the code : &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;xorl&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;

&lt;span class="nl"&gt;loop:&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%edx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;divl&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="no"&gt;$48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%edx&lt;/span&gt;
&lt;span class="nf"&gt;pushl&lt;/span&gt; &lt;span class="nv"&gt;%edx&lt;/span&gt;
&lt;span class="nf"&gt;incl&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;
&lt;span class="nf"&gt;cmpl&lt;/span&gt; &lt;span class="no"&gt;$0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;jz&lt;/span&gt;   &lt;span class="no"&gt;next&lt;/span&gt;
&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="no"&gt;loop&lt;/span&gt;

&lt;span class="nl"&gt;next:&lt;/span&gt;
&lt;span class="nf"&gt;cmpl&lt;/span&gt; &lt;span class="no"&gt;$0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;
&lt;span class="nf"&gt;jz&lt;/span&gt;   &lt;span class="no"&gt;exit&lt;/span&gt;
&lt;span class="nf"&gt;decl&lt;/span&gt; &lt;span class="nv"&gt;%esi&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%edx&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt;  &lt;span class="no"&gt;$0x80&lt;/span&gt;
&lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="no"&gt;$4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;
&lt;span class="nf"&gt;jmp&lt;/span&gt;  &lt;span class="no"&gt;next&lt;/span&gt;

&lt;span class="nl"&gt;exit:&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The first part of the code consists in dividing the value by 10 until we reach zero. The remainder of the division is pushed onto the stack. For example, for our number, after this part, we'll have 4-3-2-9 on the stack. The order is reversed, which is logic because we stack the remainders from the right. During this phase, we count the number of elements using the &lt;strong&gt;%esi&lt;/strong&gt; register. &lt;/p&gt;
&lt;p&gt;Once this is done, we print each characters one by one starting with the last that has been pushed. Here we decrement the counter for each char and we use the &lt;strong&gt;sys_write&lt;/strong&gt; call with &lt;strong&gt;%esp&lt;/strong&gt; as the address of the string of one character. After each character, we incremetn the &lt;strong&gt;%esp&lt;/strong&gt; to cancel the push that we used. &lt;/p&gt;
&lt;p&gt;We have to do this in two phases in order to get the characters in the good order and not in reverse order. &lt;/p&gt;
&lt;h4&gt;Handle negative numbers&lt;/h4&gt;

&lt;p&gt;As you may have noticed, we do not manage negative numbers in our code. They will be printed, but it will be positive number. Indeed, in Intel Assembly (and in processors in general), negative numbers are handled with two's complement. Handling negative numbers in our code is not a big deal. We can add this code at the beginning : &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;cmpl&lt;/span&gt; &lt;span class="no"&gt;$0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;jge&lt;/span&gt; &lt;span class="no"&gt;loop&lt;/span&gt;
&lt;span class="nf"&gt;neg&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;pushl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="c"&gt;; Print "-" &lt;/span&gt;
&lt;span class="nf"&gt;popl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;First of all, we check if the number is smaller than 0, if it's not the case, we directly jump to the code we used before. If it's smaller, we negate the number and print a - before printing the real number. We have to save the &lt;strong&gt;%eax&lt;/strong&gt; register before printing the - character because &lt;strong&gt;%eax&lt;/strong&gt; is used for printing. &lt;/p&gt;
&lt;p&gt;You'll now have a complete procedure to print an integer on the console in assembly. &lt;/p&gt;
&lt;p&gt;I hope that this could be of some help for somebody.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>EDDI</category><category>Intel</category><category>Linux</category><guid>http://baptiste-wicht.com/posts/2011/11/print-strings-integers-intel-assembly.html</guid><pubDate>Wed, 23 Nov 2011 08:11:59 GMT</pubDate></item><item><title>eddic 0.5.1 : Better assembly generation and faster parsing</title><link>http://baptiste-wicht.com/posts/2011/11/eddic-0-5-1-better-assembly-generation-and-faster-parsing.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;I'm very pleased to release the version 0.5.1 of the EDDI Compiler.&lt;/p&gt;
&lt;p&gt;It makes now a long time since the last version of eddic, but I started again working frequently on it. This version doesn't add any new feature to the language, but there are a lot of improvements in the compiler itself. &lt;/p&gt;
&lt;p&gt;First of all, the generated assembly has been improved a lot. I use now a intermediate representation of assembly and then the compiler is able to make more optimizations in its choice. This optimization is especially visible for integer computations. Before this, all the computations used stack operations and then we use almost only registers when it's possible. It's still not perfect, but it uses way less instructions. Moreover, this can enable me to write a 64 assembly code instead of 32 and provide both versions in the compiler. &lt;/p&gt;
&lt;p&gt;Another improvement is the speed of the parser. I now use Boost Spirit to parse the source file and construct an Abstract Syntax Tree. This parsing is very fast now (with some optimizations). Moreover, it will be easier to add new constructs later. &lt;/p&gt;
&lt;p&gt;I also improved the general performances at some places. I also use Boost Program Options to parse the command line options. &lt;/p&gt;
&lt;p&gt;In the next version (0.6.0), I will introduce arrays of int and strings and the foreach construct for array. I will also remove the dependency to malloc writing a memory allocation manager in assembly. I will also introduce warnings in the compiler. &lt;/p&gt;
&lt;p&gt;You can find the compiler sources on the Github repository : &lt;a title="EDDI COmpiler Repository" href="http://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;The compiler now needs Boost 1.47.0 to build. &lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.5.1 available in the github tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Boost</category><category>C++</category><category>EDDI</category><category>Performances</category><category>Releases</category><category>templates</category><guid>http://baptiste-wicht.com/posts/2011/11/eddic-0-5-1-better-assembly-generation-and-faster-parsing.html</guid><pubDate>Thu, 10 Nov 2011 03:33:32 GMT</pubDate></item><item><title>EDDI 0.4.1 : Loops and better assembly generation</title><link>http://baptiste-wicht.com/posts/2011/07/eddi-0-4-1-loops-and-better-assembly-generation.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;I just released the 0.4.1 version of the EDDI compiler.&lt;/p&gt;
&lt;p&gt;This version introduce two kind of loops :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the while loop&lt;/li&gt;
&lt;li&gt;the for loop, in its general form with three expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moreover, you can now use parenth in mathematical expressions.&lt;/p&gt;
&lt;p&gt;That's it for the new features, but the compiler has been greatly improved. Now the scope of variables is managed, so you can have twice the same variables as long as they are not visible at the same time.&lt;/p&gt;
&lt;p&gt;For the assembly, there have been many improvements. The variables are not stored in a more efficient way, the concatenation of strings has been improved to take less space and other little changes have been made. The Lexer has been rewritten using a Scanner to manage the source file directly so that the error do now give the line and the column of the error source. The Parser and the Compiler itself have had some refactorings, but nothing really big.&lt;/p&gt;
&lt;p&gt;You can find the compiler on the Github repository : &lt;a href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.4.1 available in the github tags.&lt;/p&gt;
&lt;p&gt;The next version will certainly see more loops versions, some assembly refinements and perhaps first kind of function calls. I will also try to escalate the Token information in order to have better reporting when there are semantic errors. I will also some refactorings in the parse node to have a better integration of the Condition and the StringPool.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>EDDI</category><category>Releases</category><guid>http://baptiste-wicht.com/posts/2011/07/eddi-0-4-1-loops-and-better-assembly-generation.html</guid><pubDate>Thu, 28 Jul 2011 07:06:50 GMT</pubDate></item><item><title>EDDI 0.4 : Native compilation and swap operator</title><link>http://baptiste-wicht.com/posts/2011/07/eddi-0-4-native-compilation-swap.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;The version 0.4 of EDDI is released. &lt;/p&gt;
&lt;p&gt;There is only one new feature, the swap operator () to swap two variables together, but the biggest news is that now EDDI is not anymore an interpreted language, but is a compiled language. &lt;/p&gt;
&lt;p&gt;In fact, I rewritten the compiler in order to output Linux assembly code. For now the code is only 32 bits, but I plan to support 64 as well. I made that change in order to not having to write a virtual machine and in order to learn assembly as well. The current outputted assembly code is not really optimized and there will certainly be a lot of changes. Indeed, in order to simplify the switch to native compiler, I continued using stack operations, so that the numeric computations have a lot have a lot of stack operations in it. Moreover, I'm far from being a professional in assembly, so that, they can beginner's errors in the generated code. &lt;/p&gt;
&lt;p&gt;I use as to compile the assembly and then gcc to link. I will try to not depend on gcc, but it seems to be difficult if I want to use malloc (used for the string concatenation). &lt;/p&gt;
&lt;p&gt;You can download the sources and find some information on the GitHub repository : https://github.com/wichtounet/eddic/ (check the tag v0.4 if you want the exact version I refer in this post). &lt;/p&gt;
&lt;p&gt;Do not hesitate to send me your comments about the C++ code, the design or the outputted assembly. &lt;/p&gt;
&lt;p&gt;The first version will see loops integrated, certainly some assembly optimizations and some code refactorings I planned.&lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>C++</category><category>EDDI</category><category>Intel</category><category>Releases</category><guid>http://baptiste-wicht.com/posts/2011/07/eddi-0-4-native-compilation-swap.html</guid><pubDate>Wed, 20 Jul 2011 07:27:13 GMT</pubDate></item></channel></rss>