<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>@Blog("Baptiste Wicht") (EDDI)</title><link>http://wichtounet.github.io/</link><description></description><atom:link type="application/rss+xml" rel="self" href="http://wichtounet.github.io/categories/eddi.xml"></atom:link><language>en</language><lastBuildDate>Sun, 16 Mar 2014 21:44:29 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Improving eddic Boost Spirit parser performances</title><link>http://wichtounet.github.io/posts/2013/06/improving-eddic-boost-spirit-parser-performances.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;After the last changes on the data-flow framework, the parsing pass of the eddic compiler became the slowest one. I was sure there was some area of optimizations, so I decided to improve its performances.&lt;/p&gt;
&lt;p&gt;In this post, I will present the different techniques I applied and their results.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Static grammar&lt;/h4&gt;
&lt;p&gt;The first optimization that I tried was to make the grammar static, meaning that we can declare it static and it will be constructed only once and will be allocated on the data segment.It is indeed heavy to build the lexer especially but also the grammar. I would like to thank &lt;a title="sehe on github" href="https://github.com/sehe"&gt;sehe&lt;/a&gt; for this optimization, he found it after I posted a question on Stackoverflow.&lt;/p&gt;
&lt;p&gt;The lexer was very easy to make static (only add static keyword :) ), but the parser was a bit more complicated because it needs the lexer iterator to get the current position in the file. This problem has been resolved by saving the iterator into the qi::locals of the rules.&lt;/p&gt;
&lt;p&gt;The result of this optimization are amazing. It saved 33% of the time.&lt;/p&gt;
&lt;h4&gt;Expectation points&lt;/h4&gt;

&lt;p&gt;Expectation points have the interesting point that they disallow backtracking and so can improve performances in some cases. Moreover, they are always interesting because they make the grammar clearer and the error messages much better.&lt;/p&gt;
&lt;p&gt;I tried adding more expectation points to the grammar. Unfortunately, there weren't a lot of them to add. Moreover, it seems that there are some quite weird behavior with them because some times it is impossible to add them (causes compilation failure) and sometimes it just make the code don't work anymore the same way, though I don't understand why.&lt;/p&gt;
&lt;p&gt;Anyway, I have been able to add some to the grammar. These changes improve the performance by a bit more than 1%. It is not a lot, but it is still an improvement. Moreover, I'm quite sure that there are more expectation points that can be added to the code. I will take some time again later to try to add more and to understand them better.&lt;/p&gt;
&lt;h4&gt;Less skips&lt;/h4&gt;

&lt;p&gt;In my grammar, I've a special parser for getting the current position in the file to add "debug information" to the AST. This special parser was skipping over its content, but it has no content, since it is artificial. Removing it improved the performance by about half a percent.&lt;/p&gt;
&lt;h4&gt;Improve Position (debug information)&lt;/h4&gt;

&lt;p&gt;As said before, there is a special parser to get the current position in the file. This information is then stored into an eddic::ast::Position structure. This structure was holding the line number, the column, the file name and the contents of the line. The first two were ints and the last two were std::string. Each time, a copy of the strings were necessary.&lt;/p&gt;
&lt;p&gt;I avoided storing the std::string directly by storing only the number of the line as well as the index of the file. Then, the content of the file is stored in the global context and can be accessed if it is necessary to display the line where the error happened.&lt;/p&gt;
&lt;p&gt;This change gave an increase of 10% of the parsing performance.&lt;/p&gt;
&lt;h4&gt;Auto Rules&lt;/h4&gt;

&lt;p&gt;Rules in Boost Spirit have an overhead due to the cost of the virtual calls that are necessary. In theory, auto rules can improve the efficiency of the rules by removing the cost of virtual calls. Moreover, auto rules should also avoid code bloat when the rules are compiled. The rules can be inlined and better optimized.&lt;/p&gt;
&lt;p&gt;I transformed some rules to auto rules to improve performances. Unfortunately, I found that this did not improve the performances. Moreover, transforming some rules to auto rules made the performance worse. I still did let some of the rules as auto rules. I have to say that I was very disappointed by this result, I was really expecting more from this :(&lt;/p&gt;
&lt;h4&gt;Generated Static Lexer&lt;/h4&gt;

&lt;p&gt;The first time the lexer is used, it has to generate the Deterministic Finite Automaton (DFA) that is used to identify the different tokens. This process takes time. There is way to avoid this by using the static model of Boost Spirit Lex. With that, the code is generated with the complete DFA and then it doesn't have to be initialized again.&lt;/p&gt;
&lt;p&gt;I was not expecting a lot from this because the lexer was already static and so was initialized only once. Indeed, it resulted in less than half a percent improvement.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;Even if I've been able to largely reduce the overhead of the parsing by more than 40%, it still has a big overhead. Indeed, it still represents 36 percent of the whole process of compiling a source file. I think it is still too much.&lt;/p&gt;
&lt;p&gt;Moreover, an interesting fact is that the optimization I would have thought to be very effective (auto rules especially) did not have the expected effect, but making the grammar static, which I would not have thought of, was very effective.&lt;/p&gt;
&lt;p&gt;When profiled, the final version shows that quite some time is spent in destructing the multi_pass, which is quite odd. And it also seems that transforming the string operators to ast::Operator is not very effective, but I do not know how to improve that at this point.&lt;/p&gt;
&lt;p&gt;I won't probably work on that again for the version 1.2.4 of eddic, but I will eventually take some time again for the version 1.3.0 to improve it again.&lt;/p&gt;&lt;/div&gt;</description><category>Benchmarks</category><category>Boost</category><category>C++11</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Performances</category><guid>http://wichtounet.github.io/posts/2013/06/improving-eddic-boost-spirit-parser-performances.html</guid><pubDate>Mon, 10 Jun 2013 08:16:42 GMT</pubDate></item><item><title>Some news</title><link>http://wichtounet.github.io/posts/2013/06/some-news.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;No, I'm not dead ;)&lt;/p&gt;
&lt;p&gt;After having finished my Master thesis in March, I took a break from my personal projects including this project. I then started a job in my school, waiting for a Ph.D thesis. I'm now working on a very interesting Machine Learning project about Speech, unfortunately in Java ;)&lt;/p&gt;
&lt;p&gt;I just started again working on eddic this week. I'm gonna try to improve as much as possible the performances of the parser. I will also try to post again some articles on this blog, although I don't know about what. &lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>EDDI</category><category>Java</category><category>Machine Learning</category><category>Others</category><guid>http://wichtounet.github.io/posts/2013/06/some-news.html</guid><pubDate>Tue, 04 Jun 2013 23:52:24 GMT</pubDate></item><item><title>eddic 1.2.3 - Better data-flow analysis</title><link>http://wichtounet.github.io/posts/2013/03/eddic-1-2-3-better-data-flow-analysis.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I finally finished the version 1.2.3 of eddic. I have been quite busy finishing my master thesis in february and then taking some vacations in United States, so this version came later than I wanted. &lt;/p&gt;
&lt;p&gt;The main change is about the speed of the data-flow optimizations. I refactored a lot the data-flow to make it much faster. Some test cases are up to 10 times faster :)&lt;/p&gt;
&lt;p&gt;There are still some work to do for speed of optimizations, but it is much better now. Dead Code Elimination and Constant Propagation still have to be made faster, but now the main bottleneck. In the next version of eddic, the parsing performance will be improved. &lt;/p&gt;
&lt;p&gt;Inlining performance has also been greatly improved. The functions are considered in topological order of the call graph. This makes it much faster and moreover the resulting code is more efficient too. &lt;/p&gt;
&lt;p&gt;There are also some improvements of the language. char and bool types now takes only one byte each. Copy constructors for structures containing field of structure type are now automatically generated. The grammar has been enhanced to support postfix operations in for loops. &lt;/p&gt;
&lt;p&gt;Other improvements have been made to the optimization engine. A new optimization has been implemented: Loop Unswitching. This optimization transforms a code like that: &lt;/p&gt;
&lt;p&gt;[cpp]for(int i = 0; i &amp;lt; X; ++i){&lt;/p&gt;
&lt;p&gt;if(a){
   //Something
} else {
   //Something else
}&lt;/p&gt;
&lt;p&gt;}[/cpp]&lt;/p&gt;
&lt;p&gt;In some code like that: &lt;/p&gt;
&lt;p&gt;[cpp]if(a){
   for(int i = 0; i &amp;lt; X; ++i){
      //Something
   }
} else {
   for(int i = 0; i &amp;lt; X; ++i){
      //Something else
   }
}[/cpp]&lt;/p&gt;
&lt;p&gt;when a doesn't depend on the loop body. The body of the loops is much faster in the second version. &lt;/p&gt;
&lt;p&gt;The induction variable analysis is now able to handle loops with induction variable divided in each iteration. With that new feature, the call: &lt;/p&gt;
&lt;p&gt;[cpp]print(123);[/cpp]&lt;/p&gt;
&lt;p&gt;is reduced to&lt;/p&gt;
&lt;p&gt;[cpp]print('1');&lt;/p&gt;
&lt;p&gt;print('2');&lt;/p&gt;
&lt;p&gt;print('3');[/cpp]&lt;/p&gt;
&lt;p&gt;Another small optimization is that variables contributing only to themselves are now correctly identified as dead. &lt;/p&gt;
&lt;p&gt;On the compiler side, the timing system has been greatly improved to contains almost all part of the compilation process. The timings for the complete compilation is available &lt;a href="https://github.com/wichtounet/eddic/wiki/Performance" title="Performance"&gt;on the wiki&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future Work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.4. &lt;/p&gt;
&lt;p&gt;Performances will stil be focused for this version. The first change will be to improve the performances of the parsing. Then, I'm gonna try to improve register allocation performances by improving handling of bound registers which I believe is a bottleneck. &lt;/p&gt;
&lt;p&gt;There are also several refactorings that I think of doing to the code. I will probably also implement new minor language features, but I still don't know what. &lt;/p&gt;
&lt;p&gt;Moreover, I have to serve in the army the next three weeks, so there won't be any progress these weeks. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.3&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Optimization</category><category>projects</category><category>Releases</category><guid>http://wichtounet.github.io/posts/2013/03/eddic-1-2-3-better-data-flow-analysis.html</guid><pubDate>Sat, 09 Mar 2013 11:50:27 GMT</pubDate></item><item><title>eddic 1.2.2 - Performances, improved optimizations and additions to standard library</title><link>http://wichtounet.github.io/posts/2013/01/eddic-1-2-2-performances-optimization-library.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;These last weeks, I had more work than expected with my Master thesis so it took me longer to finish this new version of eddic. Moreover, I included more stuff than I though in this version. Anyway, I'm happy to announce the version 1.2.2 of eddic.&lt;/p&gt;
&lt;p&gt;It is a minor version regarding the language itself. On the other, there are a lot of changes in the compiler itself.&lt;/p&gt;
&lt;p&gt;For the language:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;Structures are now correclty copy constructed when passed by value&lt;/li&gt;
    &lt;li&gt;When the same header is included several times accross the program, it is not parsed again&lt;/li&gt;
    &lt;li&gt;The vector structure has now functions to insert and remove elements in arbitrary positions&lt;/li&gt;
    &lt;li&gt;The functions to print bools, floats and integers are now written in EDDI directly. Only the functions to print chars and raw string are now written in assembly&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I worked on improving the performances by improving the constant propagation pass that runs less times now and by tuning a bit the data-flow framework, avoiding virtual calls.&lt;/p&gt;
&lt;p&gt;Another improvement is that all the mtac::Statement types have been merged in mtac::Quadruple, this removes one level of indirection and simplifies several passes. Moreover, there are now directly stored inside a vector and not allocated via shared_ptr. This removes another level of indirection.&lt;/p&gt;
&lt;p&gt;Put together, these two optimizations improved the performances of the compiler by about 15%. On the other hand, now that printF and printI are written in EDDI, it takes much longer to compile. I will work on that for the next version too. One way to improve the performances will be to tune the ordering of passes and also to tune the passes themselves so that they do more work at once. I will also try to merge constant propagation and offset constant propagation together. They perform very similar work.&lt;/p&gt;
&lt;p&gt;There are also several improvements in the optimization engine:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span style="line-height: 13px;"&gt;The loop analysis has been fixed to handle loops bigger than one basic block. There was a problem in my implement of &lt;strong&gt;Lengauer and Tarjan&lt;/strong&gt; making that dominators were not computed. &lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;The optimization engine now create a call graph of the program. This call graph is used to remove unused functions that are called but not reachable from the main function.&lt;/li&gt;
    &lt;li&gt;A new analysis pass has been added: pure_analysis. This pass test if a function is pure (no write to pointers or global variables) and thus avoid creating a basic block for it&lt;/li&gt;
    &lt;li&gt;The L&lt;strong&gt;oop Invariant Code Motion algorithm&lt;/strong&gt; has been improved to handle more invariants&lt;/li&gt;
    &lt;li&gt;The &lt;strong&gt;Common Subexpression Elimination&lt;/strong&gt; algorithm has been improved to handle more expression&lt;/li&gt;
    &lt;li&gt;The &lt;strong&gt;Induction Variables analysis&lt;/strong&gt; has been reviewed and several bugs have been corrected. It is now a bit complicated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A big bug has been fixed in the handling of the MEMSET LTAC instruction. This will be completely reviewed in the next version (See Future Work).&lt;/p&gt;
&lt;p&gt;Some analysis starts to become quite complicated. I'm thinking of using SSA in MTAC in order to simplify some of the passes and to easily compute ud-chains. Another thing that I'm thinking is to add a powerful and complete alias analysis that would really improve the efficiency of some passes (offset constant propagation for instance) by making them less conservative.&lt;/p&gt;
&lt;p&gt;I also have removed some memory leaks (will try to remove all of them in the next version). I added a new optimization level: O3. This level enables loop unrolling and complete loop peeling.&lt;/p&gt;
&lt;h4&gt;Future Work&lt;/h4&gt;

&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.3. The inliner will be improved to work directly in the call graph in postorder. That should produce better code. I will also try to improve the inlining heuristics. A first basic version of loop unswitching will be added as well. I will add a small local constant propagation pass for globals. I will also continue to work on the performances of the passes to avoid repeating them too much. MEMSET will be completely reviewed. That should produce smaller and faster code. Until now, the sizes of the types bool and chars were the same as int. They will be optimized to take only 1 byte.&lt;/p&gt;
&lt;p&gt;I will also continue the improvements of the data structures by merging all ltac::Statement into ltac::Instruction and storing them directly.&lt;/p&gt;
&lt;p&gt;And there will probably be some bug fixing as well.&lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.2&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>C++11</category><category>EDDI</category><category>EDDI</category><category>Releases</category><guid>http://wichtounet.github.io/posts/2013/01/eddic-1-2-2-performances-optimization-library.html</guid><pubDate>Sat, 26 Jan 2013 16:35:42 GMT</pubDate></item><item><title>eddic 1.2.1 - string, concatenation and vector</title><link>http://wichtounet.github.io/posts/2012/12/eddic-1-2-1-string-concatenation-and-vector.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Before preparing myself for New Year's Eve, I decided to finish eddic 1.2.1, and it's done !&lt;/p&gt;
&lt;p&gt;This version is a small one, but add several improvements to the language and to the standard library. Many bugs have been fixed especially in the support of dynamic arrays and structures. &lt;/p&gt;
&lt;p&gt;The first important change is that string has been renamed to str and that a new struct is available: string. Indeed, str is now a simple raw string where string has more capabilities like concatenation. This new version also supports concatenation of string and int, which was not possible before. In the future, I'll try to add more features to the string class. &lt;/p&gt;
&lt;p&gt;Another improvement of the standard library is the inclusion of a vector structure. The vector is a dynamic arrays, which means that it can be automatically resized when necessary. For now, the operations available on vector are very few, but more will be added later. Especially, it is not possible now to add elements in the middle of the array, but it will be done, perhaps in the next eddic version or the next after this one. Adding the vector has also meant to add new features to the language. &lt;/p&gt;
&lt;p&gt;Dynamic arrays of structures is now supported. And, the delete operator can be applied on any left value now, not only variables. It means that "delete a[9];" is now a valid code. &lt;/p&gt;
&lt;p&gt;Finally, in the side of the language, printB has been rewritten in EDDI instead of raw assembly. In the next versions, I will continue to rewrite as much as possible of the assembly stuff into EDDI. There are several advantages. The first one is that I don't have to maintain two versions (one for 32 bits and one for 64 bits). Another advantage is that it can profit from the eddic optimizations. And it is more readable and maintainable in EDDI. &lt;/p&gt;
&lt;p&gt;A new optimization is now available. If a function is always called with the same value for one of its parameters, the value is propagated inside the function. In the future, it will be improved to suppport propagation for instance in more than X% of the case, creating several versions of the function. The optimizations have also been a bit improved in terms of performance, making some samples much faster to compile than before. Essentially, the removal of dead basic blocks is now made in a way that it doesn't need to be run several times to remove all the dead basic blocks. &lt;/p&gt;
&lt;p&gt;The warnings have been improved. Now, no warnings are emitted if some parts of a include are not used. And, if no elements of an included header is used, it will be warned that the include is not necessary. &lt;/p&gt;
&lt;p&gt;The error reporting has also been improved a bit. It can now display several errors. For now, it is limited to one error by function. Doing better error reporting, would mean lots of changes in the AST passes which I don't want to do right now. &lt;/p&gt;
&lt;p&gt;The hangman application has been fixed. It was a bug in the inliner that was causing this problem. There are now new test cases that verify that the optimizations are done. For instance, there is a test case verifying that the correct loops are removed when necessary. This is done by keeping tracks of counters like removed functions during the optimization. &lt;/p&gt;
&lt;p&gt;The source code has also been improved. I now use less shared_ptr and rather rely in storing the elements in standard container and using references directly. It result in much better code. This also improves a bit the performances by having a better data locality. For now, I have handled the given classes: eddic::Function, mtac::Function and mtac::Program, but the next version will handle more critical structures like the basic blocks and the MTAC statements which could improve the performances of the optimization by making iteration faster. &lt;/p&gt;
&lt;p&gt;Don't hesitate to comment or to contact me if you have any suggestion (or other) about this release or for the future versions of eddic. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;And happy new year !&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future Work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.2. In this version, I willl continue the work that I've done by using less shared_ptr and relying on references. I will also continue to improve the interfaces of the different class used. This version will also fix the memory leaks that I spotted in the application. There will also be new improvements on the language side, but minor one and I don't know now which ones I will pick. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.1&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>EDDI</category><category>EDDI</category><category>Releases</category><guid>http://wichtounet.github.io/posts/2012/12/eddic-1-2-1-string-concatenation-and-vector.html</guid><pubDate>Mon, 31 Dec 2012 19:46:56 GMT</pubDate></item><item><title>eddic 1.2.0 - Single inheritance, copy construction</title><link>http://wichtounet.github.io/posts/2012/12/eddic-1-2-0-single-inheritance-copy-constructor.html</link><description>&lt;div&gt;&lt;p&gt;I'm happy to release the &lt;strong&gt;version 1.2.0 of the EDDI Compiler (eddic)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This new version introduces several major changes to the language. &lt;/p&gt;
&lt;p&gt;First of all, structures can now inherits from another structure. When it is done, the structure can use the members of the parent class. Below is an example of single inheritance in EDDI: &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;init_a&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;55.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test_a&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;init_b&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'B'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;init_a&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test_b&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;test_a&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For now, the support remains basic, but it will be improved over time. I will probably add support for virtual functions in the future. &lt;/p&gt;
&lt;p&gt;Another major improvement to the language is that variable of a custom type can now be assignment, resulting in a call to the copy constructor. If no copy constructor is defined in a structure, it is automatically generated by the compiler. Another improvement to structures is that structures can now contains arrays. Moreover, the members of a structure (fields, constructors, functions, ...) can now be present in any order. &lt;/p&gt;
&lt;p&gt;A major change has been made to pointers. The conversions from variables to pointers is no more implicit, it is necessary to use the new &amp;amp; operator to take the address of a variable. I found that this implicit conversions was not really making any sense.&lt;/p&gt;
&lt;p&gt;A function can now return a structure by value. And, member functions can be called from any valid left value. For instance: &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;is now valid code.  &lt;/p&gt;
&lt;p&gt;Finally, the switch construct can be used with strings too. This uses the str_equals functions to test which case is valid. &lt;/p&gt;
&lt;p&gt;There are no big changes in the optimization engine. A new optimization pass has been added performing loop unrolling for loop with known iteration count. The pointer propagation has been fixed to handle pointers on structures resulting in much better code for several samples. The last improvement here is that conditions can be propagated into branches when necessary. &lt;/p&gt;
&lt;p&gt;The loop analysis has been improved to directly calculate the number of iterations of each loop and store this result. The list of induction variables is only calculated once now. &lt;/p&gt;
&lt;p&gt;The code generation has been slightly improved by saving fewer registers when calling another function. &lt;/p&gt;
&lt;p&gt;Finally, there are also some internal changes. The template instantiation depth limit can now configured. Before, infinite template recursion would just fail. The time spent in each optimization can now be computed with the new --timing option. There have been great improvements on the side of the Abstract Syntax Tree. A good part of the expression grammar has been rewritten. With these changes, the grammar is much more powerful than before. &lt;/p&gt;
&lt;p&gt;Don't hesitate to comment or to contact me if you have any suggestion (or other) about this release or for the future versions of eddic. &lt;/p&gt;
&lt;p&gt;I'd also like to thank &lt;a href="https://github.com/TyRoXx" title="TyRoXx"&gt;TyRoXx&lt;/a&gt; who has made some improvements in the assembly generation module. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Future Work&lt;/h4&gt;
&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.1. This version will specifically focus on two points. First the usage of strings will be improved with a string class adding features to literal string. The second point will be the performances of the compiler. At this point, the optimization engine is clearly too slow. I will try to make it faster. The list of issues is available &lt;a href="https://github.com/wichtounet/eddic/issues?milestone=2&amp;amp;state=open" title="eddic version 1.2.1"&gt;on Github&lt;/a&gt;.  &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.2.0&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Releases</category><guid>http://wichtounet.github.io/posts/2012/12/eddic-1-2-0-single-inheritance-copy-constructor.html</guid><pubDate>Mon, 17 Dec 2012 09:20:10 GMT</pubDate></item><item><title>GCC 4.7 vs CLang 3.1 on eddic</title><link>http://wichtounet.github.io/posts/2012/11/gcc-4-7-clang-3-1-eddic.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;a href="http://www.baptiste-wicht.com/2012/11/eddic-compiles-with-clang-3-1/" title="eddic compiles with CLang 3.1"&gt;Now that eddic can be compiled with CLang&lt;/a&gt;, I wanted to compare the differences in compilation time and in performance of the generated executable between those two compilers. The tests are done using GCC 4.7.2 and CLang 3.1 on Gentoo.
&lt;h3&gt;Compilation Time&lt;/h3&gt;
&lt;p&gt;The first thing that I tested has been the compilation time of the two compilers to compile eddic with different flags. I tested the compilation in debug mode and with -O2 and -O3.&lt;/p&gt;
&lt;p&gt;[bar_chart width="400px" height="300px" title="Compilation Time - Less is better" h_title="Options" v_title="Seconds" scale_button="true"]
          ['Options', 'GCC', 'CLang'],
          ['-g',  234.59,   119.59],
          ['-O2',  273.02,   178.22],
          ['-O3',  276.87,   183.78],
[/bar_chart]&lt;/p&gt;
&lt;p&gt;The most interesting fact in these results is that CLang is much faster than GCC. It takes twice less times to compile eddic with CLang in debug mode than with GCC. The impact on optimizations on CLang's compilation is also more important than on GCC. For both compilers, -O3 does not seems to add a lot of overhead.&lt;/p&gt;
&lt;h3&gt;Runtime performance&lt;/h3&gt;

&lt;p&gt;Then, I tested the performance of the generated executable. I tested it on three things, the whole test suite and two test cases that I know are the slowest for the EDDI Compiler. For each case, I took the slowest value of 5 consecutive executions. &lt;/p&gt;
&lt;p&gt;[bar_chart width="600px" height="400px" title="Runtime Performance - Less is better" h_title="Options" v_title="Seconds" scale_button="true"]
          ['Compiler', 'testsuite', 'assembly', 'linked_list'],
          ['GCC -O2',  6.58,   1.2, 0.51],
          ['GCC -O3',  6.59,   1.2, 0.5],
          ['CLang -O2',  6.74,   1.2, 0.49],
          ['CLang -O3',  6.58,   1.2, 0.49],
[/bar_chart]&lt;/p&gt;
&lt;p&gt;The difference are very small. In -02, GCC performs a bit better, but in -O3, the performance are equivalent. I was a bit disappointed by the results, because I thought that there would be higher differences. It seems that CLang is not as far from GCC that some people would like to say. It also certainly depends on the program being compiled. &lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;It is clear that CLang is much faster than GCC to compile eddic. Moreover, the performance of the generated executable are very similar. &lt;/p&gt;
&lt;p&gt;I will continue to use CLang as my development compiler and switches between the two when I'm doing performance benchmarking. I will try to update the benchmark once new versions of GCC / CLang are available. &lt;/p&gt;&lt;/div&gt;</description><category>Benchmarks</category><category>CLang</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>gcc</category><category>Performances</category><guid>http://wichtounet.github.io/posts/2012/11/gcc-4-7-clang-3-1-eddic.html</guid><pubDate>Mon, 12 Nov 2012 09:28:44 GMT</pubDate></item><item><title>EDDI Compiler 1.1.4 – Graph Coloring Register Allocation</title><link>http://wichtounet.github.io/posts/2012/11/eddic-compiler-1-1-4-graph-coloring-register-allocation.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I'm proud to announce the release of the &lt;strong&gt;version 1.1.4 of the EDDI Compiler (eddic)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This version has taken me much more time than I thought but I also added much more features than I thought too. &lt;/p&gt;
&lt;p&gt;There are few changes of the language itself, the main changes are in the optimization passes or in the compiler. &lt;/p&gt;
&lt;p&gt;For the language, it is now possible to use dynamically allocated arrays. The &lt;em&gt;this&lt;/em&gt; pointer is now implicit in member functions. &lt;/p&gt;
&lt;p&gt;The standard library has been improved by the &lt;strong&gt;addition of a Doubly-Linked List&lt;/strong&gt;. This list uses the templates so that it is generic. It is possible to add elements to the front and the back of the list. The list is iterable using iterators (bidirectional). &lt;/p&gt;
&lt;p&gt;The template engine has been almost entirely rewritten. The previous version was too limited and there was code to handle the templates almost in the whole front-end. Now, the templates are handled recursively at each point where they can appear. For not the template instantiation depth is not limited, but this will be done in the next version of eddic. &lt;/p&gt;
&lt;p&gt;The major change of this version is the use of a &lt;strong&gt;Graph Coloring Register Allocator&lt;/strong&gt; ! This allocator is based on a Chaitin-style allocator. This greatly improves the quality of the generated assembly. The LTAC compilation is now made in two phase. In the first one, only pseudo registers are used. This first pass includes a first cleanup pass. Then, the register allocator replaces all the pseudo registers by actual registers. Finally, the LTAC IR is optimized like before. In the future, it will be improved further. The coalescing and renumbering passes are a bit limited for now and Chaitin-Briggs optimistic coloring will be used in the future. &lt;/p&gt;
&lt;p&gt;The data-flow framework has been improved to support &lt;strong&gt;data-flow analysis of LTAC program&lt;/strong&gt;. For now, the only analysis that does that is Live Registers Analysis. This analysis is used by the Register Allocator by the Dead Code Elimination that is run in LTAC code. &lt;/p&gt;
&lt;p&gt;The MTAC optimization engine has been greatly improved by the use of a powerful pass manager that runs the optimization in the correct order and that gives them the necessary information. The Control Flow Graph is now updated by the different passes and never invalidated. The CFG is computed only once before the optimizations. &lt;/p&gt;
&lt;p&gt;The MTAC optimization engine has also new optimization passes regarding to loops: &lt;strong&gt;Loop Invariant Code Motion&lt;/strong&gt;, &lt;strong&gt;Loop Strength Reduction&lt;/strong&gt; and &lt;strong&gt;Complete Loop Peeling&lt;/strong&gt;. The loops are discovered by a dominance analysis implemented using the Lengauer-Tarjan's algorithm. &lt;/p&gt;
&lt;p&gt;The inliner has also beeen greatly improved. The inlining decision is now taken at the call site level. It means that only some calls to a function can be inlined and not the whole function. The inliner now supports functions with string parameters. Moreover, the inliner heuristic takes the number of constant parameters at the call site into account to take its decision. &lt;/p&gt;
&lt;p&gt;On the side of the Compiler, there are several improvements. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;The whole compilation process has been made thread safe.&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://www.baptiste-wicht.com/2012/10/run-boost-test-parallel-cmake/" title="Run your Boost Tests in parallel with CMake"&gt;The Test Suite can be run in parallel&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;The Middle-End and Back-Ends have been clearly separated (More information on the &lt;a href="https://github.com/wichtounet/eddic/wiki/Architecture" title="Architecture of the EDDI Compiler"&gt;Wiki&lt;/a&gt;). &lt;/li&gt;
    &lt;li&gt;The LTAC Intermediate Representation now keeps the Basic Blocks of the MTAC representation.&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://www.baptiste-wicht.com/2012/11/eddic-compiles-with-clang-3-1/" title="eddic compiles with CLang 3.1"&gt;eddic can be compiled with CLang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Future Work&lt;/h4&gt;

&lt;p&gt;The next version of the EDDI compiler (eddic) will be the version 1.2.0. This version will add support for inheritance at least in a basic way. It will also add support for returning a structure by value. The structures can contains arrays of defined size. This version will also focus on removing the limitations that exists on some features (Function Call Left Values for instance). It will also contains several necessary cleanups to the files. &lt;/p&gt;
&lt;h4&gt;Download&lt;/h4&gt;

&lt;p&gt;You can find the EDDI Compiler sources on the Github repository: &lt;a title="Github repository of eddic" href="https://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The version is available in the &lt;em&gt;v1.1.4&lt;/em&gt; tag available in the GitHub or directly in the &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><guid>http://wichtounet.github.io/posts/2012/11/eddic-compiler-1-1-4-graph-coloring-register-allocation.html</guid><pubDate>Thu, 08 Nov 2012 08:25:15 GMT</pubDate></item><item><title>eddic compiles with CLang 3.1</title><link>http://wichtounet.github.io/posts/2012/11/eddic-compiles-with-clang-3-1.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I finally added support for compiling eddic with LLVM CLang 3.1 !&lt;/p&gt;
&lt;p&gt;The current development version can be completely compiled with CLang. Starting with the version 1.1.4, all versions of eddic will be support GCC and CLang. &lt;/p&gt;
&lt;p&gt;The changes have not been as painful as I first thought. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;The main problem that I has was about a static const variable of a class that had no user-constructor. GCC allows that, but it is not standard compliant and CLang was complaining. &lt;/li&gt;
    &lt;li&gt;Another problem that I encountered was about the used of bit flags and Template Meta Programming. I simplified that by the use of a simple type traits and it worked. I don't really know why this does not worked at first. &lt;/li&gt;
    &lt;li&gt;The remaining effort was to fix the several warnings that CLang had. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLang also fixed a bug in my code with a warning on a assignment that was not supposed to be an assignment, thanks CLang. &lt;/p&gt;
&lt;p&gt;The most interesting fact about CLang is that &lt;strong&gt;is it twice faster to build eddic than GCC&lt;/strong&gt;. I think I'm gonna use it during development to fasten the compile time. Moreover, even if I only worked two days with it, it seems that the error messages are indeed better than the GCC's ones. &lt;/p&gt;
&lt;p&gt;I haven't tried to compare the performances of eddic in both cases, but I will do that in the future, soon after the 1.1.4 version is released. &lt;/p&gt;
&lt;p&gt;I tried the CLang static analyzer on eddic but it didn't found any bugs. Moreover, it crashed on several of my files. I didn't found why for now, but I will continue to investigate, perhaps I'm not using it correctly. &lt;/p&gt;
&lt;p&gt;I expect to publish the next version of eddic in the next two weeks. This version has much more improvements that I thought at first and I have less time to work now that &lt;a href="http://www.baptiste-wicht.com/2012/09/back-in-berkeley-california/" title="Back in Berkeley, California" target="_blank"&gt;I'm working on my Master thesis&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;More informations on CLang: &lt;a href="http://clang.llvm.org/" title="CLang official site"&gt;The official site&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>CLang</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>gcc</category><category>Linux</category><guid>http://wichtounet.github.io/posts/2012/11/eddic-compiles-with-clang-3-1.html</guid><pubDate>Thu, 01 Nov 2012 09:11:05 GMT</pubDate></item><item><title>Run your Boost Tests in parallel with CMake</title><link>http://wichtounet.github.io/posts/2012/10/run-boost-test-parallel-cmake.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I was looking for a Test Library to run eddic tests in parallel to replace Boost Test Library. I posted my question on StackOverflow and an awesome solution has been posted. With CMake and a little CMake additional file, it is possible to run the tests written with Boost Test Library in parallel without changing anything in the tests code !&lt;/p&gt;
&lt;p&gt;CTest is the test runner that is shipped with CMake. This runner can run tests in parallel using the -j X option (X is the numbers of threads). However, it can only run the tests that are declared in the CMakeLists.txt file. In my case, this means only one (the executable with Boost Test Library). If you have T tests, a solution would be create T executable files. Then, they can be run in parallel by ctest. However, this is not very practical. The solution proposed in this article is better. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Integrate Boost Test Library in CMake&lt;/h3&gt;
&lt;p&gt;Ryan Pavlik provides a series of CMake modules in its Github repository. One of this module is named BoostTestTargets. It automatically generates the CTest commands to run all the tests that you have. The small drawback is that you to list all the tests. &lt;/p&gt;
&lt;p&gt;To start, you have to download these files: &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/raw/master/BoostTestTargets.cmake" title="BoostTestTargets.cmake"&gt;BoostTestTargets.cmake&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/raw/master/GetForceIncludeDefinitions.cmake" title="GetForceIncludeDefinitions.cmake"&gt;GetForceIncludeDefinitions.cmake&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/raw/master/CopyResourcesToBuildTree.cmake" title="CopyResourcesToBuildTree.cmake"&gt;CopyResourcesToBuildTree.cmake&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/blob/master/BoostTestTargetsStatic.h" title="BoostTestTargetsStatic.h"&gt;BoostTestTargetsStatic.h&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/blob/master/BoostTestTargetsDynamic.h" title="BoostTestTargetsDynamic.h"&gt;BoostTestTargetsDynamic.h&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/blob/master/BoostTestTargetsIncluded.h" title="BoostTestTargetsIncluded.h"&gt;BoostTestTargetsIncluded.h&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These files must be placed next to your CMakeLists.txt file. Then, you have to modify your CMakeLists.txt file to enable testing and enable the new module. For example, if you have two test suites and five tests in each:  &lt;/p&gt;
&lt;p&gt;[code]INCLUDE(CTest)&lt;/p&gt;
&lt;p&gt;ENABLE_TESTING()&lt;/p&gt;
&lt;p&gt;file(
    GLOB_RECURSE
    test_files
    test/*
)&lt;/p&gt;
&lt;p&gt;include(BoostTestTargets.cmake)&lt;/p&gt;
&lt;p&gt;add_boost_test(eddic_boost_test
    SOURCES ${test_files}
    TESTS 
    TestSuiteA/test_1
    TestSuiteA/test_2
    TestSuiteA/test_3
    TestSuiteA/test_4
    TestSuiteA/test_5
    TestSuiteB/test_1
    TestSuiteB/test_2
    TestSuiteB/test_3
    TestSuiteB/test_4
    TestSuiteB/test_5
    )[/code]&lt;/p&gt;
&lt;p&gt;All the test files are searched in the test directory and used in the SOURCES variable. Then all the tests are declared. &lt;/p&gt;
&lt;p&gt;The main test file has to include a specific header file:&lt;/p&gt;
&lt;p&gt;[cpp]#define BOOST_TEST_MODULE eddic_test_suite&lt;/p&gt;
&lt;h2&gt;include &amp;lt;BoostTestTargetConfig.h&amp;gt;[/cpp]&lt;/h2&gt;
&lt;p&gt;This file will be automatically detected by BoostTestTargets and configured correctly. And that's it !&lt;/p&gt;
&lt;p&gt;You can run CMake again in your build directory to use the new test system: &lt;/p&gt;
&lt;p&gt;[bash]cmake .[/bash]&lt;/p&gt;
&lt;p&gt;If the configuration has been successful, you will see a message indicating that. For example, I see that: &lt;/p&gt;
&lt;p&gt;[bash]-- Test 'eddic_boost_test' uses the CMake-configurable form of the boost test framework - congrats! (Including File: /home/wichtounet/dev/eddi/eddic/test/IntegrationTests.cpp)&lt;/p&gt;
&lt;p&gt;-- Configuring done&lt;/p&gt;
&lt;p&gt;-- Generating done&lt;/p&gt;
&lt;p&gt;-- Build files have been written to: /tmp/ramdrive/dev/eddic[/bash]&lt;/p&gt;
&lt;h3&gt;Run tests in parallel&lt;/h3&gt;

&lt;p&gt;You can then run your tests in parallel with ctest. For instance, with 9 threads: &lt;/p&gt;
&lt;p&gt;[bash]ctest -j 8[/bash]&lt;/p&gt;
&lt;p&gt;In my case, my tests are completed 6x faster ! This is very valuable when you often run your tests. &lt;/p&gt;
&lt;p&gt;For more information on how to integrate your Boost Test Library tests with CMake, you can consult the &lt;a href="https://github.com/rpavlik/cmake-modules/" title="cmake-modules Github repository"&gt;The cmake-modules repository&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>Boost</category><category>C++</category><category>cmake</category><category>Concurrency</category><category>EDDI</category><category>Performances</category><category>Tests</category><guid>http://wichtounet.github.io/posts/2012/10/run-boost-test-parallel-cmake.html</guid><pubDate>Mon, 15 Oct 2012 08:57:43 GMT</pubDate></item></channel></rss>