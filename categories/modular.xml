<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>@Blog("Baptiste Wicht") (Modular)</title><link>http://wichtounet.github.io/</link><description></description><atom:link rel="self" href="http://wichtounet.github.io/categories/modular.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Mon, 17 Mar 2014 17:20:50 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>JTheque Core 2.1.0 released !</title><link>http://wichtounet.github.io/posts/2010/10/jtheque-core-2-1-0-released.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;It's my pleasure to announce that I've finally released &lt;strong&gt;JTheque Core 2.1.0&lt;/strong&gt; !&lt;/p&gt;
&lt;p&gt;The different services of the core are now separated using &lt;strong&gt;OSGi&lt;/strong&gt;. With this separation, I've improved a lot the design of the core and the orthogonality of the different services. Each service is now an OSGi bundle. I've also refactored the implementation of all services. Several services have been completely rewritten. The majority of the bundles are now thread-safe.&lt;/p&gt;
&lt;p&gt;Now, to create modules for a JTheque application, you have to write an OSGi bundle representing the module. Then, you only have to use Spring to launch the module. This is done using &lt;strong&gt;Spring Dynamic Modules&lt;/strong&gt;. The used OSGi container is &lt;strong&gt;Felix&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now that this version of the core is finalized, I'll updates the applications. First of all, JTheque Movies with the new version of the core.&lt;/p&gt;
&lt;p&gt;Fore more informations and to download JTheque Core, you can go on &lt;a href="http://www.jtheque.com/jtheque-core"&gt;the description page&lt;/a&gt;. If you want to try developing a module (or see how it is done), you can consult &lt;a href="http://www.jtheque.com/jtheque-core/guides/develop-modular-application-jtheque-core-2-1-0"&gt;this starter guide&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>Java</category><category>JTheque</category><category>Modular</category><category>OSGi</category><category>Releases</category><category>Spring</category><guid>http://wichtounet.github.io/posts/2010/10/jtheque-core-2-1-0-released.html</guid><pubDate>Wed, 20 Oct 2010 07:12:33 GMT</pubDate></item><item><title>Modular Java – Book Review</title><link>http://wichtounet.github.io/posts/2010/07/modular-java-book-review.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Some weeks ago, I finished "Modular Java - Creating Flexible Applications With OSGi and Spring", it's time to do a little review now.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/07/1934356409.01.LZZZZZZZ-e1278244106418.jpg"&gt;&lt;img class="size-full wp-image-690" title="Modular Java" src="http://wichtounet.github.io/wp-content/uploads/2010/07/1934356409.01.LZZZZZZZ-e1278244106418.jpg" alt="Modular Java" width="150" height="182"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;This book is an excellent introduction to the creation of modular applications in Java. It introduces all the main concepts of the OSGi technology, Spring Dynamic Modules and tools making easier the development of OSGi applications.&lt;/p&gt;
&lt;p&gt;The first chapter introduce the concept of modularity and explain how OSGi solve the problem. The main characteristics of the technology are also described.&lt;/p&gt;
&lt;p&gt;The next chapter lists the main OSGi containers and we create the first Hello World using OSGi. Next we improve this simple program using an OSGi service.&lt;/p&gt;
&lt;p&gt;After that the third chapter introduce the application "Dude, Where is my Jar ?". This application is a simple web program allowing a develop to search for a Jar file in Maven repositories. This application is used in all the next chapters. More than this introduction, the chapter also shows how the Pax tools can make easier the development of OSGi applications.&lt;/p&gt;
&lt;p&gt;In the next chapter, we create the first bundle of the application. With that bundle we see how to work with non-bundle dependencies. And in the next one, we create the services of the application and see how to publish and consume services.&lt;/p&gt;
&lt;p&gt;After that, it's time to use Spring Dynamic Modules with the next chapter. We see how to publish and consume services with Spring.&lt;/p&gt;
&lt;p&gt;In the seventh chapter, we develop the web bundle. Fort hat, we include Tomcat or Jetty in the form of OSGi Bundles. We also see the differences between a simple bundle (Jar) and a web bundle (War).&lt;/p&gt;
&lt;p&gt;In the next, we see how to extend OSGi bundle using fragment. With that, we see how to separate the JSP part of the application.&lt;/p&gt;
&lt;p&gt;The last two chapters are about the deployment in production of an OSGi application and the services offered by the OSGi standard (logging, admin, console, ...).&lt;/p&gt;
&lt;p&gt;In conclusion, this book will allows you to start developing application using OSGi. It's really comfortable to follow the development of a simple applications during the entire book. And improve it with each concept of the technology. But I think it's not a very good idea to use that log the Pax Tools. We quickly loose OSGi with Pax. It's quite interesting to know how to use Pax (I use it everyday), but when we start, it's better to see the basic concepts further.&lt;/p&gt;
&lt;p&gt;And more, the Maven output, is almost entirely displayed. This not really useful to see that every time when it's not errors, warning or important informations. But nevertheless, the reading of the book is really comfortable and fluid.&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>Java</category><category>Java</category><category>Modular</category><category>OSGi</category><guid>http://wichtounet.github.io/posts/2010/07/modular-java-book-review.html</guid><pubDate>Thu, 08 Jul 2010 07:12:43 GMT</pubDate></item><item><title>Develop a modular application - The loading</title><link>http://wichtounet.github.io/posts/2010/05/modular-application-loading-modules.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Now that we've seen &lt;a href="http://www.baptiste-wicht.com/2010/05/develop-a-modular-application-implementation/"&gt;how to describe a module in Java&lt;/a&gt;, we'll see how to load it dynamically in our application.&lt;/p&gt;
&lt;p&gt;In Java, all the classes are loaded using several ClassLoader.In this article, we'll develop a loader for our modules and watch the problems that arrive when working with custom ClassLoaders.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Normally, Java use the system ClassLoader to load all the classes of our application. So it contains all the classes of our application and all the classes our application needs to work. But the problem is that we cannot add our modules jar files into classpath because the application doesn't know the modules jar files names.&lt;/p&gt;
&lt;p&gt;Moreover, we cannot theoretically add files to the system ClassLoader. I say theoretically because, we can add files using reflection and call to a private method, but i thing it's not a really good practice.&lt;/p&gt;
&lt;p&gt;So we've to create a new ClassLoader to load our modules. We'll do that in two phases :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;Browse the module files to get the classes of the modules and the URLs of the modules Jar files&lt;/li&gt;
    &lt;li&gt;Load the modules into our ClassLoader using the URLs of the first phase&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We'll do all the loading in a new class ModularLoader. so let's create a create a method that return the list of classes to load :&lt;/p&gt;
&lt;p&gt;[java]public class ModuleLoader { 
  private static List&amp;lt;URL&amp;gt; urls = new ArrayList&amp;lt;URL&amp;gt;(); &lt;/p&gt;
&lt;p&gt;private static List&amp;lt;String&amp;gt; getModuleClasses(){ 
    List&amp;lt;String&amp;gt; classes = new ArrayList&amp;lt;String&amp;gt;(); &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//Get all the modules of the modules folder&lt;/span&gt;
&lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"folder"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ModuleFilter&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
  &lt;span class="n"&gt;JarFile&lt;/span&gt; &lt;span class="n"&gt;jarFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="c1"&gt;//Open the Jar File&lt;/span&gt;
    &lt;span class="n"&gt;jarFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;JarFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//We get the manifest&lt;/span&gt;
    &lt;span class="n"&gt;Manifest&lt;/span&gt; &lt;span class="n"&gt;manifest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jarFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getManifest&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//We get the class name from the manifest attributes&lt;/span&gt;
    &lt;span class="n"&gt;classes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;manifest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMainAttributes&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Module-Class"&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toURI&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;toURL&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jarFile&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
      &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;jarFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
      &lt;span class="p"&gt;}&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;classes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;private static class ModuleFilter implements FileFilter { 
    @Override 
    public boolean accept(File file) { 
      return file.isFile() &amp;amp;&amp;amp; file.getName().toLowerCase().endsWith(".jar"); 
    } 
  } 
}[/java]&lt;/p&gt;
&lt;p&gt;Like you see, it's not complicated at all. We search all the module files and then for each jar file, we open it, get the manifest et read the class name of the module. And then, for the second phase, we get the URL to the Jar file. &lt;/p&gt;
&lt;p&gt;Of course, this loader is not perfect. We can have modules with no manifest or manifest with no class name and the errors must be correctly treated, but this is not the objective of this post to be perfect. &lt;/p&gt;
&lt;p&gt;Now we can do the second phase, adding a method to create the ClassLoader, instantiate the modules and return them : &lt;/p&gt;
&lt;p&gt;[java]private static ClassLoader classLoader; &lt;/p&gt;
&lt;p&gt;public static List&amp;lt;IModule&amp;gt; loadModules(){ 
  List&amp;lt;IModule&amp;gt; modules = new ArrayList&amp;lt;IModule&amp;gt;(); &lt;/p&gt;
&lt;p&gt;AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;(){ 
    @Override 
    public Object run() { 
      classLoader = new URLClassLoader( 
          urls.toArray(new URL[urls.size()]),&lt;br&gt;
          ModuleLoader.class.getClassLoader()); &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}); &lt;/p&gt;
&lt;p&gt;//Load all the modules
  for(String c : getModuleClasses()){ 
    try { 
      Class&amp;lt;?&amp;gt; moduleClass = Class.forName(c, true, classLoader); &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IModule&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isAssignableFrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;moduleClass&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt; 
    &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;IModule&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;castedClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;IModule&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt; &lt;span class="n"&gt;moduleClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;IModule&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;castedClass&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ClassNotFoundException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InstantiationException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IllegalAccessException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;return modules; 
}[/java]&lt;/p&gt;
&lt;p&gt;So we start creating a new ClassLoader taking the urls of the Jar files. Then, we use this ClassLoader to load all the module classes and instantiate them. We only verify if the class is of type IModule. &lt;/p&gt;
&lt;p&gt;This is all for our ModuleLoader. We can now test our simple modular application. We create a JAR file for the module of the previous post and then we create a very simple application to test that : &lt;/p&gt;
&lt;p&gt;[java]List&amp;lt;IModule&amp;gt; modules = ModuleLoader.loadModules(); &lt;/p&gt;
&lt;p&gt;for(IModule module : modules){ 
  System.out.println("Plug : " + module.getName()); 
  module.plug(); 
} &lt;/p&gt;
&lt;p&gt;System.out.println("Lot of other things done by the application. "); &lt;/p&gt;
&lt;p&gt;for(IModule module : modules){ 
  module.unplug(); 
}[/java]&lt;/p&gt;
&lt;p&gt;And here is the output of the application : &lt;/p&gt;
&lt;pre&gt;Plug : Simple module

Hello kernel !

Lot of other things done by the application. 

Bye kernel !&lt;/pre&gt;

&lt;p&gt;Like you can see, we just created a modular applications ! The application doesn't know the modules, but the modules can do things in the application. &lt;/p&gt;
&lt;p&gt;Of course, to create a real applicatio, we have to develop all the extension points and services, but this is a base to start with. &lt;/p&gt;
&lt;p&gt;However, there is some problems with the current implementations : &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;We cannot deploy modules without restarting the application, because we must create a new ClassLoader for the modules. This is possible if there is no interation between modules, but that's not often the case. You have also the possibility to isolate all the modules in a specific ClassLoader, but with that second solution, the interations between modules are made harder. &lt;/li&gt;
    &lt;li&gt;Using a second ClassLoader may be problematic with libraries loading dynamically the classes like Spring or Hibernate. To make these libraries working with your ClassLoader, you have to look at case by case depending on the library. Often, you achieve specifying the contextClassLoader using the method  Thread.currentThread().setContextClassLoader(ClassLoader cl) with your ClassLoader&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So here is the end of this four posts about creating a modular application. I hope you find these posts interesting. &lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/modular-application-loading-modules.html</guid><pubDate>Fri, 14 May 2010 06:33:40 GMT</pubDate></item><item><title>Develop a modular application – Implementation</title><link>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-implementation.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Now that we saw in details &lt;a href="http://www.baptiste-wicht.com/2010/05/modular-application-modules/"&gt;the characteristics of the modules&lt;/a&gt;, we'll see how to implement a module.&lt;/p&gt;
&lt;p&gt;We need a simple container for our module to load it after with a loader from the modular application.&lt;/p&gt;
&lt;p&gt;In this post, we'll only see what will be a module in Java, we'll the loading of the modules in the next (and last) post.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;A module is completely independent of the module, so we cannot include it directly in the application. We must distinguish the file of the module and the file of the application.&lt;/p&gt;
&lt;p&gt;So what will be these files ? Because we're in Java, we use Jar files. So the modules will be Jar files extending the applications.&lt;/p&gt;
&lt;p&gt;And now in Java, a module will be an interface  describing the main characteristics of the module. We'll be simple for the moment. A module must be pluggable to the application and unpluggable. Moreover the module has also a name and we can get this name. At this moment, this is all we need :&lt;/p&gt;
&lt;p&gt;We must have a simple interface to describe a module :&lt;/p&gt;
&lt;p&gt;[java]public interface IModule {
  public void plug();
  public void unplug();
  public String getName();
}[/java]&lt;/p&gt;
&lt;p&gt;With that interface, we can create the most simple module that only prints to the console :&lt;/p&gt;
&lt;p&gt;[java]package org.modules.simple; &lt;/p&gt;
&lt;p&gt;public class SimpleModule implements IModule {
  @Override
  public void plug(){
    System.out.println("Hello kernel !");
  } &lt;/p&gt;
&lt;p&gt;@Override
  public void unplug(){
    System.out.println("Bye kernel !");
  } &lt;/p&gt;
&lt;p&gt;@Override
  public String getName(){
    return "Simple module";
  }
}[/java]&lt;/p&gt;
&lt;p&gt;So we'll create a Jar file containing our class. We need a solution for the application to know which class to launch. So we need write this somewhere.&lt;/p&gt;
&lt;p&gt;A naïve solution is to browse the Jar file and test each class if it implements the interface. This method works but is not optimal but that can be really inefficient in large Jar file. So we'll use the tools offered by Java and add an information in the Jar manifest to indicate to the application which class must be loaded.&lt;/p&gt;
&lt;p&gt;So here it's the manifest for our example :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;Manifest-Version: 1.0
&lt;p&gt;Module-Class: org.modules.simple.SimpleModule&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;With that the module loader will know which class it must instantiate to create a module.  An other solution is to use the ServiceLoader of Java 6.&lt;/p&gt;
&lt;p&gt;In the next post, we'll see how to load our module and we'll test an application with two simples modules.&lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-implementation.html</guid><pubDate>Wed, 12 May 2010 06:29:23 GMT</pubDate></item><item><title>Develop a modular application – The modules</title><link>http://wichtounet.github.io/posts/2010/05/modular-application-modules.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;After &lt;a href="http://www.baptiste-wicht.com/2010/05/develop-a-modular-application-bases/"&gt;explaining what's a modular application&lt;/a&gt;, I'll now explain with more details the concept of modules.&lt;/p&gt;
&lt;p&gt;We said that a module add features to the application. But before writing any code, we've to define exactly what are the modules, what they can do if there is several types of modules, ...&lt;/p&gt;
&lt;p&gt;This is what we'll see in this post.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;The first question to ask is "What can a module do ?". Namely, defining all the things a module can add to the application and how they can add these things. Moreover, a module can also modify the application.&lt;/p&gt;
&lt;p&gt;What the modules can do depends on the type of the modular application :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;For the first type (simple application with extension capability), the module adds specific features depending on the application. By example, in the case of an application that allows to watch television from internet, the modules can add a new channel or the support of a new video format. It can also adds a complete feature like statistics about channels. &lt;/li&gt;
    &lt;li&gt;For the second type (empty application and modules that make the application features), the modules don't add features to the application, they do the application. In this case, the modules are often bigger than in the first case, because, modules are applications. There is often no links between modules, one can create a calculator and the other a video editor. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the two cases, we've to define several extension points. By example, here are the extension points I created for JTheque : &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Add tabs in the main view&lt;/li&gt;
    &lt;li&gt;Add components in the state bar&lt;/li&gt;
    &lt;li&gt;Add features to the menu&lt;/li&gt;
    &lt;li&gt;Add configuration options&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With there extension points, the modules can do a lot of things. If we want to make a calculator, we can add a tab in the main view or add a feature in the menu that displays a calculator in a dialog. Of course, this extension points depends of the developer and the application, but this is really important to define well a list of this points. &lt;/p&gt;
&lt;p&gt;More than providing extension points, the core of the application provide also a set of services to the modules. These services can be simple utility classes or by example a persistence manager or a file manager. &lt;/p&gt;
&lt;p&gt;One more time, you've to decided which services the core will provide to the modules. This services are not essential, but that enables to simplify a lot the modules. And that improve the code standard of the modules. With that model, the modules will always use the same type of services, this is easier to manage.  &lt;/p&gt;
&lt;p&gt;By example, here are some of services, JTheque Core offers to the modules : &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Error manager : To display some errors. &lt;/li&gt;
    &lt;li&gt;View manager : To create easily new views, display messages, ask something to the user. &lt;/li&gt;
    &lt;li&gt;Resource manager : Provide an image cache and utility methods to load image, create thumbnail, ...&lt;/li&gt;
    &lt;li&gt;Persistence manager : Give the ability to modules to persist objects&lt;/li&gt;
    &lt;li&gt;State manager : Store states for modules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can also think if we want only one type of modules or several. By example, you can imagine primary modules and normal modules. Only a primary module can be launched at the same time. &lt;/p&gt;
&lt;p&gt;The last point I see, is the point of the dependencies between modules. We can allows that a module depends on an other modules. This add a difficulty level for the implementation, because we must verify that the dependencies are solved before launch a module. And what about circular dependencies ? This is the choice of developer, but if you don't allow dependencies between modules, it can e difficult to create good applications. &lt;/p&gt;
&lt;p&gt;So I've finished to talk about modules. Don't hesitate to comment if you doesn't agree with something or if you have questions. In the next I'll implement the first modules and in the last, I will create a simple loader for modules. &lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/modular-application-modules.html</guid><pubDate>Mon, 10 May 2010 06:24:29 GMT</pubDate></item><item><title>Develop a modular application – Bases</title><link>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-bases.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;This is the first post of four posts about modular applications.&lt;/p&gt;
&lt;p&gt;I'll try to explain all the things we must think of when we develop a modular application. I'm developing a generic core for modular applications, JTheque. So what I'm saying in this posts are taken from my experience developing this framework. &lt;/p&gt;
&lt;p&gt;In this post, i'll start talking of the bases of the conception of modular application. So what's a modular application, a module and what give to the developer and the user to have a modular application ? In the next posts, I'll describe the problems we could found relating to modules and loading. The examples will be in Java, but all the concepts can be applied to every language. I'll not talk about OSGi, this is more an introduction to modular programming without specific framework, but of course, OSGi is a very good solution to modular programming.&lt;/p&gt;
&lt;p&gt;Of course, I don't think i'm a professional in modular programming and what I'll say in this post, is nothing else than my point of view. If you think there is better solutions than what I present, don't hesitate to say that in comments.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;To start, what's a modular application ? A modular application is made of 2 distinct parts : &lt;/p&gt;
&lt;p&gt;The core : Like its name says, this is the central part of the application. This part must be completely independent of the modules. &lt;/p&gt;
&lt;p&gt;The modules : It's the dynamic parts we'll add to the application to add features. There is other name for modules : add-ons, plugins and lot of other name, but the concept is the same. &lt;/p&gt;
&lt;p&gt;I think there is two types of modular applications. The first type is a normal application who provide several features and give the user the possibility to add functionalities with modules. The second type is an application who has a core without feature. All the features are provided by the modules, so, "All is module". &lt;/p&gt;
&lt;p&gt;The main difference is that the first type can be used like any other application without modules, but the second one is not useful without modules. &lt;/p&gt;
&lt;p&gt;In these two types of applications, you've to define some extension points for the modules. With that extension points, the modules can add features to the application or modify some features. &lt;/p&gt;
&lt;p&gt;JTheque is based on the second type. JTheque Core is a simple core to develop modular applications. We can also talk of Eclipse that is a fully modular framework. &lt;/p&gt;
&lt;p&gt;Now the question is : that seems good but what the hell does that offer ? First, from the point of view of a developer, this allows to clearly separate the different parts of its application. We've distinct modules easier to maintain than a big applications. It's also easy to add features to applications. And last but not least, you can use the core several times for building different applications. From the point of view of the user, he can choose which modules he want to launch, add new modules and perhaps create some modules if he can. So he can customize applications. &lt;/p&gt;
&lt;p&gt;But, that not trivial to make, you've to make a good conceptions and implement it in a clean way. When you do, you find some problmens to solve and a lot of questions to ask. We'll see all the problems and questions in &lt;a href="http://www.baptiste-wicht.com/2010/05/modular-application-modules/"&gt;the next post&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-bases.html</guid><pubDate>Thu, 06 May 2010 06:28:38 GMT</pubDate></item><item><title>JTheque is going to OSGi</title><link>http://wichtounet.github.io/posts/2010/03/jtheque-is-going-to-osgi.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;Just a little post to inform you that i'm currently migrating JTheque Core to OSGI / Spring Dynamic Modules. The core will be fractioned into several bundles. The JTheque Modules will also be OSGi bundles.&lt;/p&gt;
&lt;p&gt;It will increase the modularity of the different services of the Core. And it will also be a more standard way to develop modules. And last but not least, it's an opportunity for me to learn OSGi and Spring Dm.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Java</category><category>JTheque</category><category>JTheque</category><category>Modular</category><category>OSGi</category><category>Spring</category><guid>http://wichtounet.github.io/posts/2010/03/jtheque-is-going-to-osgi.html</guid><pubDate>Tue, 02 Mar 2010 13:35:52 GMT</pubDate></item><item><title>Develop a modular application with JTheque Core 2.0.3</title><link>http://wichtounet.github.io/posts/2010/02/modular-application-jtheque-core-2-0-3.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;1. Introduction&lt;/h4&gt;
This article will teach you how to develop a first application with JTheque Core.
&lt;p&gt;We will develop a basic modular application, like an hello world. This little program will be composed of :&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;A JTheque application&lt;/li&gt;
    &lt;li&gt;A JTheque module who display an Hello World on the main view&lt;/li&gt;
    &lt;li&gt;A module who will add an option menu to display one more time "Hello World"&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h4&gt;2. JTheque environment&lt;/h4&gt;

&lt;p&gt;The first thing to do before starting develop our application and our modules is to download the "development environment" of JTheque Core. A JTheque application needs some files and librairies to work.&lt;/p&gt;
&lt;p&gt;You can download an archive containing all necessary files on the website of the projects. Then you must choose the dev-base-XXX.zip file where XXX is the version number. In our case, we need the dev-base-2.0.3.zip file.&lt;/p&gt;
&lt;p&gt;When you've downloaded the file, unzip it. Here is the content of the folder :&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;core &lt;/strong&gt;: Contains JTheque Core, the configuration and the application&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;lib &lt;/strong&gt;: Contains all the librairies&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;modules &lt;/strong&gt;: Contains all the modules&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;JTheque-Launcher.jar&lt;/strong&gt; : The launcher of the application. You must execute this file to launch your application.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We only have two things to change in this folder. First, we have to add our application (application.xml) and its resources in the core folder. Then, we have to add our modules in the "modules" folder and declare it in the JTheque configuration.&lt;/p&gt;
&lt;!--nextpage--&gt;

&lt;h4&gt;3. Application&lt;/h4&gt;

&lt;p&gt;Now that we seen what is a JTheque Application, we'll develop it, the first part of our program.&lt;/p&gt;
&lt;p&gt;An application is basically a container for modules. It has a name, a version but adds no functionaly to the application, this a function of the modules. An application without modules is not useful and vice-versa.&lt;/p&gt;
&lt;p&gt;An application is composed of several things :&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;An XML file (application.xml) describing the application&lt;/li&gt;
    &lt;li&gt;Some images (in the core/images folder)&lt;/li&gt;
    &lt;li&gt;Eventually some .properties i18n files in the core/i18n folder&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To define the internationalization values of the application, there is 2 ways. We can define the values directly in the XML file or use some i18n .properties files. This is this solution we will use in our case. The resource bundle must be named application and be in the core/i18n folder. Here are the files to create :&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;name=JTheque Demos

author=Baptiste Wicht

email=baptistewicht@redaction-developpez.com&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;application_en.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;site=http://jtheque.developpez.com/en

copyright=JTheque 2009 All rights reserved&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;application_fr.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;site=http://jtheque.developpez.com/

copyright=JTheque 2009 Tous droits reservés&lt;/pre&gt;

&lt;p&gt;Then, we can write the application.xml file :&lt;/p&gt;
&lt;p&gt;We declared than our application is available in french and in english. Moreover, we declare () to use the i18n files. i18n properties.&lt;/p&gt;
&lt;p&gt;The core is translated in english, french and german.&lt;/p&gt;
&lt;p&gt;For the images, we start to declare a logo.png file and a icon.png file for the application. We can use other extension specifying type="jpg" for exemple for a .jpg file.&lt;/p&gt;
&lt;p&gt;Here are the used images :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/03/icon.png"&gt;&lt;img class="size-full wp-image-138" title="The window icon" src="http://wichtounet.github.io/wp-content/uploads/2010/03/icon.png" alt="The window icon" width="16" height="16"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/03/logo.png"&gt;&lt;img class="size-full wp-image-139" title="The application logo" src="http://wichtounet.github.io/wp-content/uploads/2010/03/logo.png" alt="The application logo" width="171" height="100"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We will now make a first try. For that, you just have to launch the JTheque-Launcher.jar at the root of the JTheque folder. It will launch the core with our application.&lt;/p&gt;
&lt;p&gt;Here is the result :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/03/Screen1.png"&gt;&lt;img class="size-medium wp-image-140" title="Launch without any modules" src="http://wichtounet.github.io/wp-content/uploads/2010/03/Screen1-300x233.png" alt="Launch without any modules" width="300" height="233"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can see that the application launches weel, but there is nothing really interesting to do in this application because there is no modules to add functionalities.&lt;/p&gt;
&lt;!--nextpage--&gt;

&lt;h4&gt;4. The first module&lt;/h4&gt;

&lt;p&gt;Now that our module has been developed and is functional, we can make our first module of the application.&lt;/p&gt;
&lt;p&gt;This module will be very simple. It just display "Hello World !" on the main componnent of the application in an internationalized way.&lt;/p&gt;
&lt;p&gt;To declare a module, we need to create class with the @Module annotation. Then, we have to declare it in the Spring context and declare this last in the manifest of the jar.&lt;/p&gt;
&lt;p&gt;It's not necessary to know Spring to use JTheque. If you don't want to use Spring in your application, you can just declare the module in the Spring context withtout using it and then develop your application without use Spring context. You just have to know that the module will be created by Spring.&lt;/p&gt;
&lt;p&gt;The life cycle of a module is composed of three states :&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;pre-plug : To make pre-configuration&lt;/li&gt;
    &lt;li&gt;plug : Here you must add the module in the application. It means edit view, add config elements, ...&lt;/li&gt;
    &lt;li&gt;unplug : Remove the module from the application&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To make operations in this 3 phases, you just have to add annotations on methods, respectively @PrePlug, @Plug et @Unplug. Then the application will detect this methods and invoke them.&lt;/p&gt;
&lt;p&gt;In our case, we need to edit the main component of the view in the plug phase. So we doesn't need the other phases.&lt;/p&gt;
&lt;p&gt;Starting with declaring our module with necessary annotations :&lt;/p&gt;
&lt;p&gt;[java]package org.jtheque.demos.first;&lt;/p&gt;
&lt;p&gt;import org.jtheque.core.managers.module.annotations.Module;&lt;/p&gt;
&lt;p&gt;import org.jtheque.core.managers.module.annotations.Plug;&lt;/p&gt;
&lt;p&gt;@Module(id = "jtheque-demo-module-1", i18n = "classpath:org/jtheque/demos/first/i18n/first", version = "1.0", core = "2.0.3",
        jarFile = "jtheque-demo-module-1.jar")
public final class DemoFirstModule {
    @Plug
    public void plug(){&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;Here again, there is nothing hard. The annotation Module declare the informations about the module. The plug method is for this time empty. The i18n annotation contains the path (Spring resource convention) to the resource bundle of the module. bundle du module.&lt;/p&gt;
&lt;p&gt;Now we can declare informations about the module in the i18n files.&lt;/p&gt;
&lt;p&gt;A i18n file is a simple .properties file who contains a list of key/value couples. A i18n file represent a language. We use a set of this files to internationalize the application. They must have the same base name and finish with _language where "language" is the short form of the language$ (de, fr, en, it, ...).&lt;/p&gt;
&lt;p&gt;The key will be search depending on the id of the module. We directly add also the internationalization of the main view :&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;first_en.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;jtheque-demo-module-1.name=JTheque Demo Module 1

jtheque-demo-module-1.author=Baptiste Wicht

jtheque-demo-module-1.description=First demo module&lt;/pre&gt;

&lt;p&gt;label.message=Hello World !&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;first_fr.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;jtheque-demo-module-1.name=JTheque Demo Module 1

jtheque-demo-module-1.author=Baptiste Wicht

jtheque-demo-module-1.description=Premier module de démo

label.message=Bonjour le monde !&lt;/pre&gt;

&lt;p&gt;The application will automatically search and resolve this messages to internationalize the module. We put this files in the org/jtheque/demos/module/first/resources/18n folder.&lt;/p&gt;
&lt;p&gt;To extend the application or access to the services of JTheque, we always have to use the Managers class who provide access to the managers (services) of JTheque Core. In our case, we need to access IViewManager who manage the view of the application.&lt;/p&gt;
&lt;p&gt;In the plug() method, we just have to add a JLabel with an internationalizable text. In JTheque, to make a component internationalizable, we have to implement the Internationalizable interface and add it to ILanguageManager to keep it in the good language. In the case of a label, this component exists in JTheque Core, its the JThequeI18nLabel who takes a i18n key as constructor parameter :&lt;/p&gt;
&lt;p&gt;[java]@Plug&lt;/p&gt;
&lt;p&gt;public void plug(){
    SwingUtils.inEdt(new Runnable(){
        @Override
        public void run(){
            JThequeI18nLabel label = new JThequeI18nLabel("label.message");
            label.setFont(label.getFont().deriveFont(36f));&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;        &lt;span class="n"&gt;Managers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getManager&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IViewManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;setMainComponent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;It's easy. We get our manager with the Managers class, then, we set our label as the main component.&lt;/p&gt;
&lt;p&gt;Now we'll declare our module in Spring context. It's a simple XML file :&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;first.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We put this file at the same level of DemoFirstModule. For those who doesn't know spring, it's exactly if we create a new instance of our module and assign it to a variable named firstModule.&lt;/p&gt;
&lt;p&gt;We'll try this module. Then, we have to generate a jar of our project. The manifest of the jar must have the link to our XML file. Here is our manifest file :&lt;/p&gt;
&lt;pre&gt;Manifest-Version: 1.0

Module-Context: org/jtheque/demos/first/first.xml&lt;/pre&gt;

&lt;p&gt;Then we generate our Jar file and put it on the modules files of the JTheque environment with the name of jtheque-demo-module-1.jar.&lt;/p&gt;
&lt;p&gt;Now we have to configure JTheque to put our module in the application. To do that, we have to edit the config.xml file in the core.file. We just add the discovery tag to say that all the modules in the modules folder to the application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;config.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can now test the result launching JTheque-Launcher.jar and here is what we get :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/02/Screen2.png"&gt;&lt;img class="size-medium wp-image-151" title="Hello World" src="http://wichtounet.github.io/wp-content/uploads/2010/02/Screen2-300x233.png" alt="Hello World" width="300" height="233"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Like we can see, our module is good integrated in our application.&lt;/p&gt;
&lt;!--nextpage--&gt;

&lt;h4&gt;5. The second module&lt;/h4&gt;

&lt;p&gt;We will now create a second module who will add an option menu to display another Hello World. We could of course do that in the first module, but it's to show how to create several modules.&lt;/p&gt;
&lt;p&gt;To add options menu, we just need the plug pahse. Here is the base of the new module (DemoSecondModule) :&lt;/p&gt;
&lt;p&gt;[java]@Module(id = "jtheque-demo-module-2", i18n = "classpath:org/jtheque/demos/second/i18n/second", version = "1.0",
        core = "2.0.3", jarFile = "jtheque-demo-module-2.jar")
public final class DemoSecondModule {
    @Plug
    public void plug() {
    }
}[/java]&lt;/p&gt;
&lt;p&gt;With this i18n files :&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;second_fr.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;jtheque-demo-module-2.name=JTheque Demo Module 2

jtheque-demo-module-2.author=Baptiste Wicht

jtheque-demo-module-2.description=Deuxième module de démo

dialog.message=Bonjour le monde !&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;second_en.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;jtheque-demo-module-2.name=JTheque Demo Module 2

jtheque-demo-module-2.author=Baptiste Wicht

jtheque-demo-module-2.description=Second demo module

dialog.message=Hello world !&lt;/pre&gt;

&lt;p&gt;It's basically the same things than for the first module. We'll now add an option to the "File" menu. For that, we have to add an internationalizable action, JThequeAction.&lt;/p&gt;
&lt;p&gt;So here is our simple action :&lt;/p&gt;
&lt;p&gt;[java]package org.jtheque.demos.second;&lt;/p&gt;
&lt;p&gt;import org.jtheque.core.managers.view.able.IViewManager;&lt;/p&gt;
&lt;p&gt;import org.jtheque.core.managers.view.impl.actions.JThequeAction;&lt;/p&gt;
&lt;p&gt;import org.jtheque.core.managers.Managers;&lt;/p&gt;
&lt;p&gt;import java.awt.event.ActionEvent;&lt;/p&gt;
&lt;p&gt;final class HelloWorldAction extends JThequeAction {
    HelloWorldAction() {
        super("dialog.message");
    }&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;Override&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;actionPerformed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ActionEvent&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Managers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getManager&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IViewManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;displayI18nText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"dialog.message"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}[/java]&lt;/p&gt;
&lt;p&gt;Nothing hard, we use the IViewManager to display an internationalizable text in a dialog box. We can now add this action on the menu using the IFeatureManager. From JTheque Core 2.0.3, there is a declarative way to create menu actions with the Menu interface. For that, we can extends the AbstractMenu class and choose the methods to override to add menus (features).&lt;/p&gt;
&lt;p&gt;[java]@Plug&lt;/p&gt;
&lt;p&gt;public void plug() {
    Managers.getManager(IFeatureManager.class).addMenu(new DemoMenu());
}&lt;/p&gt;
&lt;p&gt;private static final class DemoMenu extends AbstractMenu {
    @Override
    protected List getFileMenuSubFeatures(){
        return features(
                createSubFeature(150, new HelloWorldAction())
        );
    }
}[/java]&lt;/p&gt;
&lt;p&gt;We just add an action on the "File" menu, with our action and we give it the 150 position (0 is the first position and 1000 is the last (exit)).&lt;/p&gt;
&lt;p&gt;Then we create the Spring xml file of the second module :&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;second.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[xml]&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd"&amp;gt;&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;bean&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"secondaryModule"&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"org.jtheque.demos.second.DemoSecondModule"&lt;/span&gt; &lt;span class="n"&gt;lazy&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"false"&lt;/span&gt; &lt;span class="o"&gt;/&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;lt;/beans&amp;gt;[/xml]&lt;/p&gt;
&lt;p&gt;We can now generate the Jar file of the second module with this manifest :&lt;/p&gt;
&lt;pre&gt;Manifest-Version: 1.0

Module-Context: org/jtheque/demos/second/test.xml&lt;/pre&gt;

&lt;p&gt;Finally, we can test the complete application using JTheque-Launcher.jar :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/02/Screen3.png"&gt;&lt;img class="size-medium wp-image-160" title="Nouveau menu" src="http://wichtounet.github.io/wp-content/uploads/2010/02/Screen3-300x170.png" alt="Nouveau menu" width="300" height="170"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wichtounet.github.io/wp-content/uploads/2010/02/Screen4.png"&gt;&lt;img class="size-medium wp-image-161" title="Hello world" src="http://wichtounet.github.io/wp-content/uploads/2010/02/Screen4-300x232.png" alt="Hello world" width="300" height="232"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Our second module is well integrated.&lt;/p&gt;
&lt;!--nextpage--&gt;

&lt;h4&gt;6. Conclusion&lt;/h4&gt;

&lt;p&gt;With relatively few code, we have developed a modular applications with 2 modules and that can have a lot more of modules.&lt;/p&gt;
&lt;p&gt;The services given by JTheque are many more. If you want to know more, for the moment, i'll guide you to the Javadoc of the last version of the core. I will try to create a full guide to present all the functionalities of the core.&lt;/p&gt;
&lt;p&gt;If you want to comment this article, don't hesitate to add a comment on the comment form at the end of the page.&lt;/p&gt;
&lt;p&gt;If you want to make a comment, a suggestion or talk about the JTheque project, you can also come to the dedicated forum. It's a french forum, but you can post in english.&lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Java</category><category>JTheque</category><category>JTheque</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/02/modular-application-jtheque-core-2-0-3.html</guid><pubDate>Sun, 07 Feb 2010 05:38:45 GMT</pubDate></item></channel></rss>