<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>@Blog("Baptiste Wicht") (Develop a modular application)</title><link>http://wichtounet.github.io/</link><description></description><atom:link type="application/rss+xml" rel="self" href="http://wichtounet.github.io/categories/develop-a-modular-application.xml"></atom:link><language>en</language><lastBuildDate>Sun, 16 Mar 2014 21:44:31 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Develop a modular application - The loading</title><link>http://wichtounet.github.io/posts/2010/05/modular-application-loading-modules.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Now that we've seen &lt;a href="http://www.baptiste-wicht.com/2010/05/develop-a-modular-application-implementation/"&gt;how to describe a module in Java&lt;/a&gt;, we'll see how to load it dynamically in our application.&lt;/p&gt;
&lt;p&gt;In Java, all the classes are loaded using several ClassLoader.In this article, we'll develop a loader for our modules and watch the problems that arrive when working with custom ClassLoaders.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Normally, Java use the system ClassLoader to load all the classes of our application. So it contains all the classes of our application and all the classes our application needs to work. But the problem is that we cannot add our modules jar files into classpath because the application doesn't know the modules jar files names.&lt;/p&gt;
&lt;p&gt;Moreover, we cannot theoretically add files to the system ClassLoader. I say theoretically because, we can add files using reflection and call to a private method, but i thing it's not a really good practice.&lt;/p&gt;
&lt;p&gt;So we've to create a new ClassLoader to load our modules. We'll do that in two phases :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;Browse the module files to get the classes of the modules and the URLs of the modules Jar files&lt;/li&gt;
    &lt;li&gt;Load the modules into our ClassLoader using the URLs of the first phase&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We'll do all the loading in a new class ModularLoader. so let's create a create a method that return the list of classes to load :&lt;/p&gt;
&lt;p&gt;[java]public class ModuleLoader { 
  private static List&amp;lt;URL&amp;gt; urls = new ArrayList&amp;lt;URL&amp;gt;(); &lt;/p&gt;
&lt;p&gt;private static List&amp;lt;String&amp;gt; getModuleClasses(){ 
    List&amp;lt;String&amp;gt; classes = new ArrayList&amp;lt;String&amp;gt;(); &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//Get all the modules of the modules folder&lt;/span&gt;
&lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"folder"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ModuleFilter&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
  &lt;span class="n"&gt;JarFile&lt;/span&gt; &lt;span class="n"&gt;jarFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="c1"&gt;//Open the Jar File&lt;/span&gt;
    &lt;span class="n"&gt;jarFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;JarFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//We get the manifest&lt;/span&gt;
    &lt;span class="n"&gt;Manifest&lt;/span&gt; &lt;span class="n"&gt;manifest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jarFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getManifest&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//We get the class name from the manifest attributes&lt;/span&gt;
    &lt;span class="n"&gt;classes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;manifest&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getMainAttributes&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Module-Class"&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toURI&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;toURL&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jarFile&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
      &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;jarFile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
      &lt;span class="p"&gt;}&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;classes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;private static class ModuleFilter implements FileFilter { 
    @Override 
    public boolean accept(File file) { 
      return file.isFile() &amp;amp;&amp;amp; file.getName().toLowerCase().endsWith(".jar"); 
    } 
  } 
}[/java]&lt;/p&gt;
&lt;p&gt;Like you see, it's not complicated at all. We search all the module files and then for each jar file, we open it, get the manifest et read the class name of the module. And then, for the second phase, we get the URL to the Jar file. &lt;/p&gt;
&lt;p&gt;Of course, this loader is not perfect. We can have modules with no manifest or manifest with no class name and the errors must be correctly treated, but this is not the objective of this post to be perfect. &lt;/p&gt;
&lt;p&gt;Now we can do the second phase, adding a method to create the ClassLoader, instantiate the modules and return them : &lt;/p&gt;
&lt;p&gt;[java]private static ClassLoader classLoader; &lt;/p&gt;
&lt;p&gt;public static List&amp;lt;IModule&amp;gt; loadModules(){ 
  List&amp;lt;IModule&amp;gt; modules = new ArrayList&amp;lt;IModule&amp;gt;(); &lt;/p&gt;
&lt;p&gt;AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;(){ 
    @Override 
    public Object run() { 
      classLoader = new URLClassLoader( 
          urls.toArray(new URL[urls.size()]),&lt;br&gt;
          ModuleLoader.class.getClassLoader()); &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}); &lt;/p&gt;
&lt;p&gt;//Load all the modules
  for(String c : getModuleClasses()){ 
    try { 
      Class&amp;lt;?&amp;gt; moduleClass = Class.forName(c, true, classLoader); &lt;/p&gt;
&lt;div class="code"&gt;&lt;pre&gt;  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IModule&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isAssignableFrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;moduleClass&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt; 
    &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;IModule&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;castedClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;IModule&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt; &lt;span class="n"&gt;moduleClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;IModule&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;castedClass&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
  &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ClassNotFoundException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InstantiationException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IllegalAccessException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;return modules; 
}[/java]&lt;/p&gt;
&lt;p&gt;So we start creating a new ClassLoader taking the urls of the Jar files. Then, we use this ClassLoader to load all the module classes and instantiate them. We only verify if the class is of type IModule. &lt;/p&gt;
&lt;p&gt;This is all for our ModuleLoader. We can now test our simple modular application. We create a JAR file for the module of the previous post and then we create a very simple application to test that : &lt;/p&gt;
&lt;p&gt;[java]List&amp;lt;IModule&amp;gt; modules = ModuleLoader.loadModules(); &lt;/p&gt;
&lt;p&gt;for(IModule module : modules){ 
  System.out.println("Plug : " + module.getName()); 
  module.plug(); 
} &lt;/p&gt;
&lt;p&gt;System.out.println("Lot of other things done by the application. "); &lt;/p&gt;
&lt;p&gt;for(IModule module : modules){ 
  module.unplug(); 
}[/java]&lt;/p&gt;
&lt;p&gt;And here is the output of the application : &lt;/p&gt;
&lt;pre&gt;Plug : Simple module

Hello kernel !

Lot of other things done by the application. 

Bye kernel !&lt;/pre&gt;

&lt;p&gt;Like you can see, we just created a modular applications ! The application doesn't know the modules, but the modules can do things in the application. &lt;/p&gt;
&lt;p&gt;Of course, to create a real applicatio, we have to develop all the extension points and services, but this is a base to start with. &lt;/p&gt;
&lt;p&gt;However, there is some problems with the current implementations : &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;We cannot deploy modules without restarting the application, because we must create a new ClassLoader for the modules. This is possible if there is no interation between modules, but that's not often the case. You have also the possibility to isolate all the modules in a specific ClassLoader, but with that second solution, the interations between modules are made harder. &lt;/li&gt;
    &lt;li&gt;Using a second ClassLoader may be problematic with libraries loading dynamically the classes like Spring or Hibernate. To make these libraries working with your ClassLoader, you have to look at case by case depending on the library. Often, you achieve specifying the contextClassLoader using the method  Thread.currentThread().setContextClassLoader(ClassLoader cl) with your ClassLoader&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So here is the end of this four posts about creating a modular application. I hope you find these posts interesting. &lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/modular-application-loading-modules.html</guid><pubDate>Fri, 14 May 2010 06:33:40 GMT</pubDate></item><item><title>Develop a modular application – Implementation</title><link>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-implementation.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Now that we saw in details &lt;a href="http://www.baptiste-wicht.com/2010/05/modular-application-modules/"&gt;the characteristics of the modules&lt;/a&gt;, we'll see how to implement a module.&lt;/p&gt;
&lt;p&gt;We need a simple container for our module to load it after with a loader from the modular application.&lt;/p&gt;
&lt;p&gt;In this post, we'll only see what will be a module in Java, we'll the loading of the modules in the next (and last) post.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;A module is completely independent of the module, so we cannot include it directly in the application. We must distinguish the file of the module and the file of the application.&lt;/p&gt;
&lt;p&gt;So what will be these files ? Because we're in Java, we use Jar files. So the modules will be Jar files extending the applications.&lt;/p&gt;
&lt;p&gt;And now in Java, a module will be an interface  describing the main characteristics of the module. We'll be simple for the moment. A module must be pluggable to the application and unpluggable. Moreover the module has also a name and we can get this name. At this moment, this is all we need :&lt;/p&gt;
&lt;p&gt;We must have a simple interface to describe a module :&lt;/p&gt;
&lt;p&gt;[java]public interface IModule {
  public void plug();
  public void unplug();
  public String getName();
}[/java]&lt;/p&gt;
&lt;p&gt;With that interface, we can create the most simple module that only prints to the console :&lt;/p&gt;
&lt;p&gt;[java]package org.modules.simple; &lt;/p&gt;
&lt;p&gt;public class SimpleModule implements IModule {
  @Override
  public void plug(){
    System.out.println("Hello kernel !");
  } &lt;/p&gt;
&lt;p&gt;@Override
  public void unplug(){
    System.out.println("Bye kernel !");
  } &lt;/p&gt;
&lt;p&gt;@Override
  public String getName(){
    return "Simple module";
  }
}[/java]&lt;/p&gt;
&lt;p&gt;So we'll create a Jar file containing our class. We need a solution for the application to know which class to launch. So we need write this somewhere.&lt;/p&gt;
&lt;p&gt;A naïve solution is to browse the Jar file and test each class if it implements the interface. This method works but is not optimal but that can be really inefficient in large Jar file. So we'll use the tools offered by Java and add an information in the Jar manifest to indicate to the application which class must be loaded.&lt;/p&gt;
&lt;p&gt;So here it's the manifest for our example :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;pre&gt;Manifest-Version: 1.0
&lt;p&gt;Module-Class: org.modules.simple.SimpleModule&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;With that the module loader will know which class it must instantiate to create a module.  An other solution is to use the ServiceLoader of Java 6.&lt;/p&gt;
&lt;p&gt;In the next post, we'll see how to load our module and we'll test an application with two simples modules.&lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-implementation.html</guid><pubDate>Wed, 12 May 2010 06:29:23 GMT</pubDate></item><item><title>Develop a modular application – The modules</title><link>http://wichtounet.github.io/posts/2010/05/modular-application-modules.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;After &lt;a href="http://www.baptiste-wicht.com/2010/05/develop-a-modular-application-bases/"&gt;explaining what's a modular application&lt;/a&gt;, I'll now explain with more details the concept of modules.&lt;/p&gt;
&lt;p&gt;We said that a module add features to the application. But before writing any code, we've to define exactly what are the modules, what they can do if there is several types of modules, ...&lt;/p&gt;
&lt;p&gt;This is what we'll see in this post.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;The first question to ask is "What can a module do ?". Namely, defining all the things a module can add to the application and how they can add these things. Moreover, a module can also modify the application.&lt;/p&gt;
&lt;p&gt;What the modules can do depends on the type of the modular application :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;For the first type (simple application with extension capability), the module adds specific features depending on the application. By example, in the case of an application that allows to watch television from internet, the modules can add a new channel or the support of a new video format. It can also adds a complete feature like statistics about channels. &lt;/li&gt;
    &lt;li&gt;For the second type (empty application and modules that make the application features), the modules don't add features to the application, they do the application. In this case, the modules are often bigger than in the first case, because, modules are applications. There is often no links between modules, one can create a calculator and the other a video editor. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the two cases, we've to define several extension points. By example, here are the extension points I created for JTheque : &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Add tabs in the main view&lt;/li&gt;
    &lt;li&gt;Add components in the state bar&lt;/li&gt;
    &lt;li&gt;Add features to the menu&lt;/li&gt;
    &lt;li&gt;Add configuration options&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With there extension points, the modules can do a lot of things. If we want to make a calculator, we can add a tab in the main view or add a feature in the menu that displays a calculator in a dialog. Of course, this extension points depends of the developer and the application, but this is really important to define well a list of this points. &lt;/p&gt;
&lt;p&gt;More than providing extension points, the core of the application provide also a set of services to the modules. These services can be simple utility classes or by example a persistence manager or a file manager. &lt;/p&gt;
&lt;p&gt;One more time, you've to decided which services the core will provide to the modules. This services are not essential, but that enables to simplify a lot the modules. And that improve the code standard of the modules. With that model, the modules will always use the same type of services, this is easier to manage.  &lt;/p&gt;
&lt;p&gt;By example, here are some of services, JTheque Core offers to the modules : &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Error manager : To display some errors. &lt;/li&gt;
    &lt;li&gt;View manager : To create easily new views, display messages, ask something to the user. &lt;/li&gt;
    &lt;li&gt;Resource manager : Provide an image cache and utility methods to load image, create thumbnail, ...&lt;/li&gt;
    &lt;li&gt;Persistence manager : Give the ability to modules to persist objects&lt;/li&gt;
    &lt;li&gt;State manager : Store states for modules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can also think if we want only one type of modules or several. By example, you can imagine primary modules and normal modules. Only a primary module can be launched at the same time. &lt;/p&gt;
&lt;p&gt;The last point I see, is the point of the dependencies between modules. We can allows that a module depends on an other modules. This add a difficulty level for the implementation, because we must verify that the dependencies are solved before launch a module. And what about circular dependencies ? This is the choice of developer, but if you don't allow dependencies between modules, it can e difficult to create good applications. &lt;/p&gt;
&lt;p&gt;So I've finished to talk about modules. Don't hesitate to comment if you doesn't agree with something or if you have questions. In the next I'll implement the first modules and in the last, I will create a simple loader for modules. &lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/modular-application-modules.html</guid><pubDate>Mon, 10 May 2010 06:24:29 GMT</pubDate></item><item><title>Develop a modular application – Bases</title><link>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-bases.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;This is the first post of four posts about modular applications.&lt;/p&gt;
&lt;p&gt;I'll try to explain all the things we must think of when we develop a modular application. I'm developing a generic core for modular applications, JTheque. So what I'm saying in this posts are taken from my experience developing this framework. &lt;/p&gt;
&lt;p&gt;In this post, i'll start talking of the bases of the conception of modular application. So what's a modular application, a module and what give to the developer and the user to have a modular application ? In the next posts, I'll describe the problems we could found relating to modules and loading. The examples will be in Java, but all the concepts can be applied to every language. I'll not talk about OSGi, this is more an introduction to modular programming without specific framework, but of course, OSGi is a very good solution to modular programming.&lt;/p&gt;
&lt;p&gt;Of course, I don't think i'm a professional in modular programming and what I'll say in this post, is nothing else than my point of view. If you think there is better solutions than what I present, don't hesitate to say that in comments.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;To start, what's a modular application ? A modular application is made of 2 distinct parts : &lt;/p&gt;
&lt;p&gt;The core : Like its name says, this is the central part of the application. This part must be completely independent of the modules. &lt;/p&gt;
&lt;p&gt;The modules : It's the dynamic parts we'll add to the application to add features. There is other name for modules : add-ons, plugins and lot of other name, but the concept is the same. &lt;/p&gt;
&lt;p&gt;I think there is two types of modular applications. The first type is a normal application who provide several features and give the user the possibility to add functionalities with modules. The second type is an application who has a core without feature. All the features are provided by the modules, so, "All is module". &lt;/p&gt;
&lt;p&gt;The main difference is that the first type can be used like any other application without modules, but the second one is not useful without modules. &lt;/p&gt;
&lt;p&gt;In these two types of applications, you've to define some extension points for the modules. With that extension points, the modules can add features to the application or modify some features. &lt;/p&gt;
&lt;p&gt;JTheque is based on the second type. JTheque Core is a simple core to develop modular applications. We can also talk of Eclipse that is a fully modular framework. &lt;/p&gt;
&lt;p&gt;Now the question is : that seems good but what the hell does that offer ? First, from the point of view of a developer, this allows to clearly separate the different parts of its application. We've distinct modules easier to maintain than a big applications. It's also easy to add features to applications. And last but not least, you can use the core several times for building different applications. From the point of view of the user, he can choose which modules he want to launch, add new modules and perhaps create some modules if he can. So he can customize applications. &lt;/p&gt;
&lt;p&gt;But, that not trivial to make, you've to make a good conceptions and implement it in a clean way. When you do, you find some problmens to solve and a lot of questions to ask. We'll see all the problems and questions in &lt;a href="http://www.baptiste-wicht.com/2010/05/modular-application-modules/"&gt;the next post&lt;/a&gt;. &lt;/p&gt;&lt;/div&gt;</description><category>Conception</category><category>Develop a modular application</category><category>Java</category><category>Java</category><category>Modular</category><guid>http://wichtounet.github.io/posts/2010/05/develop-a-modular-application-bases.html</guid><pubDate>Thu, 06 May 2010 06:28:38 GMT</pubDate></item></channel></rss>