<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Blog blog("Baptiste Wicht"); (Posts about JR)</title><link>http://baptiste-wicht.com/</link><description></description><atom:link rel="self" type="application/rss+xml" href="http://baptiste-wicht.com/categories/jr.xml"></atom:link><language>en</language><lastBuildDate>Sun, 04 Jun 2017 20:17:49 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>JR Virtual machines</title><link>http://baptiste-wicht.com/posts/2010/07/jr-virtual-machines.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Until now, we've always had concurrent program working in one virtual machines, but JR provides ways to declare several virtual machines on several different physical machines. A JR Virtual Machine contains a Java Virtual Machine and a layer for the JR language. Once you created some virtual machines, you can specify where an object will be created with a variant of the new operator. After that, almost all the development is transparent. By example,  a send operation on an operation serviced by an other virtual machine is exactly the same as if there is only one virtual machine. You can do exactly the same thing. We'll see that there is some differences, but it's really easy.&lt;/p&gt;
&lt;p&gt;An important thing to remember is that all the virtual machines created contains the static part of the application. So all the static part is local to the virtual machines. This can cause really difficult bug to solve if we don't take care.&lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/07/jr-virtual-machines.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>JR</category><guid>http://baptiste-wicht.com/posts/2010/07/jr-virtual-machines.html</guid><pubDate>Fri, 09 Jul 2010 05:00:12 GMT</pubDate></item><item><title>Rendezvous, concurrency method, in JR</title><link>http://baptiste-wicht.com/posts/2010/07/rendezvous-concurrency-jr.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;In this post, we'll see a new feature of JR : the rendezvous.&lt;/p&gt;
&lt;p&gt;Like asynchronous message passing, this synchronization method involves two processes : a caller and a receiver. But this time, the invocation is synchronous, the caller delays until the operation completes. The rendezvous does not create a new thread to the receiver. The receiver must invoke an input statement (the implementation of rendezvous) and wait for the message. Like asynchronous message passing, this is achieved using operations as message queue.&lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/07/rendezvous-concurrency-jr.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>JR</category><guid>http://baptiste-wicht.com/posts/2010/07/rendezvous-concurrency-jr.html</guid><pubDate>Wed, 07 Jul 2010 05:05:20 GMT</pubDate></item><item><title>Asynchronous Message Passing in JR</title><link>http://baptiste-wicht.com/posts/2010/07/asynchronous-message-passing-jr.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;We've now covered the basic synchronization systems (&lt;a href="http://www.baptiste-wicht.com/2010/01/jr-introduction/" target="_blank"&gt;semaphore&lt;/a&gt;, &lt;a href="http://www.baptiste-wicht.com/2010/06/monitor-programming-in-jr/" target="_blank"&gt;monitors&lt;/a&gt;) and we know how to &lt;a href="http://www.baptiste-wicht.com/2010/06/jr-operations-and-capabilities/" target="_blank"&gt;declare operations and capabilities&lt;/a&gt; . It's time to go to an other form of synchronization : &lt;strong&gt;Message Passing&lt;/strong&gt;. In this post, we'll focus in &lt;strong&gt;Asynchronous Message Passing&lt;/strong&gt;, we'll cover later, the synchronous message passing system with RendezVous.&lt;/p&gt;
&lt;p&gt;When we use message passing, the threads doesn't share datas anymore, they share channels. You can see channels like an abstraction of a network between several processes. The processes will send messages to other and the other will wait for receive a message. Normally, with that form of synchronization, the channels are the only objects shared between the threads. So you doesn't need to share memory. That makes possible to distribute the processes across several virtual machines or computers, of course, this also works on a simple computer, like any other program. In message passing, we often see models with several clients and a server that manage the messages. &lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/07/asynchronous-message-passing-jr.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>JR</category><guid>http://baptiste-wicht.com/posts/2010/07/asynchronous-message-passing-jr.html</guid><pubDate>Fri, 02 Jul 2010 05:02:09 GMT</pubDate></item><item><title>JR Operations and Capabilities</title><link>http://baptiste-wicht.com/posts/2010/06/jr-operations-and-capabilities.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Now that we've seen how to use &lt;a target="_blank" href="http://www.baptiste-wicht.com/2010/01/jr-introduction/"&gt;semaphores&lt;/a&gt; and &lt;a target="_blank" href="http://www.baptiste-wicht.com/2010/06/monitor-programming-in-jr/"&gt;monitors&lt;/a&gt; in JR, we must go to message passing. But before, we must learn how to use operation and capabilities in JR. These concepts are used in JR to message passing, so we must learn them before. &lt;/p&gt;
&lt;p&gt;An operation (or op-method) has the same form as a method declaration but are declared with a op keyword. An operation can be invoked the same way as a normal method or can be invoked with a call statement (also with a send statement as we'll see in next post about JR). &lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/06/jr-operations-and-capabilities.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Java</category><category>JR</category><guid>http://baptiste-wicht.com/posts/2010/06/jr-operations-and-capabilities.html</guid><pubDate>Wed, 30 Jun 2010 04:45:03 GMT</pubDate></item><item><title>Monitor programming in JR</title><link>http://baptiste-wicht.com/posts/2010/06/monitor-programming-in-jr.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Like I promised, I will restart to write articles now that the evaluation period is over. &lt;/p&gt;
&lt;p&gt;After seeing &lt;a href="http://www.baptiste-wicht.com/2010/01/jr-introduction/"&gt;how to develop using the JR programming language&lt;/a&gt;, we'll see now how to use monitors in JR.&lt;/p&gt;
&lt;p&gt;Monitors provide a higher-level abstraction than semaphores and produce a better code with several advantages :&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;All the synchronization code is centralized in one location and the users of this code doesn't need to know how it's implemented.&lt;/li&gt;
    &lt;li&gt;The code doesn't depends on the number of processes, it works for as much process as you want&lt;/li&gt;
    &lt;li&gt;You doesn't need to release something like a mutex, so you cannot forget to do it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The mutual exclusion is implicit with monitors. Only one process is allowed in the monitor, so all the method are automatically guarded with synchronization code. The synchronization between threads is made using signaling system, with condition variables. A condition variable is a kind of queue of process who are waiting on the same condition. You have several operations available on a condition, the most important is to signal a process waiting to be awaken and to wait on a condition. There are some similitudes between signal/wait operations and P and V of semaphores, but this is a little different. The signal operation does nothing if the queue is empty and the wait operation put always the thread in the waiting queue. The process queue is served in a first come, first served mode. &lt;/p&gt;
&lt;p&gt;Now we'll see how to use them in JR. &lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/06/monitor-programming-in-jr.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Concurrency</category><category>Java</category><category>JR</category><guid>http://baptiste-wicht.com/posts/2010/06/monitor-programming-in-jr.html</guid><pubDate>Mon, 28 Jun 2010 04:30:35 GMT</pubDate></item><item><title>Introduction to JR programming language</title><link>http://baptiste-wicht.com/posts/2010/01/jr-introduction.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;h4&gt;1. Language overview&lt;/h4&gt;

&lt;p&gt;JR is a programming language especially created to solve concurrent programming problems. This language is an overview of Java who add to this last the main paradigms of concurrent programming. Moreover JR make easier the concepts still implemented in Java like process or semaphores. There is also several extensions for JR to add more functionalities like monitors and Conditional Critical Region (CCR). JR is the implementation of the SR language for Java.&lt;/p&gt;
&lt;p&gt;JR makes nothing else than add a layer over Java. Once we use the JR compiler, the JR source files are transformed in Java files and are executed by the virtual machine like any other Java class.&lt;/p&gt;
&lt;p&gt;JR is often used as a school support to learn concurrent programming.&lt;/p&gt;
&lt;p&gt;In this article, we will see the bases of the programmation with JR.&lt;/p&gt;
&lt;p&gt;The presented version is the one of June 2009, the version 2.00602 who are based on Java 6.0.&lt;/p&gt;
&lt;p&gt;This article need that you've installed the JR environment on your system. An article is available here for the installation under Windows.&lt;/p&gt;
&lt;p&gt;In this article, we will especially focus on the apports of the JR language for the concurrent programming. We will not see the the integrality of the language. JR has other benefits than make easier concurrent programming, but we will not see that in this article. Moreover, all the aspects of concurrent programming in JR will not be treated here.&lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/01/jr-introduction.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Java</category><category>JR</category><guid>http://baptiste-wicht.com/posts/2010/01/jr-introduction.html</guid><pubDate>Sat, 30 Jan 2010 12:01:49 GMT</pubDate></item><item><title>Install the JR environment on Windows</title><link>http://baptiste-wicht.com/posts/2010/01/install-jr-windows.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;h4&gt;1. JR Programming language&lt;/h4&gt;

&lt;p&gt;This article will present you the installation of JR on Windows. It's not an article to learn the JR programming language, this article focus on the installation of JR on Windows.&lt;/p&gt;
&lt;p&gt;JR is a programming language especially created to resolve concurrent programming problems. This language is an overlay of Java who add to this last the main paradigms of the concurrent programming. Moreover, JR make easier some concepts also implemented in Java like the process or the semaphores. There is also extensions to JR to implement other functionalities like monitors and Conditional Critical Region (CCR). JR is the implemenation of the SR language for Java.&lt;/p&gt;
&lt;p&gt;JR is mainly used as a school support to learn concurrent programming.&lt;/p&gt;
&lt;p&gt;In this article, we'll see how to install the JR environment under Windows.&lt;/p&gt;
&lt;p&gt;The used version is the one of June 2009, the 2.00602 who is based on Java 6.0.&lt;/p&gt;
&lt;h4&gt;2. Prerequisites&lt;/h4&gt;

&lt;p&gt;The prerequisites of JR are not many, you need two things :&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Java : in the case of the last version of JR, you need Java 6.0. An older version (1.00601) is still available for Java 1.4. To install it if it's not yet the cas, go to the &lt;a title="Website of Sun" href="http://java.com/en/download/index.jsp" target="_blank"&gt;website of Sun&lt;/a&gt; and follow the described procedure.&lt;/li&gt;
    &lt;li&gt;Perl : go on &lt;a title="Official Site of Perl" href="http://www.activestate.com/activeperl/" target="_blank"&gt;the official site&lt;/a&gt; and download the last version of ActivePerl. Then, you just have to follow the installation procedure.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once this two programs installed, we can go to the installation of JR.&lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/01/install-jr-windows.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Java</category><category>JR</category><guid>http://baptiste-wicht.com/posts/2010/01/install-jr-windows.html</guid><pubDate>Thu, 14 Jan 2010 11:17:21 GMT</pubDate></item></channel></rss>