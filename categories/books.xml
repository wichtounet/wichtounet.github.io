<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>@Blog("Baptiste Wicht") (Books)</title><link>http://wichtounet.github.io/</link><description></description><atom:link type="application/rss+xml" href="http://wichtounet.github.io/categories/books.xml" rel="self"></atom:link><language>en</language><lastBuildDate>Sun, 16 Mar 2014 20:01:18 GMT</lastBuildDate><generator>Nikola &lt;http://getnikola.com/&gt;</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Christmas offer - Buy 2 or more Packt Publishing eBooks for $5 each</title><link>http://wichtounet.github.io/posts/2012/12/christmas-offer-buy-packt-publishing-ebooks.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;For Christmas, Packt Publishing has an awesome offer available to everybody :)&lt;/p&gt;
&lt;p&gt;All eBooks from Packt Publishing are now available for only 5$ (€4 | £3 | AUS$5) each when you buy two or more eBooks. &lt;/p&gt;
&lt;p&gt;The offer is available until Thursday 3rd Jan 2013.&lt;/p&gt;
&lt;p&gt;More information about the promotion: &lt;a href="http://www.packtpub.com/news/stock-your-reader-christmas" title="Stock your reader this christmas"&gt;Stock your reader this christmas&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>Programming</category><category>Promotion</category><guid>http://wichtounet.github.io/posts/2012/12/christmas-offer-buy-packt-publishing-ebooks.html</guid><pubDate>Fri, 21 Dec 2012 11:39:50 GMT</pubDate></item><item><title>Packt Publishing celebrates its 1000th IT Book !</title><link>http://wichtounet.github.io/posts/2012/09/packt-publishing-thousandth-book-celebration.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Packt Publishing is about to publish its 1000th title, on the 30th of September, 2012.&lt;/p&gt;
&lt;p&gt;Packt published their first book in April 2004. They now have a lot of books on about every subject from web development to IT architecture, games to e-commerce. Their books are known for their high quality.&lt;/p&gt;
&lt;p&gt;For this occasion, they are offering a surprise gift to all their members. If you want to be part of it, you just have to sign up for a free Packt Publishing account. If you're already registered, you don't have anything to do! You need to be registered before the 30th of September in order to get involved.&lt;/p&gt;
&lt;p&gt;Packt is also known for their support to Open Source. They support Open Source projects through a project royalty donation. They already have contributed over £300,000. For this special occasion, they will allocate 30,000 to share between projects and authors in their own way that will be disclosed on the website soon.&lt;/p&gt;
&lt;p&gt;For more information about Packt Publishing, their books or how to sign-up for a free account for this offer, you can view the official website: &lt;a title="http://www.packtpub.com" href="http://www.packtpub.com" target="_blank"&gt;http://www.packtpub.com/&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>Programming</category><category>Promotion</category><category>Releases</category><guid>http://wichtounet.github.io/posts/2012/09/packt-publishing-thousandth-book-celebration.html</guid><pubDate>Wed, 19 Sep 2012 20:44:44 GMT</pubDate></item><item><title>Algorithms books Reviews</title><link>http://wichtounet.github.io/posts/2012/08/algorithms-books-reviews.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;To be sure to be well prepared for an interview, I decided to read several &lt;strong&gt;Algorithms book&lt;/strong&gt;. I also chosen books in order to have information about data structures. I chose these books to read:
&lt;/p&gt;&lt;ol&gt;
    &lt;li&gt;Data Structures &amp;amp; Algorithm Analysis in C++, Third Edition, by Clifford A. Shaffer&lt;/li&gt;
    &lt;li&gt;Algorithms in a Nutshell, by George T. Heineman, Gary Pollice and Stanley Selkow&lt;/li&gt;
    &lt;li&gt;Algorithms, Fourth Edition, by Robert Sedgewick and Kevin Wayne&lt;/li&gt;
    &lt;li&gt;Introduction to Algorithms, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. I have to say that I have only read most of it, not completely, because some chapters were not interesting for me at the current time, but I will certainly read them later.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As some of my comments are about the presentation of the books, it has to be noted that I have read the three first books on my Kindle.&lt;/p&gt;
&lt;p&gt;In this post, you will find my point of view about all these books.&lt;/p&gt;
&lt;h4&gt;Data Structures &amp;amp; Algorithm Analysis in C++&lt;/h4&gt;

&lt;p&gt;This book is really great. It contains a lot of data structures and algorithms. Each of them is very clearly presented. It is not hard to understand the data structures and the algorithms.&lt;/p&gt;
&lt;p&gt;Each data structure is first presented as an ADT (Abstract Data Structure) and then several possible implementations are presented. Each implementation is precisely defined and analyzed to find its sweet pots and worst cases.  Other implementations are also presented with enough references to know where to start with them.&lt;/p&gt;
&lt;p&gt;I have found that some other books about algorithms are writing too much stuff for a single thing. This is not the case with this book. Indeed, each interesting thing is clearly and succinctly explained.&lt;/p&gt;
&lt;p&gt;About the presentation, the code is well presented and the content of the book is very well written. A good think would have been to add a summary of the most important facts about each algorithm and data structure. If you want to know these facts, you have to read several pages (but the facts are always here).&lt;/p&gt;
&lt;p&gt;The book contains very good explanation about the complexity analysis of algorihtms. It also contains a very interesting chapter about limits to computation where it treats P, NP, NP-Complete and NP-Hard complexity classes.&lt;/p&gt;
&lt;p&gt;This book contains a large number of exercises and projects that can be used to improve even more your algorithmic skills. Moreover, there are very good references at the end of each chapters if you want more documentation about a specific subject.&lt;/p&gt;
&lt;p&gt;I had some difficulty reading it on my Kindle. Indeed, it's impossible to switch chapters directly with the Kindle button. If you want quick access to the next chapter, you have to use the table of contents.&lt;/p&gt;
&lt;h4&gt;Algorithms in a Nutshell&lt;/h4&gt;

&lt;p&gt;This book is much shorter than the previous one. Even if it could be a good book for beginners, I didn't liked this book a lot. The explanations are a bit messy sometimes and it could contain more data structures (even if I know that this is not the subject of the book). The analysis of the different algorithms are a bit short too. Even if it looks normal for a book that short, it has to be known that this book has no exercise.&lt;/p&gt;
&lt;p&gt;However, this book has also several good points. Each algorithm is very well presented in a single panel. The complexity of each algorithm is directly given alongside its code. It helps finding quickly an algorithm and its main properties.&lt;/p&gt;
&lt;p&gt;Another thing that I found good is that the author included empiric benchmarks as well as complexity analysis. The chapters about Path Finding in AI and computational geometry were very interesting, especially because it is not widely dealt with in other books.&lt;/p&gt;
&lt;p&gt;It also has very good references for each chapter.&lt;/p&gt;
&lt;p&gt;This book was perfect to read with Kindle, the navigation was very easy.&lt;/p&gt;
&lt;h4&gt;Algorithms&lt;/h4&gt;

&lt;p&gt;This book is a good book, but suffers from several drawbacks regarding to other books. First, the book covers a lot of data structures and algorithms. Then, it also has very good explanations about complexity classes. It also has a lot of exercises. I also liked a lot the chapter about string algorithms that was lacking in previous books.&lt;/p&gt;
&lt;p&gt;Most of the time, the explanations are good, but sometimes, I found them quite hard to understand. Moreover, some parts of code are also hard to follow. The author included Java runs of some of programs. In my opinion, this is quite useless, empiric benchmarks could have been useful, but not single runs of the program. Some of the diagrams were also hard to read, but that's perhaps a consequence of the Kindle.&lt;/p&gt;
&lt;p&gt;A think that disappointed me a bit is that the author doesn't use big Oh notation. Even, if we have enough information to easily get the Big Oh equivalent, I don't understand why a book about algorithms doesn't use this notation.&lt;/p&gt;
&lt;p&gt;Just like the first book, there is no simple view of a given algorithm that contains all the information about an algorithm. Another think that disturbed me is that the author takes time to describe an API around the algorithms and data structures and about the Java API. Again, in my opinion only, it takes a too large portion of the book.&lt;/p&gt;
&lt;p&gt;Again, this book was perfect to read with Kindle, the navigation was very easy.&lt;/p&gt;
&lt;h4&gt;Introduction to Algorithms&lt;/h4&gt;

&lt;p&gt;This book is the most complete I read about algorithms and data structures by a large factor. It has very complete explanations about complexity analysis: big Oh, Big Theta, Small O. For each data structure and algorithm, the complexity analysis is very detailed and very well explained. The pieces of code are written in a very good pseudo code manner.&lt;/p&gt;
&lt;p&gt;As I said before, the complexity analysis are very complete and sometimes very complex. This can be either an advantage or a disadvantage, depending of what you awaits from the book. For example, the analysis is made using several notations Big Oh, Big Theta or even small Oh. Sometimes, it is a bit hard to follow, but it provides very good basis for complexity analysis in general.&lt;/p&gt;
&lt;p&gt;The book  was also the one with the best explanations about linear time sorting algorithms. In the other books, I found difficult to understand sorts like counting sort or bucket sort, but in this book, the explanations are very clear. It also includes multithreaded algorithm analysis, number theoretic algorithms, polynomials and a very complete chapter about linear programming.&lt;/p&gt;
&lt;p&gt;The book contains a huge number of exercises for each chapters and sub chapters.&lt;/p&gt;
&lt;p&gt;This book will not only help you find the best suited algorithm for a given problem, it will also help you understand how to write your own algorithm for a problem or how to analyze deeply an existing solution.&lt;/p&gt;
&lt;h4&gt;Algorithms Book Wrap-up&lt;/h4&gt;

&lt;p&gt;As I read all these Algorithms books in order, it's possible that my review is a bit subjective regarding to comparisons to other books.&lt;/p&gt;
&lt;p&gt;If you plan to work in C++ and need more knowledge in algorithms and C++, I advice you to read &lt;strong&gt;Data Structures &amp;amp; Algorithm Analysis in C++&lt;/strong&gt;, that is really awesome. If you want a very deep knowledge about algorithm analysis and algorithms in general and have good mathematical basis, you should really take a deep look at &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;. If you want short introduction about algorithms and don't care about the implementation language, you can read &lt;strong&gt;Algorithms in a Nutshell&lt;/strong&gt;. &lt;strong&gt;Algorithms&lt;/strong&gt; is like a master key, it will gives you good starting knowledge about algorithm analysis and a broad range of algorithms and data structures.&lt;/p&gt;&lt;/div&gt;</description><category>Algorithm</category><category>Books</category><category>C++</category><category>Conception</category><category>Java</category><category>Performances</category><category>Programming</category><guid>http://wichtounet.github.io/posts/2012/08/algorithms-books-reviews.html</guid><pubDate>Fri, 24 Aug 2012 08:52:04 GMT</pubDate></item><item><title>Advanced Compiler Design and Implementation - Book Review</title><link>http://wichtounet.github.io/posts/2012/05/advanced-compiler-design-and-implementation-book-review.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;After &lt;a title="Compilers : Principles, Techniques &amp;amp; Tools – Book Review" href="http://www.baptiste-wicht.com/2012/01/compilers-principles-techniques-tools/"&gt;having read my first book about compilers&lt;/a&gt;, I decided to try another one more focused on optimizations. For that, I chose "&lt;strong&gt;Advanced Compiler Design and Implementation&lt;/strong&gt;", by Steven S. Muchnick.&lt;/p&gt;
&lt;p&gt;This book covers several subjects about compilers, but more than 60% of the text is about compiler optimizations.&lt;/p&gt;
&lt;p&gt;The first chapter introduces the main concepts of compiler design. It also explains why optimization is so important in a compiler.&lt;/p&gt;
&lt;p&gt;The algorithms of this book are presented in ICAN (Informal Compiler Algorithm Notation) notation. The chapter two provides both a brief and a full description of this notation. In my case, the brief description has been enough to understand the algorithms presented in the following chapters, but it can be useful for a deep understanding of the notation to read the full description.&lt;/p&gt;
&lt;p&gt;The next chapter covers Symbol Table. It also includes a way to generate load and store instructions directly based on the information contained in the Symbol Table. Then, the fourth chapter presents the intermediate representations used in that book. This book uses three different intermediate languages: A high-level one, a medium-level one and a low-level. This chapter covers each of them in details. The importance of the design of an intermediate representation is also discussed here. There will be two more intermediate forms used in the book, static single-assignment (SSA) and program dependence graphs that are discussed later in the book.&lt;/p&gt;
&lt;p&gt;The chapter five gives some information about the different runtime support of some architectures. It is very useful to know how to handle high-level languages at runtime. The next one is about producing code generators automatically from machine descriptions. Three approaches are covered in this chapter.&lt;/p&gt;
&lt;p&gt;With the seventh chapter, the optimization techniques start. This chapter covers control-flow analysis. It will introduce several techniques that can be used to perform this kind of analysis, namely depth first search and dominators, interval analysis and structural analysis. These analysis can be used to identify structures like loops and branches in the intermediate representations. The chapter eight covers data-flow analysis. This chapter introduces a lot of mathematical concepts like lattices or flow functions. It takes some time to understand completely the concepts of this chapter, but the explanations are very good. Again, three methods of doing this analysis are studied. It covers iterative data-flow analysis, control-tree techniques and slotwise analysis. Another techniques are also introduced, but not covered in details. The chapter 9 covers dependence analysis. This analysis will be vital for optimizations on arrays and loops and to instruction scheduling techniques that will be studied later. Finally, the chapter ten introduces alias-analysis techniques.&lt;/p&gt;
&lt;p&gt;Once the analysis techniques have been covered, the other chapters are about optimization themselves. The chapter 11 introduces optimizations. It explains which optimizations should be performed at which level and in which order. It also describes briefly the optimizations that are covered in the next chapters. You will see that the following chapters are very rich, each of them containing a lot of optimizations that can be performed.&lt;/p&gt;
&lt;p&gt;The first optimizations that are covered (in chapter 12) are the so-called early optimizations. It includes scalar replacement of aggregates, value numbering, copy propagation and sparse conditional constant propagation. It also covers constant folding and algebraic simplifications. After that, the optimizations that reduce redundancy are covered. Again, several techniques are covered, common subexpression elimination, forward substitution, loop invariant code motion, partial redundancy elimination and code hoisting. Then, the loop optimizations are introduced. This chapter first introduces a way to identify induction variables in a loop and then covers some optimization that can be used. For example, strength reduction and unnecessary bounds checking optimizations are covered.&lt;/p&gt;
&lt;p&gt;The next two chapters are more related to low-level problematic. The chapter 15 covers optimizations that can be applied to reduce the cost of procedures. It discusses tail-call optimization, procedure integration, in-line expansion, leaf-routine optimization and shrink wrapping. The, the chapter 16 covers a very important subject that is Register Allocation. It covers several techniques like cost based methods and global graph coloring.&lt;/p&gt;
&lt;p&gt;The chapter 17 deals with code scheduling. It is a technique that reorder instructions to take best advantage of the pipelines built into ,modern processors. First, local approaches (within a basic block) are discussed and then optimization for scheduling across basic-block boundaries are covered. For the two subjects, several techniques are discussed. The chapter 18 covers low-level optimizations like unreachable-code elimination, loop inversion, dead-code elimination, etc... This chapter is very broad and very interesting too.&lt;/p&gt;
&lt;p&gt;The chapter 19 covers more complex optimization: the inteprocedural optimizations. Several techniques for doing inteprocedural analysis are covered in details as well as several optimizations depending on these analysis, like constant propagation. This chapter is not very simple to understand and even less to apply, but it is very interesting. The chapter 20 is the last about optimizations. It covers techniques to improve the memory hierarchy usage. The first optimizations are about instruction-cache: instruction prefetching, procedure sorting and procedure splitting for example. Then, data-cache optimizations are covered. It includes data prefetching and scalar replacement of array elements in details and gives an outline for some other optimizations.&lt;/p&gt;
&lt;p&gt;Finally, the chapter 21 studies four different compilers to see what optimizations are applied and in which order. Their intermediate forms are also studied. It is very interesting how this is done in real-world compiler.&lt;/p&gt;
&lt;p&gt;To conclude, I think that this book is really great. It covers a lot of optimizations that can be implemented in a compiler. All the optimizations are covered in details with code samples and examples of applying the optimization on some code. However, it has to be said that this book is not easy to read and sometimes it is hard to understand exactly what means a specific optimization and in what it differs from some close technique. If you want to write an aggressive optimizer compiler or just write some optimizations for an existing one, you should consider to take a look at this book.&lt;/p&gt;
&lt;p&gt;If you know another good book on Compilers, I will be glad to hear about it.&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>Compilers</category><category>Compilers</category><category>Optimization</category><guid>http://wichtounet.github.io/posts/2012/05/advanced-compiler-design-and-implementation-book-review.html</guid><pubDate>Tue, 15 May 2012 08:54:36 GMT</pubDate></item><item><title>Introduction to 64 Bit Intel Assembly Language Programming for Linux - Book Review</title><link>http://wichtounet.github.io/posts/2012/03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;The first book I read about Intel Assembly was lacking information about 64 bits programming. So I ordered and read &lt;strong&gt;Introduction to 64 Bit Intel Assembly Language Programming for Linux&lt;/strong&gt;, by Ray Seyfarth. &lt;/p&gt;
&lt;p&gt;This book covers a lot of subjects in assembly. It is adapted to people starting assembly, but it also contains advanced assembly programming techniques. I think that this book is adapted to a lot of people wanting to improve their skills in Intel Assembly. This book covers only &lt;strong&gt;64 bit Intel Assembly&lt;/strong&gt; in details. It does not cover old memory models, only the memory mode used now. &lt;/p&gt;
&lt;p&gt;This book uses yasm to assemble the programs. It uses gdb to debug the assembly programs. &lt;/p&gt;
&lt;p&gt;The first chapters are very general. They are covering numbers (octal, decimal and hexadecimal notions), computer memory and memory mapping mode. &lt;/p&gt;
&lt;p&gt;The first technical chapter covers Registers in details. It defines all the registers available in Intel Assembly. You will see how to move constants to registers. You will also learn how to move values between memory and registers. Then, the next chapter covers all the mathematical operations (negate, addition, subtraction, division and multiplication). It also covers the use of conditional move instructions. The next one is about bit manipulations (not, and, or and shift). It also covers bit testing and filling. &lt;/p&gt;
&lt;p&gt;After that, the chapter eight covers a very important subject: branching and looping. All the jumps are covered in details. You will see how to convert each control structure (if, for, while, do-while) of programming language to assembly. After that, the string instructions are also explained. Once you know how to create control structures, it's time to create your own functions. In that chapter, you will learn the stack and the function call conventions. The stack frames and the recursion are also covered. &lt;/p&gt;
&lt;p&gt;The arrays are covered in the next chapter. You will see how to allocate arrays on the stack or on the heap using malloc. The command line parameters are also covered (that was a very interesting part). &lt;/p&gt;
&lt;p&gt;Then, floating point math is covered. For that, the &lt;strong&gt;Streaming SIMD Extensions&lt;/strong&gt; (SSE) are used. All the math operations are covered. As is the way to transfer data between XMM registers and memory. The conversion and comparison instructions are also explained here. Some complete samples like dot product of 3D vectors help us understand the SSE instructions. &lt;/p&gt;
&lt;p&gt;The system calls are covered in details in chapter twelve. The C system library wrapper functions for system calls are also covered. After that, a whole chapter addresses structures. The allocation of structs is also addressed. Then, the way to use I/O streams from assembly is taught. &lt;/p&gt;
&lt;p&gt;A whole chapter is devoted to the implementation of data structures in Intel Assembly. The covered data structures are the linked lists, doubly linked lists, the hash tables and the binary trees. Each common operation on these data structures is implemented. &lt;/p&gt;
&lt;p&gt;After that, the last chapters are about optimization and performances. The chapter 16 covers &lt;strong&gt;High Performance Assembly Programming&lt;/strong&gt; in details. In that chapter, you will learn a set of optimization that can be applied to improve the performances of a given code. For example, you will see how to make efficient use of cache or how to make better performing loops. These optimization can also be applied to other programming languages. The following chapters are all covering a single problem and a way to optimize it the most using Intel Assembly. For each of these problems, the C version is compared to the assembly version. Three problems are presented: counting bits in an array of integers, the Sobel filter and computing the correlation of two variables given some sample values. &lt;/p&gt;
&lt;p&gt;To conclude, I found this book very book. It covers a lot of subjects in a very good manner. I liked a lot the performance techniques covered in the book. The deep coverage of SSE instructions was also very interesting. &lt;/p&gt;&lt;/div&gt;</description><category>Assembly</category><category>Assembly</category><category>Books</category><category>Intel</category><guid>http://wichtounet.github.io/posts/2012/03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html</guid><pubDate>Mon, 19 Mar 2012 09:41:54 GMT</pubDate></item><item><title>Compilers : Principles, Techniques &amp; Tools - Book Review</title><link>http://wichtounet.github.io/posts/2012/01/compilers-principles-techniques-tools.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Some weeks ago, I finished reading &lt;strong&gt;Compilers : Principles, Techniques &amp;amp; Tools&lt;/strong&gt;, by Afred V. Aho, Monica S. Lam, Ravi Sethi and Jeffrey D. Ullman. This book is also called the &lt;strong&gt;Dragon Book&lt;/strong&gt; due to the cover.&lt;/p&gt;
&lt;p&gt;This book is a reference about compiler construction and design. If you are interested in this subject, this book is for you, it's a must-have. However, I have to warn you that this book is very technical and hard. Honestly, some of the chapters are beyond my comprehension. Before this book, I had no real comprehension of the subject. I will certainly read again some of the chapters when I will have more practice into the subject.&lt;/p&gt;
&lt;p&gt;If you want, the book is full of exercises about each subject covered in the book. If you plan to do all the exercises, you'll need a lot of time as there are a lot of them and some of them are quite hard. I've done some of them but only a little part.&lt;/p&gt;
&lt;p&gt;The first chapter introduces the construction of compilers. You will see the common structure of compilers, the evolution of programming languages and the science behind building a compiler and its applications. The second chapter is still quite general. It will teach you how to develop a simple syntax-directed translator. This chapter is very important as it will give you the basics for understanding the following chapters. You will learn how to define a grammar, what are the main parsing techniques and what is lexical analysis. It will also covers symbol tables and intermediate language generation.&lt;/p&gt;
&lt;p&gt;With the third chapter (&lt;strong&gt;Lexical Analysis&lt;/strong&gt;), we are entering the hearth of the matter. You will learn the vocabulary behind lexical analysis (tokens, lexemes, attributes, ...). Then, after you've learned how to define and recognize tokens, you will see the different techniques to build an efficient lexical analyzer. The first technique that will be covered is the use of a lexer generator (Lex). Then you will see in details how to construct a lexer using regular expressions or finite automata especially Nondeterministic Finite Automata and Deterministic Finite Automata.&lt;/p&gt;
&lt;p&gt;The next one (&lt;strong&gt;Syntax Analysis&lt;/strong&gt;) is about parsing. After learning how to define and write a grammar you will see how to parse it. You will see in details the most commons types of parsing (Top-Down, Bottom-Up) and the most common parsers (LL(K) and LR(K) parsers). The construction of these kinds of parsers is covered in details and the way to optimize them is also teached. Finally, you will see how to automatically generate a parser using Lex and Yacc. This chapter is sometimes very hard to understand (in my own opinion) but very interesting especially if you plan to build parser without generating it with some advanced tools (for example Yacc or Boost Spirit for C++).&lt;/p&gt;
&lt;p&gt;The fourth chapter (&lt;strong&gt;Syntax Directed Translation&lt;/strong&gt;) explains you how to translate some source code (parse it) into a coherent structure (an abstract tree) using a Syntax Directed Scheme. The translation is made based on a syntax using semantic actions and rules to translate the source into something else. You'll see different ways of doing that translations.&lt;/p&gt;
&lt;p&gt;Then, the next one (&lt;strong&gt;Intermediate Code Generation&lt;/strong&gt;) teaches you how to generate Intermediate Code from the source. Two different representations are covered : syntax trees and three-address-code. Another subject covered in this chapter is type checking. You'll see in details how to translate expressions, control flow instructions and switch statements into three-address-code statements.&lt;/p&gt;
&lt;p&gt;The seventh chapter (&lt;strong&gt;Run-Time Environment&lt;/strong&gt;) gives a lot of information about the different run-time targets that you can compile for. A lot of subjects are covered here: stack and heap allocation, locality exploitation, garbage collectors... This chapter is in my opinion a very good instruction to computer architecture. You cannot imagine develop a compiler without having a deep understanding of the target machine.&lt;/p&gt;
&lt;p&gt;The next chapter (&lt;strong&gt;Code Generation&lt;/strong&gt;) is also a very important one. In this chapter, you will see how to generate assembly code from the three-address-code. You will learn how to select the good instructions. A very important subject covered in this chapter is register allocation. You'll learn how to choose wisely the registers to produce efficient code. The basic blocks are also covered there with flow graphs. More than just generating code from Three-Address-Code statements, you'll also see how to optimize them. Only local (to a basic block) optimization techniques  will be covered in this chapter. Several techniques that aims at testing if code is optimal are also taught there.&lt;/p&gt;
&lt;p&gt;The global optimizations are covered in the next chapter (&lt;strong&gt;Machine-Independent Optimizations&lt;/strong&gt;). You will discover several optimizations that you can do globally (inside a function but among different basic blocks). A data-flow analysis framework is explained here in details. After that, for each of the optimization, the parameters of the data flow analysis are explained. The optimization of loops is treated too.&lt;/p&gt;
&lt;p&gt;The three next chapters (&lt;strong&gt;Instruction-Level Parallelism&lt;/strong&gt;, &lt;strong&gt;Optimizing for Parallelism&lt;/strong&gt; &lt;strong&gt;and Localit&lt;/strong&gt;y and &lt;strong&gt;Interprocedural Analysis&lt;/strong&gt;) are the most complex of the book. They are covering in details the optimizations that can be made when a compiler supports instruction-level parallelism (executes several instructions in one clock cycle). It also covers interprocedural analysis of a program to allow even better optimization than global optimization inside a function. Honestly, I didn't understand some of the concepts described here. I will read them again one by one, chapter by chapter and try to implement some of the techniques in EDDI in the future.&lt;/p&gt;
&lt;p&gt;To conclude, I will say that Compilers : Principles, Techniques &amp;amp; Tools is a very good book that every compiler designer and developer should read before starting constructing a  compiler. Although very technical, it's quite clear and contains a huge amount of information. If  you plan to develop a compiler, it is a very good idea to read this book first.&lt;/p&gt;
&lt;p&gt;I've implement some of the techniques explained in this book in my own compiler. I implemented most of the local optimizations presented and Intermediate Code generation. You can find some information &lt;a title="EDDIC 0.7 : New compilation model and optimizations" href="http://www.baptiste-wicht.com/2012/01/eddic-0-7-compiler-model-optimizations/"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>C++</category><category>Compilers</category><category>Compilers</category><category>EDDI</category><category>Java</category><category>Optimization</category><category>Programming</category><guid>http://wichtounet.github.io/posts/2012/01/compilers-principles-techniques-tools.html</guid><pubDate>Thu, 12 Jan 2012 09:27:19 GMT</pubDate></item><item><title>EDDIC 0.7 : New compilation model and optimizations</title><link>http://wichtounet.github.io/posts/2012/01/eddic-0-7-compiler-model-optimizations.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I'm proud to announce a new release of EDDIC, the version 0.7.&lt;/p&gt;
&lt;p&gt;Most of the changes are internal to the compiler. I read a new book : &lt;em&gt;Compilers: Principles, Techniques, and Tools&lt;/em&gt; and applied some of the advices of the author. The biggest change is the use of a new intermediate representation : Three-Address-Code statements. This representation is easy, all the statements are basically of the form a = b + c with + being any operator of the language. The big advantage of this representation is that we can easily run optimization on it. Another advantage is that this representation is complete enough to represent most of the programming languages, so, we can imagine compiling several different source languages into the TAC language and then compiling them the same way.&lt;/p&gt;
&lt;p&gt;Once the Three-Address-Code representation is generated and separated into basic blocks, it is compiled into X86 assembly using a code generator. I've made a lot of improvements on the generated assembly. For example, I'm using several new instructions (neg, inc, dec, xor, ...) to generate more efficient code. Moreover, I'm doing a better use of registers with keeping variables into registers as long as possible.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h4&gt;Better optimization engine&lt;/h4&gt;
&lt;p&gt;Here is the list of what the optimizer do at the TAC level:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Simplify arithmetic identities : a = b + 0 =&amp;gt; a = b&lt;/li&gt;
    &lt;li&gt;Reduce in strength : a = b * 2 =&amp;gt; a = b + b&lt;/li&gt;
    &lt;li&gt;Constant folding : a = 2 + 2 =&amp;gt; a = 4&lt;/li&gt;
    &lt;li&gt;Constant propagation : when a constant is assigned to a, reuse the constant as long as no other assignment is made to a&lt;/li&gt;
    &lt;li&gt;Remove overridden assign&lt;/li&gt;
    &lt;li&gt;Remove dead basic blocks : when a condition is known at compile time we can know the path it will take and remove basic blocks that will never be taken&lt;/li&gt;
    &lt;li&gt;Remove needless jumps : After the other optimization have been done it is possible that a goto is directly targeting the next basic block so we can remove it&lt;/li&gt;
    &lt;li&gt;Merge basic blocks : After some statements have been replaced or removed it is possible that we can merge some basic blocks together&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;The optimizer is running the different optimization technique as long as one of them as an effect on the code. At the present time, the optimization techniques are used locally (within a basic block) so the generated assembly is not perfect, but for what I tested so far, it's a good start.&lt;/div&gt;

&lt;h4&gt;Other changes&lt;/h4&gt;

&lt;div&gt;Moreover, the language itself has also had some improvements:&lt;/div&gt;

&lt;div&gt;

&lt;ul&gt;
    &lt;li&gt;The minus and plus unary operators have been added to the grammar&lt;/li&gt;
    &lt;li&gt;The local and global variables can be const&lt;/li&gt;
    &lt;li&gt;A source file can now includes another source or a file from the standard library (very little for now, but a little start)&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;The project itself has also been improved&lt;/div&gt;

&lt;div&gt;

&lt;ul&gt;
    &lt;li&gt;Most of the classes and files are now documented using Doxygen&lt;/li&gt;
    &lt;li&gt;The unit tests are now testing compilation and execution of some samples, that helped me finding some bugs in the code base and in the new changes&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Download&lt;/h4&gt;

&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;You can find the compiler sources on the Github repository : &lt;a title="EDDI Compiler Repository" href="http://github.com/wichtounet/eddic"&gt;https://github.com/wichtounet/eddic&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The exact version I refer to is the v0.7 available in the github tags or directly as the release branch.&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>C++</category><category>Compilers</category><category>EDDI</category><category>EDDI</category><category>Optimization</category><guid>http://wichtounet.github.io/posts/2012/01/eddic-0-7-compiler-model-optimizations.html</guid><pubDate>Tue, 10 Jan 2012 09:28:18 GMT</pubDate></item><item><title>Moodle promotion on Packt Publishing Books</title><link>http://wichtounet.github.io/posts/2011/12/moodle-promotion-on-packt-publishing-books.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;In their December promotion, Pack Publishing are offering heavy discounts on all their Moodle books during all the month.&lt;/p&gt;
&lt;p&gt;You can find all books available on offer on this page : &lt;a href="http://www.packtpub.com/news/moodle-festive-month" target="_blank"&gt;http://www.packtpub.com/news/&lt;wbr&gt;moodle-festive-month&lt;/wbr&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There are great offers:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;Buy any &lt;strong&gt;Moodle &lt;/strong&gt;print book and get&lt;strong&gt; 20% off&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;Buy any &lt;strong&gt;Moodle &lt;/strong&gt;eBook and get&lt;strong&gt; 30% off&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For those who don't know Moodle, Moodle is currently the world's most popular E-learning platform. Moodle is a free, open-source PHP web application for producing modular internet-based courses that support a modern social constructionist pedagogy.&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>Others</category><category>Promotion</category><guid>http://wichtounet.github.io/posts/2011/12/moodle-promotion-on-packt-publishing-books.html</guid><pubDate>Tue, 13 Dec 2011 08:40:08 GMT</pubDate></item><item><title>C++ Templates : The Complete Guide - Book Review</title><link>http://wichtounet.github.io/posts/2011/11/cpp-templates-complete-guide-book.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;After the Effective C++ Serie, I read &lt;strong&gt;C++ Templates: The Complete Guide&lt;/strong&gt;, from David Vandevoorde and Nicolai M. Josuttis&lt;/p&gt;
&lt;p&gt;The templates are one of the most powerful feature of C++. However, this is a complex technique that is often misused or misunderstood. This book will help you learning what exactly are templates and how they can be used to improve your software development in C++.&lt;/p&gt;
&lt;p&gt;This book is sometimes very technical and is not the easiest to read. Nevertheless, the quality of the information it contains is great. This book covers all the aspects of template programming, from generic programming to template meta programming passing by traits and policy classes.&lt;/p&gt;
&lt;p&gt;The first two chapters are introducing function templates and class templates. Then, the third chapter is about the nontype template parameters. Indeed, template parameters can be values and not types. For example, you can pass int constants as template parameters. Then, the two following chapters are more about templates in practice. You will learn the different way to include template code in your common C++ base code. You will also see some tricks useful when developing templates. The last chapter of this first part is fixing a terminology for templates.&lt;/p&gt;
&lt;p&gt;The second part of the book (&lt;strong&gt;Templates in-Depth&lt;/strong&gt;) starts with the fundamentals  of templates in-depth. Then, the names in templates are covered in details. After that, we have three very technical and complex chapters. The first covers the instantiations of templates in-depth, the second covers the template argument detection and the next one is about specializations and overloading. The last chapter of this part is about the future directions of the C++ templates. This chapter covers some extensions that have been added to library and compilers,  but were not in C++ standard at the time the book was written. Some of these futures directions are now part of the new C++11 standard.&lt;/p&gt;
&lt;p&gt;The next part (&lt;strong&gt;Templates and Design&lt;/strong&gt;) is about the techniques that can be used to improve your software design using templates. The first chapter covers the most common use of templates: compile-time polymorphism. Then, the traits and policy classes are covered. The traits classes are a way to add more information to a template parameter and policy classes represent a configurable behavior for templates. The 16th is talking about some optimization that can be made about templates and inheritance. The next chapter focuses on template metaprogramming. A metaprogram is a program that is not computed at runtime, but at compile-time resulting in performance sometimes very important. Then, the last chapter introduces the expression templates. This technique is a way to encapsulate expressions into templates in order to optimize some computations. The example is about matrix computations.&lt;/p&gt;
&lt;p&gt;The final part (&lt;strong&gt;Advanced Applications&lt;/strong&gt;) present four examples in which the templates brings a lot of power. The first example is about type classification. How to know at compile-time of what kind is a given type and makes something depending on the characteristics of the type. The second example is about developing Smart Pointers. The next one presents an implementation of tuples with templates and the last one implements function objects and callbacks. These four examples are not made to be used instead of the standard library, but there are good examples to prove the power of templates.&lt;/p&gt;
&lt;p&gt;To conclude, I'll say that this book is a very good guide about templates. It covers most of the details that you can face when developing with templates or when working with very templatized libraries like Boost.&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>C++</category><category>C++</category><category>templates</category><guid>http://wichtounet.github.io/posts/2011/11/cpp-templates-complete-guide-book.html</guid><pubDate>Wed, 30 Nov 2011 08:32:11 GMT</pubDate></item><item><title>Effective STL Book Review</title><link>http://wichtounet.github.io/posts/2011/10/effective-stl-book-review.html</link><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I finished reading the last Effective C++ volume : Effective STL, Scott Meyers.&lt;/p&gt;
&lt;p&gt;Again, this book follows the same model as the two others, providing several rules aiming at making you a better (more effective) STL programmer. All the items of this book are centered on the usage of the Standard Template Library (STL).&lt;/p&gt;
&lt;p&gt;The first chapters (Containers) gives you several advices for using STL Containers. The main point of this chapter is about how to choose carefully a container for a specific use case. It also contains several advices on how to use them well regarding to performances and thread safety.&lt;/p&gt;
&lt;p&gt;In the next chapter (&lt;em&gt;vector&lt;/em&gt; and &lt;em&gt;string&lt;/em&gt;), the author focuses on two specific containers : vector and string. There are some specificities on these two containers that can improve the efficiency of the program.&lt;/p&gt;
&lt;p&gt;The third chapter (Associative Containers) is about the associative containers of the STL : set, map, multimap and multiset. It also contains some important informations about which methods to use for each usage in order to preserve the efficiency of each container. It will also explain you the very important difference between equality and equivalence.&lt;/p&gt;
&lt;p&gt;The next one (Iterators) explains which iterators to use and how to convert iterators of one type to another.&lt;/p&gt;
&lt;p&gt;The chapter five (Algorithms) describes the most important algorithms of the STL. There are tons of algorithms in the STL and using them can save you from writing a lot of boilerplate code. For example, you will learn the different sorting algorithms and for_each. I found that this chapter was especially interesting.&lt;/p&gt;
&lt;p&gt;The sixth chapter (Functors) explains you how to create functors and predicates for using with STL classes. It also treats of the special functions to convert functions to functors.&lt;/p&gt;
&lt;p&gt;The last chapter (Programming with the STL) gives you advices on how to use the STL to make easier the programming of concrete programs. It will teach you what functions to use, what headers to include and how to decipher STL-related errors.&lt;/p&gt;
&lt;p&gt;I found that this book was really good, as good as the first one. The advices are very useful and easy to understand. Using this advices enabled me to improve my code and the efficiency of it. I will recommend this book to every C++ developers using the STL.&lt;/p&gt;&lt;/div&gt;</description><category>Books</category><category>C++</category><category>C++</category><category>templates</category><guid>http://wichtounet.github.io/posts/2011/10/effective-stl-book-review.html</guid><pubDate>Mon, 31 Oct 2011 08:39:16 GMT</pubDate></item></channel></rss>