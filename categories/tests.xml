<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Blog blog("Baptiste Wicht"); (Posts about Tests)</title><link>http://baptiste-wicht.com/</link><description></description><atom:link rel="self" type="application/rss+xml" href="http://baptiste-wicht.com/categories/tests.xml"></atom:link><language>en</language><lastBuildDate>Sun, 04 Jun 2017 20:17:46 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Blazing fast unit test compilation with doctest 1.1</title><link>http://baptiste-wicht.com/posts/2016/09/blazing-fast-unit-test-compilation-with-doctest-11.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;You may remember &lt;a class="reference external" href="http://baptiste-wicht.com/posts/2016/06/reduce-compilation-time-by-another-16-with-catch.html"&gt;my quest for faster compilation times&lt;/a&gt;. I had made several changes to the Catch test framework macros in order to save some compilation at the expense of my test code looking a bit less nice:&lt;/p&gt;
&lt;pre class="code cpp"&gt;&lt;a name="rest_code_9399a9d3683d452a97b6626a15a07b67-1"&gt;&lt;/a&gt;&lt;span class="n"&gt;REQUIRE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Before&lt;/span&gt;
&lt;a name="rest_code_9399a9d3683d452a97b6626a15a07b67-2"&gt;&lt;/a&gt;&lt;span class="n"&gt;REQUIRE_EQUALS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//After&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The first line is a little bit better, but using several optimizations, I was
able to dramatically change the compilation time of the test cases of ETL. In
the end, I don't think that the difference between the two lines justifies the
high overhead in compilation times.&lt;/p&gt;
&lt;div class="section" id="doctest"&gt;
&lt;h2&gt;doctest&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/onqtam/doctest"&gt;doctest&lt;/a&gt; is a framework quite similar to
Catch but that claims to be much lighter. I tested doctest 1.0 early on, but at
this point it was actually slower than Catch and especially slower than my
versions of the macro.&lt;/p&gt;
&lt;p&gt;Today, doctest 1.1 was released with promises of being even lighter than before
and providing several new ways of speeding up compilation. If you want the
results directly, you can take a look at the next section.&lt;/p&gt;
&lt;p&gt;First of all, this new version improved the basic macros to make expression
decomposition faster. When you use the standard REQUIRE macro, the expression is
composed by using several template techniques and operator overloading. This is
really slow to compile. By removing the need for this decomposition, the fast
Catch macros are much faster to compile.&lt;/p&gt;
&lt;p&gt;Moreover, doctest 1.1 also introduces CHECK_EQ that does not any expression
decomposition. This is close to what I did in my macros expect that it is
directly integrated into the framework and preserves all its features. It is
also possible to bypass the expression checking code by using FAST_CHECK_EQ
macro. In that case, the exceptions are not captured. Finally, a new
configuration option is introduced (DOCTEST_CONFIG_SUPER_FAST_ASSERTS) that
removes some features related to automatic debugger breaks. Since I don't use
the debugger features and I don't need to capture exception everywhere (it's
sufficient for me that the test fails completely if an exception is thrown), I'm
more than eager to use these new features.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="results"&gt;
&lt;h2&gt;Results&lt;/h2&gt;
&lt;p&gt;For evaluation, I have compiled the complete test suite of ETL, with 1 thread,
using gcc 4.9.3 with various different options, starting from Catch to doctest
1.1 with all compilation time features. Here are the results, in seconds:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="29%"&gt;
&lt;col width="12%"&gt;
&lt;col width="14%"&gt;
&lt;col width="22%"&gt;
&lt;col width="23%"&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Version&lt;/th&gt;
&lt;th class="head"&gt;Time&lt;/th&gt;
&lt;th class="head"&gt;VS Catch&lt;/th&gt;
&lt;th class="head"&gt;VS Fast Catch&lt;/th&gt;
&lt;th class="head"&gt;VS doctest 1.0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Catch&lt;/td&gt;
&lt;td&gt;724.22&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Fast Catch&lt;/td&gt;
&lt;td&gt;464.52&lt;/td&gt;
&lt;td&gt;-36%&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;doctest 1.0&lt;/td&gt;
&lt;td&gt;871.54&lt;/td&gt;
&lt;td&gt;+20%&lt;/td&gt;
&lt;td&gt;+87%&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;doctest 1.1&lt;/td&gt;
&lt;td&gt;614.67&lt;/td&gt;
&lt;td&gt;-16%&lt;/td&gt;
&lt;td&gt;+32%&lt;/td&gt;
&lt;td&gt;-30%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;REQUIRE_EQ&lt;/td&gt;
&lt;td&gt;493.97&lt;/td&gt;
&lt;td&gt;-32%&lt;/td&gt;
&lt;td&gt;+6%&lt;/td&gt;
&lt;td&gt;-43%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FAST_REQUIRE_EQ&lt;/td&gt;
&lt;td&gt;439.09&lt;/td&gt;
&lt;td&gt;-39%&lt;/td&gt;
&lt;td&gt;-6%&lt;/td&gt;
&lt;td&gt;-50%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SUPER_FAST_ASSERTS&lt;/td&gt;
&lt;td&gt;411.11&lt;/td&gt;
&lt;td&gt;-43%&lt;/td&gt;
&lt;td&gt;-12%&lt;/td&gt;
&lt;td&gt;-53%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As you can see, doctest 1.1 is much faster to compile than doctest 1.0! This is
really great news. Moreover, it is already 16% faster than Catch. When all the
features are used, doctest is 12% faster than my stripped down versions of Catch
macros (and 43% faster than Catch standard macros). This is really cool! It
means that I don't have to do any change in the code (no need to strip macros
myself) and I can gain a lot of compilation time compared to the bare Catch
framework.&lt;/p&gt;
&lt;p&gt;I really think the author of doctest did a great job with the new version.
Although this was not of as much interest for me, there are also a lot of
other changes in the new version. You can consult the
&lt;a class="reference external" href="https://github.com/onqtam/doctest/blob/master/CHANGELOG.md"&gt;changelog&lt;/a&gt; if you want more information.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Overall, doctest 1.1 is much faster to compile than doctest 1.0. Moreover, it
offers very fast macros for test assertions that are much faster to compile
than Catch versions and even faster than the versions I created myself to reduce
compilation time. I really thing this is a great advance for doctest. When
compiling with all the optimizations, doctest 1.1 saves me 50 seconds in
compilation time compared to the fast version of Catch macro and more than
5 minutes compared to the standard version of Catch macros.&lt;/p&gt;
&lt;p&gt;I'll probably start using doctest on my development machine. For now, I'll keep
Catch as well since I need it to generate the unit test reports in XML format
for Sonarqube. Once this feature appears in doctest, I'll probably drop Catch
from ETL and DLL&lt;/p&gt;
&lt;p&gt;If you need blazing fast compilation times for your unit tests, doctest 1.1 is
probably the way to go.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>C++</category><category>Catch</category><category>Compilers</category><category>doctest</category><category>etl</category><category>gcc</category><category>Performances</category><category>Tests</category><category>time</category><guid>http://baptiste-wicht.com/posts/2016/09/blazing-fast-unit-test-compilation-with-doctest-11.html</guid><pubDate>Wed, 21 Sep 2016 19:45:13 GMT</pubDate></item><item><title>Reduce Catch tests compilation time by another 16%</title><link>http://baptiste-wicht.com/posts/2016/06/reduce-compilation-time-by-another-16-with-catch.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;No, it's not the same post as two days! I've been able to reduce the compilation
time of my test cases by another 16%!&lt;/p&gt;
&lt;p&gt;Two days ago, I posted an article about how &lt;a class="reference external" href="http://baptiste-wicht.com/posts/2016/05/speedup-compilation-by-13-by-simplifying-unit-test-with-catch.html"&gt;I reduced the compilation time of my tests by 13%&lt;/a&gt;, by bypassing the expression deduction from Catch. I came up with the macro &lt;code class="cpp"&gt;&lt;span class="n"&gt;REQUIRE_EQUALS&lt;/span&gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code cpp"&gt;&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-2"&gt;&lt;/a&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;evaluate_result&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ResultBuilder&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-3"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setResultType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLhs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-5"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setRhs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-6"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setOp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"=="&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-7"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endExpression&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-8"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-9"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-10"&gt;&lt;/a&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-11"&gt;&lt;/a&gt;&lt;span class="cp"&gt;#define REQUIRE_EQUALS(lhs, rhs) \&lt;/span&gt;
&lt;a name="rest_code_85d1c9a457f5488ab2393ecfaee9227d-12"&gt;&lt;/a&gt;&lt;span class="cp"&gt;    evaluate_result(Catch::ResultBuilder( "REQUIRE", CATCH_INTERNAL_LINEINFO, #lhs " == " #rhs, Catch::ResultDisposition::Normal ), lhs, rhs);&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;This has the advantage that the left and right hand sides are directly set, not
deduced with templates and operator overloading. This still has exactly the same
features has the original macro, but it is a bit less nice in the test code.
I was quite happy with that optimization, but it turned out, I was not
aggressive enough in my optimizations.&lt;/p&gt;
&lt;p&gt;Even though it seems simple, the macro is still bloated. There are two
constructors calls: &lt;code class="cpp"&gt;&lt;span class="n"&gt;ResultBuilder&lt;/span&gt;&lt;/code&gt; and &lt;code class="cpp"&gt;&lt;span class="n"&gt;SourceLineInfo&lt;/span&gt;&lt;/code&gt; (hidden behind
&lt;code class="cpp"&gt;&lt;span class="n"&gt;CATCH_INTERNAL_LINEINFO&lt;/span&gt;&lt;/code&gt;). That means that if you test case has 100
assertions, 200 constructor calls will need to be processed by the compiler.
Considering that I have some test files with around 400 assertions, this is
a lot of overhead for nothing. Moreover, two parameters have always the same
value, no need to repeat them every time.&lt;/p&gt;
&lt;p&gt;Simplifying the macro to the minimum led me to this:&lt;/p&gt;
&lt;pre class="code cpp"&gt;&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-2"&gt;&lt;/a&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;evaluate_result&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-3"&gt;&lt;/a&gt;    &lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ResultBuilder&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"REQUIRE"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ResultDisposition&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Flags&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Normal&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setResultType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-5"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLhs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-6"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setRhs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-7"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setOp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"=="&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-8"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endExpression&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-9"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-10"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-11"&gt;&lt;/a&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-12"&gt;&lt;/a&gt;&lt;span class="cp"&gt;#define REQUIRE_EQUALS(lhs, rhs) \&lt;/span&gt;
&lt;a name="rest_code_7a8e153d687c46a58eab2758e22885cb-13"&gt;&lt;/a&gt;&lt;span class="cp"&gt;    evaluate_result(__FILE__, __LINE__, #lhs " == " #rhs, lhs, rhs);&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The macro is now a simple function call. Even though the function is a template
function, it will only be compiled for a few types (&lt;code class="cpp"&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;/code&gt; and
&lt;code class="cpp"&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;/code&gt; in my case), whereas the code of the macro would be unconditionally
compiled for each invocation.&lt;/p&gt;
&lt;p&gt;With this new macro and function, the compilation time went down from 664
seconds to 554 seconds! This is &lt;strong&gt;more than 16% reduction in compilation
time&lt;/strong&gt;. When comparing against the original compilation time (without both
optimizations) of 764 seconds, this is a 27% reduction! And there are absolutely
no difference in features.&lt;/p&gt;
&lt;p&gt;This is a really great result, in my opinion. I don't think this can be cut down
more. However, there is still some room for optimization regarding the includes
that Catch need. Indeed, it is very bloated as well. A new test framework,
&lt;a class="reference external" href="https://github.com/onqtam/doctest"&gt;doctest&lt;/a&gt; follows the same philosophy, but
has much smaller include overhead. Once all the necessary features are in
doctest, I may consider adapting my macros for it and using it in place of Catch
is there is some substantial reduction in compilation time.&lt;/p&gt;
&lt;p&gt;If you want to take a look at the code, you can find the adapted code on &lt;a class="reference external" href="https://github.com/wichtounet/etl/blob/master/test/include/fast_catch.hpp"&gt;Github&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>Catch</category><category>Tests</category><guid>http://baptiste-wicht.com/posts/2016/06/reduce-compilation-time-by-another-16-with-catch.html</guid><pubDate>Wed, 01 Jun 2016 05:28:36 GMT</pubDate></item><item><title>Speed up compilation by 13% by simplifying Catch unit tests</title><link>http://baptiste-wicht.com/posts/2016/05/speedup-compilation-by-13-by-simplifying-unit-test-with-catch.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;In the previous two days, I've working on improving compilation time of my
project Expression Templates Library (ETL). I have been able to reduce the
compilation time of the complete test suite from 794 seconds to 764 seconds
(using only one thread). Trying to get further, I started checking what was
taking the most time in a test case when I saw that the REQUIRE calls of &lt;strong&gt;the
test library were taking a large portion of the compilation time!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I have been &lt;a class="reference external" href="http://baptiste-wicht.com/posts/2014/07/catch-powerful-yet-simple-cpp-test-framework.html"&gt;using Catch as my test framework&lt;/a&gt;
for more than two years and it's really been great overall. It is a great tool,
header-only, fully-featured, XML reporting for Sonar, ... It really has
everything I need from a test framework.&lt;/p&gt;
&lt;p&gt;Contrary to some popular test frameworks that provides ASSERT_EQUALS,
ASSERT_GREATER and all fashion of assert macros, Catch only provides one
version: REQUIRE. For instance:&lt;/p&gt;
&lt;pre class="code cpp"&gt;&lt;a name="rest_code_374432f286cc4b2fad08abc1465dd7d5-1"&gt;&lt;/a&gt;&lt;span class="n"&gt;REQUIRE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_374432f286cc4b2fad08abc1465dd7d5-2"&gt;&lt;/a&gt;&lt;span class="n"&gt;REQUIRE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;5.5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_374432f286cc4b2fad08abc1465dd7d5-3"&gt;&lt;/a&gt;&lt;span class="n"&gt;REQUIRE&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mf"&gt;22.01f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The left and right part are detected with some smart template and operator
overloading techniques and this makes for very nice test output in case of
errors, for instance:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_3bfa083996c34cd19ac0d930c2325a3f-1"&gt;&lt;/a&gt;test/src/dyn_matrix.cpp:16: FAILED:
&lt;a name="rest_code_3bfa083996c34cd19ac0d930c2325a3f-2"&gt;&lt;/a&gt;  REQUIRE( test_matrix.rows() == 2UL )
&lt;a name="rest_code_3bfa083996c34cd19ac0d930c2325a3f-3"&gt;&lt;/a&gt;with expansion:
&lt;a name="rest_code_3bfa083996c34cd19ac0d930c2325a3f-4"&gt;&lt;/a&gt;  3 == 2
&lt;/pre&gt;&lt;p&gt;I think this is pretty nice and the tests are really clear. However, &lt;em&gt;it comes
with a cost&lt;/em&gt; and I underestimated this at first.&lt;/p&gt;
&lt;p&gt;To overcome this, I create two new macros (and few other variations)
REQUIRE_EQUALS and REQUIRE_DIRECT that simply bypass Catch deduction of the
expression:&lt;/p&gt;
&lt;pre class="code cpp"&gt;&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-1"&gt;&lt;/a&gt;&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;evaluate_result_direct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ResultBuilder&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-2"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setResultType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-3"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLhs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s"&gt;"true"&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"false"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setOp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-5"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endExpression&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-6"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-7"&gt;&lt;/a&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-8"&gt;&lt;/a&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-9"&gt;&lt;/a&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;evaluate_result&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ResultBuilder&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-10"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setResultType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-11"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLhs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-12"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setRhs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Catch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-13"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setOp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"=="&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-14"&gt;&lt;/a&gt;    &lt;span class="n"&gt;__result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endExpression&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-15"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-16"&gt;&lt;/a&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-17"&gt;&lt;/a&gt;&lt;span class="cp"&gt;#define REQUIRE_DIRECT(value) \&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-18"&gt;&lt;/a&gt;&lt;span class="cp"&gt;    evaluate_result_direct(Catch::ResultBuilder( "REQUIRE", CATCH_INTERNAL_LINEINFO, #value, Catch::ResultDisposition::Normal ), value);&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-19"&gt;&lt;/a&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-20"&gt;&lt;/a&gt;&lt;span class="cp"&gt;#define REQUIRE_EQUALS(lhs, rhs) \&lt;/span&gt;
&lt;a name="rest_code_62241f0c19d348efb6d84fa88a35b736-21"&gt;&lt;/a&gt;&lt;span class="cp"&gt;    evaluate_result(Catch::ResultBuilder( "REQUIRE", CATCH_INTERNAL_LINEINFO, #lhs " == " #rhs, Catch::ResultDisposition::Normal ), lhs, rhs);&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;There is really nothing too special about it, I simply followed the macros and
functions in Catch source code until I found out what to bypass.&lt;/p&gt;
&lt;p&gt;And now, we use them directly:&lt;/p&gt;
&lt;pre class="code cpp"&gt;&lt;a name="rest_code_7b45640202ed4713a1a87d036e6f2c1f-1"&gt;&lt;/a&gt;&lt;span class="n"&gt;REQUIRE_DIRECT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;am_i_true&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;a name="rest_code_7b45640202ed4713a1a87d036e6f2c1f-2"&gt;&lt;/a&gt;&lt;span class="n"&gt;REQUIRE_EQUALS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;This is a bit less nice and it requires to know a few more macros, I admit, but
it turns out to be much faster (and who really cares about the beauty of test
code anyway...). Indeed, the total compilation time of the tests went from 764
seconds to 664 seconds!  This is &lt;strong&gt;a 13% reduction of the compilation time&lt;/strong&gt;!
I really am impressed of the overhead of this technique. I cannot justify this
slowdown just for a bit nicer test code. Finally, the output in case of error
remains exactly the same as before.&lt;/p&gt;
&lt;p&gt;This proves that sometimes the bottlenecks are not where we expect them :)&lt;/p&gt;
&lt;p&gt;If you are interested, you can find the adapted code on &lt;a class="reference external" href="https://github.com/wichtounet/etl/blob/master/test/include/fast_catch.hpp"&gt;Github&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>Tests</category><guid>http://baptiste-wicht.com/posts/2016/05/speedup-compilation-by-13-by-simplifying-unit-test-with-catch.html</guid><pubDate>Wed, 25 May 2016 10:35:16 GMT</pubDate></item><item><title>Catch: A powerful yet simple C++ test framework</title><link>http://baptiste-wicht.com/posts/2014/07/catch-powerful-yet-simple-cpp-test-framework.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Recently, I came accross a new test framework for C++ program: Catch.&lt;/p&gt;
&lt;p&gt;Until I found Catch, I was using Boost Test Framework. It is working quite well,
but the problem is that you need to build Boost and link to the Boost Test
Framework, which is not highly convenient. I wanter something lighter and easier
to integrate.&lt;/p&gt;
&lt;p&gt;Catch is header only, you only have to include one header for each test file.
Moreover, it is very easy to combine several source files without linking
problems.&lt;/p&gt;
&lt;div class="section" id="usage"&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;The usage is really simple. Here is a basic example:&lt;/p&gt;
&lt;pre class="code cpp"&gt;&lt;a name="rest_code_dd4bac5ffe5c43518aabed71ccbbd089-1"&gt;&lt;/a&gt;&lt;span class="cp"&gt;#define CATCH_CONFIG_MAIN&lt;/span&gt;
&lt;a name="rest_code_dd4bac5ffe5c43518aabed71ccbbd089-2"&gt;&lt;/a&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;"catch.hpp"&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;a name="rest_code_dd4bac5ffe5c43518aabed71ccbbd089-3"&gt;&lt;/a&gt;
&lt;a name="rest_code_dd4bac5ffe5c43518aabed71ccbbd089-4"&gt;&lt;/a&gt;&lt;span class="n"&gt;TEST_CASE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;"stupid/1=2"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Prove that one equals 2"&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
&lt;a name="rest_code_dd4bac5ffe5c43518aabed71ccbbd089-5"&gt;&lt;/a&gt;    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;a name="rest_code_dd4bac5ffe5c43518aabed71ccbbd089-6"&gt;&lt;/a&gt;    &lt;span class="n"&gt;REQUIRE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;a name="rest_code_dd4bac5ffe5c43518aabed71ccbbd089-7"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The define is made to ensure that Catch will generate a main for you. This
should only defined in one of your tests files if you have several. You define a
new test case using the &lt;code&gt;TEST_CASE&lt;/code&gt; macro. There are two parameters, the
first one is the name of the test case, you can use any name, you don't have to
use a valid C++ name. The second parameter is a longer description of the test
case.&lt;/p&gt;
&lt;p&gt;You then use &lt;code&gt;REQUIRE&lt;/code&gt; to verify a condition. You can also use
&lt;code&gt;CHECK&lt;/code&gt; to verify a condition, the difference being that it does not stop
if the condition is not true. &lt;code&gt;CHECK&lt;/code&gt; is a good tool to put together some
conditions that are related. There also exists &lt;code&gt;REQUIRE_FALSE&lt;/code&gt; and
&lt;code&gt;CHECK_FALSE&lt;/code&gt; versions.&lt;/p&gt;
&lt;p&gt;As you can see, there are no &lt;code&gt;REQUIRE_EQUALS&lt;/code&gt; or things like that, you can
use any comparison operator you want in the &lt;code&gt;REQUIRE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This produces an executable that will, by default, run every test contained in
the executable. You can also configure the output report to be XML or JUnit if
you want or run a subset of your tests. Take a look at the command line usage by
running the executable with the -h option if you want more information.&lt;/p&gt;
&lt;p&gt;Here is the result of the previous test:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
catch_test_1 is a Catch v1.0 b52 host application.
Run with -? for options

-------------------------------------------------------------------------------
stupid/1=2
-------------------------------------------------------------------------------
src/catch/test1.cpp:4
...............................................................................

src/catch/test1.cpp:6: FAILED:
  REQUIRE( one == 2 )
with expansion:
  1 == 2

===============================================================================
test cases: 1 | 1 failed
assertions: 1 | 1 failed
&lt;/pre&gt;
&lt;p&gt;For each failed condition, the source location is printed as well as some
information on the test that failed. What is also interesting is the "with
expansion" information that shows LHS and RHS of the comparison operator.&lt;/p&gt;
&lt;p&gt;You can also check for exceptions with several macros:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;code&gt;REQUIRE_THROWS(expression)&lt;/code&gt; and &lt;code&gt;CHECK_THROWS(expression)&lt;/code&gt;
verify that an exception is thrown when the given expresssion is evaluated.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REQUIRE_THROWS_AS(expression, exception_type)&lt;/code&gt; and
&lt;code&gt;CHECK_THROWS_AS(expression, exception_type)&lt;/code&gt; verify the the given
exception is thrown.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REQUIRE_NOTHROW(expression)&lt;/code&gt; and &lt;code&gt;CHECK_NOTHROW(expression)&lt;/code&gt;
verify that no exception is thrown.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I have only covered the most basic features, there is more that you can do with
Catch: fixtures, logging and BDD-style test cases for instance. For more
information you can read the &lt;a class="reference external" href="https://github.com/philsquared/Catch/blob/master/docs/reference-index.md"&gt;reference documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I'm really satisfied with this framework. It also can be used for Objective-C if
you are interested. You can download Catch &lt;a class="reference external" href="https://github.com/philsquared/Catch"&gt;on Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you want more examples, you can take a look at the &lt;a class="reference external" href="https://github.com/wichtounet/etl/tree/master/test"&gt;ETL&lt;/a&gt; tests that are all
made with Catch.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>C++</category><category>Tests</category><guid>http://baptiste-wicht.com/posts/2014/07/catch-powerful-yet-simple-cpp-test-framework.html</guid><pubDate>Mon, 28 Jul 2014 11:21:49 GMT</pubDate></item><item><title>CMake Testing - Rerun the last failed tests with CTest</title><link>http://baptiste-wicht.com/posts/2012/12/cmake-rerun-last-failed-tests-ctest.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Some time ago, we saw &lt;a href="http://www.baptiste-wicht.com/2012/10/run-boost-test-parallel-cmake/" title="Run your Boost Tests in parallel with CMake"&gt;how to use CMake to run Boost Tests in paralel&lt;/a&gt;, now it is time for another tip. &lt;/p&gt;
&lt;p&gt;A feature that I think is lacking in CMake/CTest is a way to launch only the last failed tests. As it is not possible to do that directly, I posted &lt;a href="http://stackoverflow.com/q/13547175/802362" title="How to rerun the failed tests with ctest?"&gt;the question on StackOverflow&lt;/a&gt; and got a great answer from &lt;a href="http://stackoverflow.com/users/424459/fraser" title="Fraser"&gt;Fraser&lt;/a&gt;. I wanted to share its answer. &lt;/p&gt;
&lt;p&gt;CTest has -I option to select a list of tests to run. The idea here is to convert the log of CTest in format readable by CTest. What I think is great in its answer is that the solution is a CMake script: &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;FailedFileName&lt;/span&gt; &lt;span class="s"&gt;FailedTests.log&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;EXISTS&lt;/span&gt; &lt;span class="s2"&gt;"Testing/Temporary/LastTestsFailed.log"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;STRINGS&lt;/span&gt; &lt;span class="s2"&gt;"Testing/Temporary/LastTestsFailed.log"&lt;/span&gt; &lt;span class="s"&gt;FailedTests&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;REGEX&lt;/span&gt; &lt;span class="s"&gt;REPLACE&lt;/span&gt; &lt;span class="s2"&gt;"([0-9]+):[^;]*"&lt;/span&gt; &lt;span class="s2"&gt;"\\1"&lt;/span&gt; &lt;span class="s"&gt;FailedTests&lt;/span&gt; &lt;span class="s2"&gt;"${FailedTests}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;SORT&lt;/span&gt; &lt;span class="s"&gt;FailedTests&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;GET&lt;/span&gt; &lt;span class="s"&gt;FailedTests&lt;/span&gt; &lt;span class="s"&gt;0&lt;/span&gt; &lt;span class="s"&gt;FirstTest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;FailedTests&lt;/span&gt; &lt;span class="s2"&gt;"${FirstTest};${FirstTest};;${FailedTests};"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;REPLACE&lt;/span&gt; &lt;span class="s2"&gt;";"&lt;/span&gt; &lt;span class="s2"&gt;","&lt;/span&gt; &lt;span class="s"&gt;FailedTests&lt;/span&gt; &lt;span class="s2"&gt;"${FailedTests}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;WRITE&lt;/span&gt; &lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;FailedFileName&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;FailedTests&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;else&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;WRITE&lt;/span&gt; &lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;FailedFileName&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;endif&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This test just transforms one file into another. &lt;/p&gt;
&lt;p&gt;You can then run the last failing tests using: &lt;/p&gt;
&lt;pre&gt;cmake -P &lt;the script&gt;
ctest -I FailedTests.log&lt;/the&gt;&lt;/pre&gt;

&lt;p&gt;Very easy, isn't it ? &lt;/p&gt;
&lt;p&gt;There is a limitation to this solution. It won't work when CTest is running in dashboard mode, but it wouldn't take too long to adapt it for that. &lt;/p&gt;
&lt;p&gt;Hope you found that tip useful.&lt;/p&gt;&lt;/div&gt;</description><category>C++</category><category>cmake</category><category>Tests</category><category>Tools</category><guid>http://baptiste-wicht.com/posts/2012/12/cmake-rerun-last-failed-tests-ctest.html</guid><pubDate>Thu, 06 Dec 2012 07:47:12 GMT</pubDate></item><item><title>Run your Boost Tests in parallel with CMake</title><link>http://baptiste-wicht.com/posts/2012/10/run-boost-test-parallel-cmake.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;I was looking for a Test Library to run eddic tests in parallel to replace Boost Test Library. I posted my question on StackOverflow and an awesome solution has been posted. With CMake and a little CMake additional file, it is possible to run the tests written with Boost Test Library in parallel without changing anything in the tests code !&lt;/p&gt;
&lt;p&gt;CTest is the test runner that is shipped with CMake. This runner can run tests in parallel using the -j X option (X is the numbers of threads). However, it can only run the tests that are declared in the CMakeLists.txt file. In my case, this means only one (the executable with Boost Test Library). If you have T tests, a solution would be create T executable files. Then, they can be run in parallel by ctest. However, this is not very practical. The solution proposed in this article is better. &lt;/p&gt;
&lt;h3&gt;Integrate Boost Test Library in CMake&lt;/h3&gt;

&lt;p&gt;Ryan Pavlik provides a series of CMake modules in its Github repository. One of this module is named BoostTestTargets. It automatically generates the CTest commands to run all the tests that you have. The small drawback is that you to list all the tests. &lt;/p&gt;
&lt;p&gt;To start, you have to download these files: &lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/raw/master/BoostTestTargets.cmake" title="BoostTestTargets.cmake"&gt;BoostTestTargets.cmake&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/raw/master/GetForceIncludeDefinitions.cmake" title="GetForceIncludeDefinitions.cmake"&gt;GetForceIncludeDefinitions.cmake&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/raw/master/CopyResourcesToBuildTree.cmake" title="CopyResourcesToBuildTree.cmake"&gt;CopyResourcesToBuildTree.cmake&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/blob/master/BoostTestTargetsStatic.h" title="BoostTestTargetsStatic.h"&gt;BoostTestTargetsStatic.h&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/blob/master/BoostTestTargetsDynamic.h" title="BoostTestTargetsDynamic.h"&gt;BoostTestTargetsDynamic.h&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://github.com/rpavlik/cmake-modules/blob/master/BoostTestTargetsIncluded.h" title="BoostTestTargetsIncluded.h"&gt;BoostTestTargetsIncluded.h&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These files must be placed next to your CMakeLists.txt file. Then, you have to modify your CMakeLists.txt file to enable testing and enable the new module. For example, if you have two test suites and five tests in each:  &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;INCLUDE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;CTest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;ENABLE_TESTING&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;GLOB_RECURSE&lt;/span&gt;
    &lt;span class="s"&gt;test_files&lt;/span&gt;
    &lt;span class="s"&gt;test/*&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;BoostTestTargets.cmake&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;add_boost_test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;eddic_boost_test&lt;/span&gt;
    &lt;span class="s"&gt;SOURCES&lt;/span&gt; &lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;test_files&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="s"&gt;TESTS&lt;/span&gt; 
    &lt;span class="s"&gt;TestSuiteA/test_1&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteA/test_2&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteA/test_3&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteA/test_4&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteA/test_5&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteB/test_1&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteB/test_2&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteB/test_3&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteB/test_4&lt;/span&gt;
    &lt;span class="s"&gt;TestSuiteB/test_5&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;All the test files are searched in the test directory and used in the SOURCES variable. Then all the tests are declared. &lt;/p&gt;
&lt;p&gt;The main test file has to include a specific header file:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define BOOST_TEST_MODULE eddic_test_suite&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;BoostTestTargetConfig.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This file will be automatically detected by BoostTestTargets and configured correctly. And that's it !&lt;/p&gt;
&lt;p&gt;You can run CMake again in your build directory to use the new test system: &lt;/p&gt;
&lt;p&gt;[bash]cmake .[/bash]&lt;/p&gt;
&lt;p&gt;If the configuration has been successful, you will see a message indicating that. For example, I see that: &lt;/p&gt;
&lt;pre&gt;-- Test 'eddic_boost_test' uses the CMake-configurable form of the boost test framework - congrats! (Including File: /home/wichtounet/dev/eddi/eddic/test/IntegrationTests.cpp)
-- Configuring done
-- Generating done
-- Build files have been written to: /tmp/ramdrive/dev/eddic&lt;/pre&gt;

&lt;h3&gt;Run tests in parallel&lt;/h3&gt;

&lt;p&gt;You can then run your tests in parallel with ctest. For instance, with 9 threads: &lt;/p&gt;
&lt;pre&gt;ctest -j 8&lt;/pre&gt;

&lt;p&gt;In my case, my tests are completed 6x faster ! This is very valuable when you often run your tests. &lt;/p&gt;
&lt;p&gt;For more information on how to integrate your Boost Test Library tests with CMake, you can consult the &lt;a href="https://github.com/rpavlik/cmake-modules/" title="cmake-modules Github repository"&gt;The cmake-modules repository&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Boost</category><category>C++</category><category>cmake</category><category>Concurrency</category><category>EDDI</category><category>Performances</category><category>Tests</category><guid>http://baptiste-wicht.com/posts/2012/10/run-boost-test-parallel-cmake.html</guid><pubDate>Mon, 15 Oct 2012 06:57:43 GMT</pubDate></item><item><title>Links of the Week</title><link>http://baptiste-wicht.com/posts/2010/04/links-of-the-week-2.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;p&gt;Here are some interesting links of this week :&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://www.codinghorror.com/blog/2010/04/three-monitors-for-every-user.html" target="_blank"&gt;Three Monitors for Every User&lt;/a&gt; : Jeff Atwood explain how to works with three monitors on the same computers and what that give to the user.&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/java/library/j-ce/index.html" target="_blank"&gt;Tip: When you can't throw an exception&lt;/a&gt; : Elliotte Rusty Harold explore solutions on how to works with exceptions in public APIs&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://blogs.sun.com/tor/entry/leak_unit_tests" target="_blank"&gt;How to Write a Memory Leak Unit Test&lt;/a&gt; : Tor Norbye explain how to make unit test to verify for memory leak&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://agile.dzone.com/news/8-tips-performance-metrics"&gt;8 Tips for Performance Metrics&lt;/a&gt; by Jurgen Appelo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope you'll find this links interesting.&lt;/p&gt;&lt;/div&gt;</description><category>Hardware</category><category>Java</category><category>Links</category><category>Performances</category><category>Tests</category><guid>http://baptiste-wicht.com/posts/2010/04/links-of-the-week-2.html</guid><pubDate>Mon, 12 Apr 2010 04:34:18 GMT</pubDate></item><item><title>Mock objects with EasyMock</title><link>http://baptiste-wicht.com/posts/2010/03/mock-objects-easymock.html</link><dc:creator>Baptiste Wicht</dc:creator><description>&lt;div&gt;&lt;h4&gt;1. Introduction&lt;/h4&gt;

&lt;p&gt;The mock objects allows to make unit tests on objects depending on other objects. We will replace this dependencies with mock objects. With that, we can by example verify than the method xyzzy() has been called 5 times and returned 33. That can be practical in a several cases. By exampe, if the object to mock is slow or undeterministic (depending on time, or why not on the weather). This objects are really difficult to test because we can make a lot of tests but we could never find the special cases. Test cases with mock objects enable us to test this cases.&lt;/p&gt;
&lt;p class="more"&gt;&lt;a href="http://baptiste-wicht.com/posts/2010/03/mock-objects-easymock.html"&gt;Read more…&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>Java</category><category>Libraries</category><category>Tests</category><guid>http://baptiste-wicht.com/posts/2010/03/mock-objects-easymock.html</guid><pubDate>Thu, 18 Mar 2010 05:53:54 GMT</pubDate></item></channel></rss>