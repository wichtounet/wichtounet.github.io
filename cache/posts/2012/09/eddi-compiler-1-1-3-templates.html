<p>I finished the <strong>version 1.1.3 of the EDDI Compiler (eddic)</strong>.</p>
<p>The main improvement to the language is the support of templates. The syntax is more or less the same as the syntax of C++ templates, but the features are much more limited. In EDDI, you can declare class templates and function templates. Class templates can also includes member function templates.</p>
<p>Here is an example of the use of templates in EDDI:</p>
<pre class="code literal-block"><span class="k">template</span><span class="o">&lt;</span><span class="n">type</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">this</span><span class="p">(</span><span class="n">T</span> <span class="n">init</span><span class="p">){</span>
        <span class="n">print</span><span class="p">(</span><span class="s">&quot;C1|&quot;</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">get_value</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="n">type</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">print_value</span><span class="p">(</span><span class="n">U</span> <span class="n">v</span><span class="p">){</span>
        <span class="n">print</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">type</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">debug</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span>
    <span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">type</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="n">node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">){</span>
    <span class="n">debug</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="n">debug</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">get_value</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">first_node</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">node</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">second_node</span><span class="p">(</span><span class="mf">13.3</span><span class="p">);</span>

    <span class="n">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first_node</span><span class="p">);</span>
    <span class="n">test</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">second_node</span><span class="p">);</span>

    <span class="n">first_node</span><span class="p">.</span><span class="n">print_value</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
    <span class="n">second_node</span><span class="p">.</span><span class="n">print_value</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>This new feature adds generic programming capabilities to the language.</p>
<p>This version also adds other language improvements. The first one is the support of the ! operator for a bool, to test if a bool is false. This version also includes support for iterating through all the chars of a string with a foreach loop. And finally, the this pointer is now implicit to access member fields of a struct from member functions.</p>
<p>The optimization engine has been greatly improved. The pointers are much better handled and some regression due to new features have been fixed. The Constant Propagation optimization can take default values of struct and arrays into account. Finally, the functions with char parameters can now be inlined.</p>
<p>Finally, the compiler use a new logging system, that can be completely removed at compile-time for release versions.</p>
<h3>Future Work</h3>

<p>The next version of the EDDI compiler (eddic) will be the version 1.1.4. This version will add support for some basic pointer manipulation. It will also add support for dynamically allocated arrays. Finally, the version will includes several new optimization techniques regarding to loops: Loop Invariant Code Motion, Loop Strength Reduction and perhaps some basic Loop Unrolling.</p>
<h3>Download</h3>

<p>You can find the EDDI Compiler sources on the Github repository: <a title="Github repository of eddic" href="https://github.com/wichtounet/eddic">https://github.com/wichtounet/eddic</a></p>
<p>The exact version I refer to is the v1.1.3 available in the GitHub tags or directly as the release branch.</p>