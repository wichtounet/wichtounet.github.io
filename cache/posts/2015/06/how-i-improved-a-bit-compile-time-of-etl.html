<p>Recently I read several articles about C++ and compile time and I wondered if I could improve the compile time of my Expression Template Library (ETL) project. ETL is a header-only and template-heavy library. I'm not going to the change the design completely or to use type erasure techniques to reduce the compile time, ETL is all about performance.</p>
<p>As a disclaimer, don't expect fancy results from this post, I haven't been able to reduce compile time a lot, but I still wanted to share my experience.</p>
<p>I've used g++-4.9.2 to perform these tests.</p>
<p>I'm compiling the complete test suite (around 6900 source lines of codes in 36 files) in release mode. Each test file includes the ETL (around 10K SLOC). Each test is run with 8 threads (make -j8). For each result, I have run a complete build 5 times and taken the best result as the final result. Everything is run on a SSD and I have more than enough RAM to handle all the compilation in parallel.</p>
<p>The reference build time was 87.5 seconds.</p>
<div class="section" id="compile-and-generate-dependency-files-at-the-same-time">
<h1>Compile and generate dependency files at the same time</h1>
<p>To help write my makefiles, I'm using a set of functions that I have written. This includes automatic dependency generation using -MM -MT options of the compiler. Until now, I had two targets, one to compile the cpp file into the object file and another one to generate the dependency file. I recently saw that compilers were able to do both at the same time! Clang, G++ and the Intel compiler all have a -MD -MF options that lets you generate the dependency file at the same time you compile your file, saving you at least one read of the file.</p>
<p>My compilation rule in my makefile has now become:</p>
<pre class="code makefile literal-block">
<span class="nf">release/$(1)/%.cpp.o</span><span class="o">:</span> <span class="m">$(1)/%.cpp</span>
    &#64; mkdir -p release/<span class="k">$(</span>1<span class="k">)</span>/
    <span class="k">$(</span>CXX<span class="k">)</span> <span class="k">$(</span>CXX_FLAGS<span class="k">)</span> <span class="k">$(</span>RELEASE_FLAGS<span class="k">)</span> <span class="k">$(</span>2<span class="k">)</span> -MD -MF release/<span class="k">$(</span>1<span class="k">)</span>/<span class="nv">$$</span>*.cpp.d -o release/<span class="k">$(</span>1<span class="k">)</span>/<span class="nv">$$</span>*.cpp.o -c <span class="k">$(</span>1<span class="k">)</span>/<span class="nv">$$</span>*.cpp
    &#64; sed -i -e <span class="s1">'s&#64;^\(.*\)\.o:&#64;\1.d \1.o:&#64;'</span> release/<span class="k">$(</span>1<span class="k">)</span>/<span class="nv">$$</span>*.cpp.d
</pre>
<p>This reduced the compilation time to 86.8 seconds. Not that much reduction, but it still is quite nice to know that. I would have expected this to reduce more the compile time.</p>
<div class="section" id="use-pragma-once">
<h2>Use #pragma once</h2>
<p>Normally, I'm not a fan of #pragma since it is not standard, but for now ETL only supports three compilers and only very recent of them, so I have the guarantee that #pragma once is available, so what the hell!</p>
<p>I've replaced all the include guards by single #pragma once directives.</p>
<p>Again, the results are not impressive, this reduced the compile time to 86.2 seconds. I would only advise to use this if you are sure of the compilers you want to support and you need the extra time.</p>
</div>
<div class="section" id="avoid-iostream">
<h2>Avoid &lt;iostream&gt;</h2>
<p>I've read that the &lt;iostream&gt; header was one of the slowest to compile of the STL. It is only one that is included several times in my headers only for stream operators and it turns out that there is a &lt;iosfwd&gt; header that forward declares a lot of things from the &lt;iostream&gt; and other I/O headers.</p>
<p>By replacing all &lt;iostream&gt; include by &lt;iosfwd&gt;, compile time has gone down to 84.1 seconds.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>By using the three techniques, I've reduced the compile time from 87.5 to 84.1 seconds. I would have honestly hoped for more improvements, but this is a already a good start.</p>
<p>As a side note, clang compile time is 45.2 seconds under the same conditions (was 46.2 seconds before the optimizations). It is really much faster :) I'm still using GCC a lot since in several cases, it does generate much better code and in average, the generated code if faster (on my benchmarks at least). I don't have the numbers for icc, but icc is definitely the slowest of the three. When I have it available (at work), I use for release build before running something. The generated executables are generally faster (I only use Intel processors) and sometimes the difference can be quite important.</p>
<p>If you have ideas to reduce further the compile time on this test case, I'd be glad to hear them and put them to the test.</p>
<p>I hope that this small experience would be helpful to some of you :)</p>
</div>
<div class="section" id="other-techniques">
<h2>Other techniques</h2>
<p>There are several other techniques that you can use to reduce compile time:</p>
<ol class="arabic simple">
<li>Precompiled Headers are supported by both Clang and GCC, altough not in a compatible. I haven't tested this in a while, but it is quite effective and a very interesting technique. The main problem with this is that is not standard and not compatible between compilers. But it probably is the most efficient techniques when you have lots of headers and lots of templates as in my case.</li>
<li>Unity builds can make full rebuild much faster. I personally don't like unity builds especially because it is only really good for full builds and you generally don't do full rebuilds that much (I know, I know, this is also the test done in this article :) ). Moreover, it also sucks at doing parallel builds.</li>
<li>Pimpl idioms and other type erasure techniques can reduce compile time a lot. If it is well done, it can be implemented without so much overhead.</li>
<li>Explicit instantiation of templates can also help, but only in the case of a user program. In the case of a library itself, you cannot do anything.</li>
<li>Reduce inclusions and use forward declarations, obviously...</li>
<li>Use tools like distcc (I very rarely use it) and ccache (I generally use it).</li>
<li>Update your compiler</li>
<li>Upgrade your computer ;)</li>
<li>...</li>
</ol>
</div>
</div>
