<p>I finally finished the version 1.2.3 of eddic. I have been quite busy finishing my master thesis in february and then taking some vacations in United States, so this version came later than I wanted. </p>
<p>The main change is about the speed of the data-flow optimizations. I refactored a lot the data-flow to make it much faster. Some test cases are up to 10 times faster :)</p>
<p>There are still some work to do for speed of optimizations, but it is much better now. Dead Code Elimination and Constant Propagation still have to be made faster, but now the main bottleneck. In the next version of eddic, the parsing performance will be improved. </p>
<p>Inlining performance has also been greatly improved. The functions are considered in topological order of the call graph. This makes it much faster and moreover the resulting code is more efficient too. </p>
<p>There are also some improvements of the language. char and bool types now takes only one byte each. Copy constructors for structures containing field of structure type are now automatically generated. The grammar has been enhanced to support postfix operations in for loops. </p>
<p>Other improvements have been made to the optimization engine. A new optimization has been implemented: Loop Unswitching. This optimization transforms a code like that: </p>
<pre class="code literal-block"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">X</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
        <span class="c1">//Something</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//Something else</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>In some code like that: </p>
<pre class="code literal-block"><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">X</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="c1">//Something</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">X</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="c1">//Something else</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>when a doesn't depend on the loop body. The body of the loops is much faster in the second version. </p>
<p>The induction variable analysis is now able to handle loops with induction variable divided in each iteration. With that new feature, the call: </p>
<pre class="code literal-block"><span class="n">print</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</pre>


<p>is reduced to</p>
<pre class="code literal-block"><span class="n">print</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="sc">&#39;2&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="sc">&#39;3&#39;</span><span class="p">);</span>
</pre>


<p>Another small optimization is that variables contributing only to themselves are now correctly identified as dead. </p>
<p>On the compiler side, the timing system has been greatly improved to contains almost all part of the compilation process. The timings for the complete compilation is available <a href="https://github.com/wichtounet/eddic/wiki/Performance" title="Performance">on the wiki</a>. </p>
<h3>Future Work</h3>

<p>The next version of the EDDI compiler (eddic) will be the version 1.2.4. </p>
<p>Performances will stil be focused for this version. The first change will be to improve the performances of the parsing. Then, I'm gonna try to improve register allocation performances by improving handling of bound registers which I believe is a bottleneck. </p>
<p>There are also several refactorings that I think of doing to the code. I will probably also implement new minor language features, but I still don't know what. </p>
<p>Moreover, I have to serve in the army the next three weeks, so there won't be any progress these weeks. </p>
<h3>Download</h3>

<p>You can find the EDDI Compiler sources on the Github repository: <a title="Github repository of eddic" href="https://github.com/wichtounet/eddic">https://github.com/wichtounet/eddic</a></p>
<p>The version is available in the <em>v1.2.3</em> tag available in the GitHub or directly in the <em>master</em> branch.</p>