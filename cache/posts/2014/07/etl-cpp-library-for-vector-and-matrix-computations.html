<p>When working on Machine Learning algorithms, I was in need of a simple library
to ease working with vectors and matrix. This is the reason why I started
developing ETL (Expression Template Library).</p>
<p>ETL is a small header only library for C++ that provides vector and matrix
classes with support for Expression Templates to perform very efficient
operations on them.</p>
<p>The library supports statically sized and dynamically sized vector and matrix
structures with efficient element-wise operations. All the operations are
implemented lazily with Expression Templates, they are only implemented once the
expression is assigned to a concrete structure.</p>
<div class="section" id="data-structures">
<h1>Data structures</h1>
<p>Several structures are available:</p>
<ul class="simple">
<li><code>fast_vector&lt;T, Rows&gt;</code>: A vector of size Rows with elements of type T. This must
be used when you know the size of the vector at compile-time.</li>
<li><code>dyn_vector&lt;T&gt;</code>: A vector with element of type T. The size of the vector can be
set at runtime.</li>
<li><code>fast_matrix&lt;T, Rows,Columns&gt;</code>: A matrix of size Rows x Columns with elements of
type T. This must be used when you know the size of the matrix at
compile-time.</li>
<li><code>dyn_vector&lt;T&gt;</code>: A matrix with element of type T. The size of the matrix can be
set at runtime.</li>
</ul>
<p>All the structures are size-invariant, once set they cannot be grown or
shrinked.</p>
<p>In every operations that involves fast version of the structures, all the sizes
are known at compile-time, this gives the compiler a lot of opportunities for
optimization.</p>
</div>
<div class="section" id="element-wise-operations">
<h1>Element-wise operations</h1>
<p>Classic element-wise operations can be done on vector and matrix as if it was
done on scalars. Matrices and vectors can also be added, subtracted, divided,
...  by scalars.</p>
<p>Here is an example of what can be done:</p>
<pre class="code cpp literal-block">
<span class="n">etl</span><span class="o">::</span><span class="n">dyn_vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">({</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">});</span>
<span class="n">etl</span><span class="o">::</span><span class="n">dyn_vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">({</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">});</span>

<span class="n">etl</span><span class="o">::</span><span class="n">dyn_vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">(</span><span class="mf">1.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">a</span> <span class="o">/</span> <span class="mf">1.2</span><span class="p">);</span>
</pre>
<p>All the operations are only executed once the expression is evaluated to
construct the dyn_vector. No temporaries are involved. This is as efficient as
if a single for loop was used and each element was computed directly.</p>
<p>You can easily assign the same value to a structure by using the operator = on
it.</p>
</div>
<div class="section" id="unary-operators">
<h1>Unary operators</h1>
<p>Several unary operators are available. Each operation is performed on every
element of the vector or the matrix.</p>
<p>Available operators:</p>
<ul class="simple">
<li><code>log</code></li>
<li><code>abs</code></li>
<li><code>sign</code></li>
<li><code>max/min</code></li>
<li><code>sigmoid</code></li>
<li><code>noise</code>: Add standard normal noise to each element</li>
<li><code>logistic_noise</code>: Add normal noise of mean zero and variance sigmoid(x) to each
element</li>
<li><code>exp</code></li>
<li><code>softplus</code></li>
<li><code>bernoulli</code></li>
</ul>
<p>Several transformations are also available:</p>
<ul class="simple">
<li><code>hflip</code>: Flip the vector or the matrix horizontally</li>
<li><code>vflip</code>: Flip the vector or the matrix vertically</li>
<li><code>fflip</code>: Flip the vector or the matrix horizontally and vertically. It is the
equivalent of <code>hflip(vflip(x))</code></li>
<li><code>dim/row/col</code>: Return a vector representing a sub part of a matrix (a row or a
col)</li>
<li><code>reshape</code>: Interpret a vector as a matrix</li>
</ul>
<p>Again, all these operations are performed lazily, they are only executed when the
expression is assigned to something.</p>
</div>
<div class="section" id="lazy-evaluation">
<h1>Lazy evaluation</h1>
<p>All binary and unary operations are applied lazily, only when they are assigned
to a concrete vector or matrix class.</p>
<p>The expression can be evaluated using the <code>s(x)</code> function that returns a
concrete class (fast_vector,fast_matrix,dyn_vector,dyn_matrix) based on the
expression.</p>
</div>
<div class="section" id="reduction">
<h1>Reduction</h1>
<p>Several reduction functions are available:</p>
<ul class="simple">
<li>sum: Return the sum of a vector or matrix</li>
<li>mean: Return the sum of a vector or matrix</li>
<li>dot: Return the dot product of two vector or matrices</li>
</ul>
</div>
<div class="section" id="functions">
<h1>Functions</h1>
<p>The header <em>convolution.hpp</em> provides several convolution operations both in 1D
(vector) and 2D (matrix). All the convolution are available in valid, full and
same versions.</p>
<p>The header <em>mutiplication.hpp</em> provides the matrix multiplication operation
(<code>mmult</code>). For now on, only the naive algorithm is available. I'll
probably add support for Strassen algorithm in the near future.</p>
<p>It is possible to pass an expression rather than an data structure to functions.
You have to keep in mind that expression are lazy, therefore if you pass a + b
to a matrix multiplication, an addition will be run each time an element is
accessed (n^3 times), therefore, it is rarely efficient.</p>
</div>
<div class="section" id="examples">
<h1>Examples</h1>
<p>Here are some examples of these operators (taken from my Machine Learning
Library):</p>
<pre class="code cpp literal-block">
<span class="n">h_a</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">mmul</span><span class="p">(</span><span class="n">reshape</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_visible</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v_a</span><span class="p">),</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">));</span>
<span class="n">h_s</span> <span class="o">=</span> <span class="n">bernoulli</span><span class="p">(</span><span class="n">h_a</span><span class="p">);</span>
</pre>
<pre class="code cpp literal-block">
<span class="n">h_a</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">mmul</span><span class="p">(</span><span class="n">reshape</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_visible</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v_a</span><span class="p">),</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">6.0</span><span class="p">);</span>
<span class="n">h_s</span> <span class="o">=</span> <span class="n">ranged_noise</span><span class="p">(</span><span class="n">h_a</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">);</span>
</pre>
<pre class="code cpp literal-block">
<span class="n">weight</span> <span class="n">exp_sum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">mmul</span><span class="p">(</span><span class="n">reshape</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_visible</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v_a</span><span class="p">),</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">)));</span>

<span class="n">h_a</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">mmul</span><span class="p">(</span><span class="n">reshape</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_visible</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v_a</span><span class="p">),</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="o">/</span> <span class="n">exp_sum</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">max</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max_element</span><span class="p">(</span><span class="n">h_a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">h_a</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">h_s</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="n">h_s</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">h_a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">max</span><span class="p">))</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</pre>
</div>
<div class="section" id="conclusion">
<h1>Conclusion</h1>
<p>This library is available on Github: <a class="reference external" href="https://github.com/wichtounet/etl">etl</a>.
It is licensed under MIT license.</p>
<p>It is header-only, therefore you don't have to build it. However, it uses some
recent C++14 stuff, you'll need a recent version of Clang or G++ to be able to
use it.</p>
<p>If you find an issue or have an idea to improve it, just post it on Github or
as a comment here and I'll do my best to work on that. If you have any question
on the usage of the library, I'd be glad to answer them.</p>
</div>
